<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ivan&#39;s Blog</title>
  
  <subtitle>虽日暮途远，仍梦想诗和远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://doboot.github.io/"/>
  <updated>2020-11-14T06:10:20.952Z</updated>
  <id>http://doboot.github.io/</id>
  
  <author>
    <name>Ivan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从安全SDK的BUG看SpringMVC的参数解析</title>
    <link href="http://doboot.github.io/2019/04/03/cong-an-quan-sdk-de-bug-kan-springmvc-de-can-shu-jie-xi/"/>
    <id>http://doboot.github.io/2019/04/03/cong-an-quan-sdk-de-bug-kan-springmvc-de-can-shu-jie-xi/</id>
    <published>2019-04-03T08:12:00.000Z</published>
    <updated>2020-11-14T06:10:20.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>最近在工作中碰到安全组的同学，在编写一个用于加解密的 <em>Filter</em>时考虑问题不够周全导致的 bug。这个 <em>Filter</em> 的原意是在客户端根据一定的条件将请求的数据进行加密，同时在服务端对数据进行解密。于是，他写了一个 <em>Filter</em> 来过滤请求，部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    SecurityHttpServletRequestWrapper requestWrapper = <span class="keyword">new</span> SecurityHttpServletRequestWrapper(</span><br><span class="line">            (HttpServletRequest) request);</span><br><span class="line">    chain.doFilter(requestWrapper, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>将原始的请求包装成一个自定义的 <em>HttpServletRequestWrapper</em>，并重写了请求中获取参数的方法，以此来达到解密的目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String[]&gt; params;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET =  Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a request object wrapping the given request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the request is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        <span class="keyword">this</span>.params = decodeParams(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码，需要区分版本,验签规则:</span></span><br><span class="line"><span class="comment">     * 1.只签名不加密的情况下，服务器对所有参数验签，所以客户端在调用签名接口后再自行添加的参数会导致服务器验签失败</span></span><br><span class="line"><span class="comment">     * 2.签名且加密的情况下，服务器只对加密部分验签，客户端自行添加的明文参数不会参与验签</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String []&gt; decodeParams(HttpServletRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己定义了一个 Request Map，并对原始参数进行解密，同时覆盖一系列的 <em>getXXX</em> 方法，返回解密后的参数。应该说，在大部分情况下，这个设计是没错的，这也是安全 SDK 运行了好几个版本也没出什么问题的原因。</p><p>但是，我们如果去翻阅 <em>HttpServletRequestWrapper</em> 的源码会发现，这个类的方法数量远不止这么几个 <em>getXXX</em>，如下图所示：</p><p><img src="/images/pasted-110.png" alt="upload successful"></p><p>当然，并不是说这里所有的方法都需要去覆盖重写，但是与加解密安全相关的都必须要进行完整的覆盖，除了之前 SDK 中的 <em>getXXX</em> 之外，还至少应该覆盖如下的 API：</p><ul><li><code>public int getContentLength()</code></li><li><code>public long getContentLengthLong()</code></li><li><code>public ServletInputStream getInputStream() throws IOException</code></li></ul><p>其中：<em>getContentLength()</em> 以及 <em>getContentLengthLong()</em> 是因为加解密的过程势必会导致请求数据的大小发生变化，所以这里要重新计算并返回实际的数据长度。而 <em>getInputStream()</em> 则是因为有一些数据并不是通过 query 参数的方式进行传递的，比如我们今天要讨论的 <em>@RequestBody</em>。</p><p>所以当采用以上 SDK 时，对于常规的参数接入方式完全没有问题，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"vaid"</span>, notes = <span class="string">"获取 VAID"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/vaid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> IdentifierItemDTO <span class="title">queryForVaid</span><span class="params">(@ApiParam(value = <span class="string">"包名"</span>)</span> @RequestParam String packageName,</span></span><br><span class="line"><span class="function">                                      @<span class="title">ApiParam</span><span class="params">(value = <span class="string">"应用 ID"</span>)</span> @RequestParam String appId,</span></span><br><span class="line"><span class="function">                                      @<span class="title">ApiParam</span><span class="params">(value = <span class="string">"签名"</span>)</span> @RequestParam String signature) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果你尝试采用 <em>@RequestBody</em> 来接收参数，则会发生参数无法解析的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"vaid"</span>, notes = <span class="string">"获取 VAID"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/vaid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> IdentifierItemDTO <span class="title">queryForVaid</span><span class="params">(@ApiParam(value = <span class="string">"应用三元组"</span>)</span> @RequestBody AppTriple triple) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <em>@RequestBody</em> 的内容来自于 <em>Request.getInputStream()</em> ，而原 SDK 并没有对这部分数据进行处理。</p><h2 id="2-SpringMVC-的参数处理流程"><a href="#2-SpringMVC-的参数处理流程" class="headerlink" title="2. SpringMVC 的参数处理流程"></a>2. SpringMVC 的参数处理流程</h2><p>如果你用过 Spring2.x 及以下的版本，可能会比较清楚，通常我们在配置 SpringMVC 时，需要手动的给 <em>HandlerAdapter</em> 添加各种 <em>HandlerMethodArgumentResolver</em>，而这个 <em>HandlerMethodArgumentResolver</em> 就是用来处理各类参数转换及绑定的，由于太过久远，我们就不分析2.x版本的实现原理了。</p><h3 id="2-1-RequestMappingHandlerMapping"><a href="#2-1-RequestMappingHandlerMapping" class="headerlink" title="2.1 RequestMappingHandlerMapping"></a>2.1 <code>RequestMappingHandlerMapping</code></h3><p>我们看看从Spring3.x 之后提供的基于 <em>Namespace</em> 的配置方式（原理大同小异）。与 <em>HandlerMethodArgumentResolver</em> 相关的配置如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"resolver.MyResolver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它是包含在 <em>\<a href="mvc:annotation-drive\" target="_blank" rel="noopener">mvc:annotation-drive\</a></em> 中的，所以我们从源头分析起，这个 <em>Namespace</em> 的处理入口类是 <em>MvcNamespaceHandler</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">      registerBeanDefinitionParser(<span class="string">"default-servlet-handler"</span>, <span class="keyword">new</span> DefaultServletHandlerBeanDefinitionParser());</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个节点是由 <em>AnnotationDrivenBeanDefinitionParser</em> 去解析的，在这个解析器里面非常重要的一点是定义了如下的 SpringBean——<code>RequestMappingHandlerMapping</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">Object source = parserContext.extractSource(element);</span><br><span class="line">XmlReaderContext readerContext = parserContext.getReaderContext();</span><br><span class="line"></span><br><span class="line">CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line">RuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);</span><br><span class="line">...</span><br><span class="line">RootBeanDefinition handlerAdapterDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerAdapter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    handlerAdapterDef.setSource(source);</span><br><span class="line">    handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    handlerAdapterDef.getPropertyValues().add(<span class="string">"contentNegotiationManager"</span>, contentNegotiationManager);</span><br><span class="line">    handlerAdapterDef.getPropertyValues().add(<span class="string">"webBindingInitializer"</span>, bindingDef);</span><br><span class="line">    handlerAdapterDef.getPropertyValues().add(<span class="string">"messageConverters"</span>, messageConverters);</span><br><span class="line">    addRequestBodyAdvice(handlerAdapterDef);</span><br><span class="line">    addResponseBodyAdvice(handlerAdapterDef);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Bean 非常重要，是 SpringMVC 的几个核心之一，甚至说是 <strong>最</strong> 核心的也不为过。它定义了<em>数据解析</em>，<em>参数绑定</em>，<em>返回值处理</em>，<em>视图解析</em>，<em>内容绑定</em>，<em>消息转换</em>等等一系列的组件，所以这些组件的相互配合完成了所有 SpringMVC 的使命。</p><h3 id="2-2-HandlerMethodArgumentResolver"><a href="#2-2-HandlerMethodArgumentResolver" class="headerlink" title="2.2 HandlerMethodArgumentResolver"></a>2.2 <code>HandlerMethodArgumentResolver</code></h3><p>上一节提到 <em>RequestMappingHandlerMapping</em> 是整个 SpringMVC 中最核心的组件，而其中整合了我们今天的主角：<em>HandlerMethodArgumentResolver</em>；这个组件主要有两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口，用于将请求中的参数根据相应的配置绑定到方法参数上去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断该策略是否适用于该参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实际解析方法参数的过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">         NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是设计模式中的 <strong>策略模式</strong> 的运用，整个 SpringMVC 中提供了许多的不同场景下的实现，在真正进行参数解析与绑定时，会遍历所有的 <em>Resolver</em> ，调用其 <em>supportsParameter()</em> 方法来确定是否支持当前这个参数的处理，如果支持，则再调用 <em>resolveArgument()</em> 方法来实现真正的参数解析（同时还会进行相应的绑定、转移过程，这利益于方法参数中的 <em>WebDataBinderFactory</em> 的支持）。</p><blockquote><p>注：在 Spring 中，几乎所有的策略模式的实现都是类似这样的，先中收集所有的策略，然后<em>supportsXXX()</em> 方法来确定该策略是否符合当前的场景，最终在符合要求的策略上调用其 <em>executeXXX()</em> 之类的方法来完成真正的能力实现。</p></blockquote><h3 id="2-3-系统自带的-HandlerMethodArgumentResolver"><a href="#2-3-系统自带的-HandlerMethodArgumentResolver" class="headerlink" title="2.3 系统自带的 HandlerMethodArgumentResolver"></a>2.3 系统自带的 <em>HandlerMethodArgumentResolver</em></h3><p>了解了 <em>HandlerMethodArgumentResolver</em> 后我们再回到 <em>RequestMappingHandlerMapping</em> 组件中，看看 SpringMVC 自带了多少的 <em>Resolver</em> ，添加自带 <em>Resolver</em> 的过程在其 <em>afterPropertiesSet()</em> 方法，这个是 SpringBean 的生命周期回调方法（可以参考我另一篇文章<a href="/2015/08/10/spring-zhong-bean-de-sheng-ming-zhou-qi">《Spring中Bean的生命周期》</a>），将在 Bean 构造完成后进行回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加系统自带的各种 ArgumentResolver</span></span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line"><span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看这个获取自带 <em>Resolver</em> 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of argument resolvers to use including built-in resolvers</span></span><br><span class="line"><span class="comment"> * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom arguments</span></span><br><span class="line"><span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Catch-all</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到共分为四类：</p><ul><li>Annotation-based argument resolution：基于注解处理的参数解析器</li><li>Type-based argument resolution：基于类型的参数解析器</li><li>Custom arguments resolution：用户自定义的解析器，<strong>我们在配置文件中添加的自定义解析器</strong> 就属于这类</li><li>Catch-all：其它</li></ul><p>这四个类型囊括了 SpringMVC 中所有的参数解析，使得我们在编写 <em>Controller.method</em> 时，不再需要手动的去 <em>request</em> 中去获取参数，绝大部分情况下只需要定义参数（或者注解参数）即可，而各个不同的 <em>Resolver</em> 会根据我们的定义（注解）完成对应的参数解析与绑定。</p><h2 id="3-RequestBody-的解析"><a href="#3-RequestBody-的解析" class="headerlink" title="3. @RequestBody 的解析"></a>3. <em>@RequestBody</em> 的解析</h2><p>了解了 SpringMVC 对于参数的解析过程后，我们再来看看第一章遇到的问题产生的原因及解决方案：<em>@RequestBody</em> 注解的参数是如何解析绑定定？</p><h3 id="3-1-supportsParameter"><a href="#3-1-supportsParameter" class="headerlink" title="3.1 supportsParameter()"></a>3.1 <code>supportsParameter()</code></h3><p>根据我们前面的分析，在四个参数解析器分类中，<em>@RequestBody</em> 的的解析应该是属于 <strong>基于注解处理的参数解析器</strong> ，所以我们只需要在系统默认注册的那些基于注解处理的参数解析器中去查找分析即可。</p><p>同时，前面也提到，具体哪个 <em>Resolver</em> 会应用到这个参数的解析过程是由其 <em>supportsParameter()</em> 方法来决定的，那么就很容易的找到 <em>RequestResponseBodyMethodProcessor</em> 组件，我们看看它的源码部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只处理标注有 *@RequestBody* 的参数</span></span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常的简单，也很直接的通过 <em>parameter.hasParameterAnnotation(RequestBody.class)</em> 来声明该策略只处理标注有 <em>@RequestBody</em> 的参数；</p><h3 id="3-2-resolveArgument"><a href="#3-2-resolveArgument" class="headerlink" title="3.2 resolveArgument()"></a>3.2 <code>resolveArgument()</code></h3><p>真正解析参数的源码过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment"> * converter to read the content with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析参数并进行相应的转换</span></span><br><span class="line">Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">        </span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line"><span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">validateIfApplicable(binder, parameter);</span><br><span class="line"><span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type paramType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// InputMessage 实际上就是 ServletServerHttpRequest</span></span><br><span class="line">ServletServerHttpRequest inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line"></span><br><span class="line">Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (checkRequired(parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"Required request body is missing: "</span> +</span><br><span class="line">parameter.getMethod().toGenericString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：这里参数中的 <em>InputMessage</em> 实际就是 <em>ServletServerHttpReques</em> ，不要被名字给迷惑了</p></blockquote><p><em>readWithMessageConverters</em> 是最底层的参数解析及转移的过程，这个过程源码相对比较复杂，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the method argument value of the expected parameter type by reading</span></span><br><span class="line"><span class="comment"> * from the given HttpInputMessage.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the expected type of the argument value to be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputMessage the HTTP input message representing the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter descriptor (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetType the target type, not necessarily the same as the method</span></span><br><span class="line"><span class="comment"> * parameter type, e.g. for &#123;<span class="doctag">@code</span> HttpEntity&lt;String&gt;&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the created method argument value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the reading from the request fails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotSupportedException if no suitable message converter is found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type targetType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 MediaType ，即我们请求中的 Content-Type</span></span><br><span class="line">MediaType contentType;</span><br><span class="line"><span class="keyword">boolean</span> noContentType = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">contentType = inputMessage.getHeaders().getContentType();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (contentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">noContentType = <span class="keyword">true</span>;</span><br><span class="line">contentType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数类型，为后续的类型转换器作准备</span></span><br><span class="line">Class&lt;?&gt; contextClass = (parameter != <span class="keyword">null</span> ? parameter.getContainingClass() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;T&gt; targetClass = (targetType <span class="keyword">instanceof</span> Class ? (Class&lt;T&gt;) targetType : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">ResolvableType resolvableType = (parameter != <span class="keyword">null</span> ?</span><br><span class="line">ResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType));</span><br><span class="line">targetClass = (Class&lt;T&gt;) resolvableType.resolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod();</span><br><span class="line">Object body = NO_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 包装一个 EmptyBodyCheckingHttpInputMessage</span></span><br><span class="line">inputMessage = <span class="keyword">new</span> EmptyBodyCheckingHttpInputMessage(inputMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MessageConverter 是参数的转换器</span></span><br><span class="line">        <span class="comment">// 同样的套路，熟悉的模式：策略模式（收集-canXXX()/supportsXX()-doXXX()）</span></span><br><span class="line"><span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line"><span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter;</span><br><span class="line"><span class="keyword">if</span> (genericConverter.canRead(targetType, contextClass, contentType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 读取 body 内容，并进行转换器的前置、后置处理</span></span><br><span class="line"><span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">body = genericConverter.read(targetType, contextClass, inputMessage);</span><br><span class="line">body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (converter.canRead(targetClass, contentType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 读取 body 内容，并进行转换器的前置、后置处理</span></span><br><span class="line"><span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage);</span><br><span class="line">body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"I/O error while reading input message"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (body == NO_VALUE) &#123;</span><br><span class="line"><span class="keyword">if</span> (httpMethod == <span class="keyword">null</span> || !SUPPORTED_METHODS.contains(httpMethod) ||</span><br><span class="line">(noContentType &amp;&amp; inputMessage.getBody() == <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(contentType, <span class="keyword">this</span>.allSupportedMediaTypes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛开 Header 信息处理，分支处理，数据转换等，真正核心的数据都保存在 <code>InputMessage.getBody()</code>，而这个<em>InputMessage</em> 实际上就是 <em>ServletServerHttpRequest</em>，所以我们看看 <em>ServletServerHttpRequest.getBody()</em> 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过表单提交数据</span></span><br><span class="line"><span class="keyword">if</span> (isFormPost(<span class="keyword">this</span>.servletRequest)) &#123;</span><br><span class="line"><span class="keyword">return</span> getBodyFromServletRequestParameters(<span class="keyword">this</span>.servletRequest);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 直接在 body 里面提交数据</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.servletRequest.getInputStream();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分了两种场景：</p><ul><li><p>通过表单提交：判定的依据是 <em>content-type=”application/x-www-form-urlencoded”</em>，同时 <em>httpMethod=POST</em>，这个时候，会将所有的表单序列化成字节流。如下所示：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use &#123;<span class="doctag">@link</span> javax.servlet.ServletRequest#getParameterMap()&#125; to reconstruct the</span></span><br><span class="line"><span class="comment"> * body of a form 'POST' providing a predictable outcome as opposed to reading</span></span><br><span class="line"><span class="comment"> * from the body, which can fail if any other code has used the ServletRequest</span></span><br><span class="line"><span class="comment"> * to access a parameter, thus causing the input stream to be "consumed".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InputStream <span class="title">getBodyFromServletRequestParameters</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">Writer writer = <span class="keyword">new</span> OutputStreamWriter(bos, FORM_CHARSET);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String[]&gt; form = request.getParameterMap();</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; nameIterator = form.keySet().iterator(); nameIterator.hasNext();) &#123;</span><br><span class="line">String name = nameIterator.next();</span><br><span class="line">List&lt;String&gt; values = Arrays.asList(form.get(name));</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; valueIterator = values.iterator(); valueIterator.hasNext();) &#123;</span><br><span class="line">String value = valueIterator.next();</span><br><span class="line">writer.write(URLEncoder.encode(name, FORM_CHARSET));</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">writer.write(<span class="string">'='</span>);</span><br><span class="line">writer.write(URLEncoder.encode(value, FORM_CHARSET));</span><br><span class="line"><span class="keyword">if</span> (valueIterator.hasNext()) &#123;</span><br><span class="line">writer.write(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nameIterator.hasNext()) &#123;</span><br><span class="line">writer.append(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">writer.flush();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>通过 body 提交：直接返回 <em>ServletRequest.getInputStream()</em> 即可</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>根据以上的分析，我们很清楚的知道了第一节中提到的 BUG 的问题根源所在：<em>@RequestBody</em> 参数的绑定是由 <em>RequestResponseBodyMethodProcessor</em> 完成的，而 <em>RequestResponseBodyMethodProcessor</em> 在进行 <em>resolveArgument</em> 时会通过 <em>ServletRequest.getInputStream()</em> 读取数据流，从而完成最终的数据转换、绑定。而安全 SDK 并没有对 <em>ServletRequest.getInputStream()</em> 进行任何的支持，从而导致读取的数据（加密后）不符合 <em>application/json</em> 的格式规范，进而抛出异常。</p><p>知道原因后解决的方案就比较清晰了，就是在加解密的时候对于 <em>ServletRequest.getInputStream()</em> 数据同样要进行相应的处理。</p><p>当然，更严谨的来说，前面提到的 <em>getContentLength()</em>，<em>getContentLengthLong()</em> 最好也要进行处理，虽然这里并没有涉及到这两个方法的执行。但 <strong>对于一些网络相关的优化或者压缩支持的时候，这两个方法是非常重要的，当实际的数据长度和这两个方法返回的数据不一致，会导致一些丢包或者数据展示不全的 bug</strong> 。</p><h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h2><p>现在 Spring/SpringBoot 的更新迭代与优化后，框架的自动化程度越来越高，编写 Spring 相关的应用会越来越简单，提高了开发的生产效率。</p><p>但是，另一方面，过多的自动化，过多的细节隐藏导致的后果是越来越多的人不知道背后的原理，一旦出现问题时手足无措，不知道从哪里开始分析与排查。</p><p>所以，这里建议，<strong>想要真正学好用好 Spring 框架，可以尝试使用 Spring1.x/2.x 的版本去写一些测试 demo 应用。这两个版本的 Spring 配置过程比较复杂，各个组件都需要自己去配置，关联关系都需要自己去维护，但正因为如此，开发者更能够理解各个组件的功能、之间的依赖关系，更能够从底层的去了解 Spring 的运行原理。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述&quot;&gt;&lt;/a&gt;1. 问题描述&lt;/h2&gt;&lt;p&gt;最近在工作中碰到安全组的同学，在编写一个用于加解密的 &lt;em&gt;Filter&lt;/em&gt;时考虑问题不够周全导致的 bug。这个 &lt;em&gt;Filter&lt;/em&gt; 的原意是在客户端根据一定的条件将请求的数据进行加密，同时在服务端对数据进行解密。于是，他写了一个 &lt;em&gt;Filter&lt;/em&gt; 来过滤请求，部分代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SecurityHttpServletRequestWrapper requestWrapper = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SecurityHttpServletRequestWrapper(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (HttpServletRequest) request);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chain.doFilter(requestWrapper, response);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://doboot.github.io/tags/SpringMVC/"/>
    
      <category term="源码阅读" scheme="http://doboot.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码解读——启动篇</title>
    <link href="http://doboot.github.io/2018/12/20/springboot-yuan-ma-jie-du-qi-dong-pian/"/>
    <id>http://doboot.github.io/2018/12/20/springboot-yuan-ma-jie-du-qi-dong-pian/</id>
    <published>2018-12-20T11:54:00.000Z</published>
    <updated>2020-11-14T06:10:20.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文主要基于SpringBoot-2.1.0.RELEASE版本分析其启动过程，以及如何完成自动配置的过程。学习理解SpringBoot是如何将我们从繁重的配置文件中解救出来的。</p><p>为了演示重点和缩短文章，文中的代码引用通常会省略掉非讲解点的代码。</p></blockquote><a id="more"></a><h3 id="一、示例及入口"><a href="#一、示例及入口" class="headerlink" title="一、示例及入口"></a>一、示例及入口</h3><p>​    一个典型的SpringBoot的应用的入口代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot2ExampleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Boot2ExampleApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果你了解过SpringBoot或者在哪里看到过SpringBoot应用的样子（你也可以在<a href="https://start.spring.io/" target="_blank" rel="noopener">SPRING INITIALIZR</a>生成一个最简单的模板应用），一定会惊叹于它的简洁与强大。</p><p>​    从代码也能看出，所有有关SpringBoot的魔法，都隐藏<code>@SpringBootApplication</code>和<code>SpringApplication.run</code>中，接下来我们将从这两个概念入手，逐步分析出SpringBoot的运行原理。</p><h3 id="二、-SpringBootApplication的解析"><a href="#二、-SpringBootApplication的解析" class="headerlink" title="二、@SpringBootApplication的解析"></a>二、<code>@SpringBootApplication</code>的解析</h3><p>​    这是SpringBoot应用的初始入口注解，定义的核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line"><span class="comment">// 各种属性...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到它其实是一个组合其它注解的入口而已，其重点在于上面的3个注解：<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>。其中<code>@ComponentScan</code>可能大家很熟悉，它相当于我们之前在XML配置中的<code>&lt;context:component-scan&gt;</code>节点，主要用来扫描我们通过<strong>JavaConfig</strong>方式定义的SpringBean。而<code>@EnableAutoConfiguration</code>我们打开其源码会发现它只是一个标记接口，仅仅是开启了<strong>JavaConfig</strong>能力，并没有什么魔法。我们会重点讲解<code>@EnableAutoConfiguration</code>这个注解，因为<strong>SpringBoot</strong>的重点就在于自动配置，而最终的实现手段就来自于这个注解。</p><p>​    如下是<code>@EnableAutoConfiguration</code>的核心源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个注解本身也没有什么实际的功能，仅仅只是定义了自动配置过程中想要<strong>exclude</strong>的类，而真正完成自动配置的过程都在它自身的注解<code>@Import(AutoConfigurationImportSelector.class)</code>上。</p><p>​    <code>@Import</code>我们知道是一个从其它<strong>JavaConfig</strong>类装载SpringBean定义的注解，所以我们的注意力要放在<code>AutoConfigurationImportSelector</code>，看看它里面有什么功能。其核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="comment">// 省略非关注点代码...</span></span><br><span class="line">AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(</span><br><span class="line">autoConfigurationMetadata, annotationMetadata);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> AutoConfigurationEntry&#125; based on the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125;</span></span><br><span class="line"><span class="comment"> * of the importing &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoConfigurationMetadata the auto-configuration metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略非关注点代码...</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the &#123;<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; to load configuration</span></span><br><span class="line"><span class="comment"> * candidates.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the factory class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="comment">// 加载到所有 EnableAutoConfiguration 工厂</span></span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    一路看下来，我们发现所有的重点都落在了<code>SpringFactoriesLoader.loadFactoryNames</code>方法中，所做的一切就是从<code>SpringFactoriesLoader</code>中查找所有的<code>EnableAutoConfiguration</code>工厂。</p><p>​    我们再看看<code>SpringFactoriesLoader</code>的核心代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有JAR包中的 spring.factories 位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load and instantiate the factory implementations of the given type from</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given class loader.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The returned factories are sorted through &#123;<span class="doctag">@link</span> AnnotationAwareOrderComparator&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a custom instantiation strategy is required, use &#123;<span class="doctag">@link</span> #loadFactoryNames&#125;</span></span><br><span class="line"><span class="comment"> * to obtain all registered factory names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading (can be &#123;<span class="doctag">@code</span> null&#125; to use the default)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if any factory implementation class cannot</span></span><br><span class="line"><span class="comment"> * be loaded or if an error occurs while instantiating any factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactoryNames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line"><span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryClassName = factoryClass.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">        <span class="comment">// 扫描并加载所有的 spring.factories</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryClassName, factoryName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    至此，<code>@SpringBootApplication</code>的核心代码执行完成，我们发现它仅仅只是做了一件事情：</p><blockquote><p><strong>扫描所有JAR包中 <em>META-INF/spring.factories</em> 文件中配置的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>来完成各个组件的自动化配置</strong></p></blockquote><p>​    我们后面会讲解这个自动化配置的过程，已经<strong>spring.factories</strong>文件的格式、内容以及功能。我们暂时先放下<code>@SpringBootApplication</code>，先来看看SpringBoot魔法的另外一个支点<code>SpringApplication.run</code>的执行过程。</p><h3 id="三、SpringApplication-run的解析"><a href="#三、SpringApplication-run的解析" class="headerlink" title="三、SpringApplication.run的解析"></a>三、<code>SpringApplication.run</code>的解析</h3><pre><code>#### 关键路径源码分析</code></pre><p>​    在分析这个方法之前，我们先来看看<code>SpringApplication</code>这个类的构造方法，看看它做了什么事情，其核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意如下的2行代码，分别用来设置容器的初始化工作和监听器的</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们看到<code>setInitializers</code>和<code>setListeners</code>这两个方法其实都是调用了<code>getSpringFactoriesInstances</code>方法，只不过一个是获取初始化的组件，一个是获取监听器组件。我们跟进去看看这个方法是如何做的，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这行代码</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    </span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    怎么样，是不是很眼熟，我们又一次看到了<code>SpringFactoriesLoader.loadFactoryNames</code>的调用，只不过这一次不是获取<code>EnableAutoConfiguration</code>，而是<code>ApplicationContextInitializer</code>和<code>ApplicationListener</code>。但是最终的来源仍然是：<strong>各个JAR包中的 spring.factories</strong>，这个文件大有玄机，后面我们重点分析，现在大家只要知道在初始化的时候会读取这个文件就行了。</p><p>​    我们再来真正进入<code>SpringApplication.run</code>方法看看它做了什么，辗转几次之后，其核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 获取运行监听器并启动</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">        <span class="comment">// 2. 准备环境信息，并从环境信息中配置需要忽略掉的 Bean 配置</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 打印 Banner，这个可以自定义</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">        </span><br><span class="line">context = createApplicationContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 获取异常报告器</span></span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 准备 ApplicationContext 并刷新</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 通知监听器</span></span><br><span class="line">listeners.started(context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7. 执行 ApplicationRunner 和 CommandLineRunner</span></span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.1 执行 SpringApplication 构造方法中收集到的 Initializer</span></span><br><span class="line">applyInitializers(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其中第 1，4 步故技重施地从 <strong>spring.factories</strong> 中读取了<code>SpringApplicationRunListener</code>和<code>SpringBootExceptionReporter</code>的配置。第 2，5，6 步是Spring容器的标准构建启动过程，在这里不做讲述，有兴趣的同学可以关注我对Spring源码的研究文章。</p><p>​    我们重点讲解一下第 3 步<strong>Banner的处理</strong>和第 7 步 <strong>ApplicationRunner</strong> 的处理，因为这两个步骤在我们实际应用过程中经常会直接接触到。</p><h4 id="Banner-的处理"><a href="#Banner-的处理" class="headerlink" title="Banner 的处理"></a>Banner 的处理</h4><p>​    我们在启动一个SpringBoot的应用时，会在控制台打印如下的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::        (v2.1.0.RELEASE)</span><br></pre></td></tr></table></figure><p>​    这个就是默认的Banner信息，我们从源码看看这个Banner内容是怎么生成及怎么定制，其核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">printBanner</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Banner.Mode.OFF) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">ResourceLoader resourceLoader = (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>)</span><br><span class="line">? <span class="keyword">this</span>.resourceLoader : <span class="keyword">new</span> DefaultResourceLoader(getClassLoader());</span><br><span class="line">SpringApplicationBannerPrinter bannerPrinter = <span class="keyword">new</span> SpringApplicationBannerPrinter(</span><br><span class="line">resourceLoader, <span class="keyword">this</span>.banner);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Mode.LOG) &#123;</span><br><span class="line"><span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, logger);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到是通过<code>SpringApplicationBannerPrinter</code>来打印这些信息的，那么这个类里面又是如何确定这些内容及如何去定制呢，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文本类 Banner 的路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BANNER_LOCATION_PROPERTY = <span class="string">"spring.banner.location"</span>;</span><br><span class="line"><span class="comment">// 图片类 Banner 的路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BANNER_IMAGE_LOCATION_PROPERTY = <span class="string">"spring.banner.image.location"</span>;</span><br><span class="line"><span class="comment">// 默认的 Banner 信息存放的文件名</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_BANNER_LOCATION = <span class="string">"banner.txt"</span>;</span><br><span class="line"><span class="comment">// 图片类 Banner 支持的文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] IMAGE_EXTENSION = &#123; <span class="string">"gif"</span>, <span class="string">"jpg"</span>, <span class="string">"png"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Banner <span class="title">print</span><span class="params">(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Banner 信息</span></span><br><span class="line">Banner banner = getBanner(environment);</span><br><span class="line">banner.printBanner(environment, sourceClass, out);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PrintedBanner(banner, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">getBanner</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">Banners banners = <span class="keyword">new</span> Banners();</span><br><span class="line">banners.addIfNotNull(getImageBanner(environment));</span><br><span class="line">banners.addIfNotNull(getTextBanner(environment));</span><br><span class="line"><span class="keyword">if</span> (banners.hasAtLeastOneBanner()) &#123;</span><br><span class="line"><span class="keyword">return</span> banners;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.fallbackBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.fallbackBanner;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 系统默认的 Banner</span></span><br><span class="line"><span class="keyword">return</span> DEFAULT_BANNER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文本类 Banner</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">getTextBanner</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">String location = environment.getProperty(BANNER_LOCATION_PROPERTY,</span><br><span class="line">DEFAULT_BANNER_LOCATION);</span><br><span class="line">Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(location);</span><br><span class="line"><span class="keyword">if</span> (resource.exists()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResourceBanner(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片类 Banner</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">getImageBanner</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">String location = environment.getProperty(BANNER_IMAGE_LOCATION_PROPERTY);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(location);</span><br><span class="line"><span class="keyword">return</span> resource.exists() ? <span class="keyword">new</span> ImageBanner(resource) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String ext : IMAGE_EXTENSION) &#123;</span><br><span class="line">Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(<span class="string">"banner."</span> + ext);</span><br><span class="line"><span class="keyword">if</span> (resource.exists()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ImageBanner(resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到，其默认的Banner信息是从<code>classpath:banner.txt</code>文件中读取的，那么我们只需要在这个路径的文件中填写我们想要的内容即可完成Banner的定制化了。</p><p>​    同时，从源码我们可以看到，这个Banner是支持图片的，也就是我们可以指定一个图片文件作为Banner，SpringBoot会自动将图片转换成 ascII 字符图形来展示。</p><p>​    更厉害的是，最近的SpringBoot Banner还可以支持动画，我们在图片文件后缀中看到了<code>.gif</code>，感兴趣的话可以在<code>ImageBanner</code>源码中学习SpringBoot是如何进行这个转换的。</p><p>​    最后，我们看看系统默认的Banner类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringBootBanner</span> <span class="keyword">implements</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BANNER = &#123; <span class="string">""</span>,</span><br><span class="line"><span class="string">"  .   ____          _            __ _ _"</span>,</span><br><span class="line"><span class="string">" /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\"</span>,</span><br><span class="line"><span class="string">"( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\"</span>,</span><br><span class="line"><span class="string">" \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )"</span>,</span><br><span class="line"><span class="string">"  '  |____| .__|_| |_|_| |_\\__, | / / / /"</span>,</span><br><span class="line"><span class="string">" =========|_|==============|___/=/_/_/_/"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_BOOT = <span class="string">" :: Spring Boot :: "</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRAP_LINE_SIZE = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBanner</span><span class="params">(Environment environment, Class&lt;?&gt; sourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">PrintStream printStream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String line : BANNER) &#123;</span><br><span class="line">printStream.println(line);</span><br><span class="line">&#125;</span><br><span class="line">String version = SpringBootVersion.getVersion();</span><br><span class="line">version = (version != <span class="keyword">null</span>) ? <span class="string">" (v"</span> + version + <span class="string">")"</span> : <span class="string">""</span>;</span><br><span class="line">StringBuilder padding = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (padding.length() &lt; STRAP_LINE_SIZE</span><br><span class="line">- (version.length() + SPRING_BOOT.length())) &#123;</span><br><span class="line">padding.append(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT,</span><br><span class="line">AnsiColor.DEFAULT, padding.toString(), AnsiStyle.FAINT, version));</span><br><span class="line">printStream.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    是不是看到了我们熟悉的启动 Banner 图案。</p><h4 id="ApplicationRunner与CommandLineRunner的使用"><a href="#ApplicationRunner与CommandLineRunner的使用" class="headerlink" title="ApplicationRunner与CommandLineRunner的使用"></a><code>ApplicationRunner</code>与<code>CommandLineRunner</code>的使用</h4><p>​    这一节我们讲解在启动流程中的第 7 步：ApplicationRunner 是如何工作的。</p><p>​    在启动流程中我们看到，这是整个启动流程的最后一个环节了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7. 执行 ApplicationRunner</span></span><br><span class="line">callRunners(context, applicationArguments);</span><br></pre></td></tr></table></figure><p>​    我们可以跟踪进去看看这个<code>callRunners</code>方法做了什么，其核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从Spring容器中获取 ApplicationRunner</span></span><br><span class="line">runners.addAll(context.getBeansOfType(ApplicationRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从Spring容器中获取 CommandLineRunner</span></span><br><span class="line">runners.addAll(context.getBeansOfType(CommandLineRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经过排序后，依次执行这些接口的 run 方法</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line"><span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line"><span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">callRunner((ApplicationRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">callRunner((CommandLineRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(ApplicationRunner runner, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">(runner).run(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute ApplicationRunner"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到这是SpringBoot容器在启动完成后给我们提供的扩展接口，如果我们在实际的应用场景中有一些操作（比如数据初始化之类的）需要在容器启动后执行，那么这两个地方就是我们的扩展点。</p><blockquote><p>好像是同样的功能点，SpringBoot提供了两个不同的操作，那么它们有什么区别，什么时候该用哪个呢？</p><p><strong>答案是：没有区别</strong></p><p>从源码中我们也看到了，唯一的区别是这两个接口接受参数的方式不同，一个是原始的<code>String[]</code>，一个是格式化好的<code>ApplicationArguments</code>，用户可以根据自己的喜好和场景随意选择。</p></blockquote><h3 id="四、spring-factories-解析"><a href="#四、spring-factories-解析" class="headerlink" title="四、spring.factories 解析"></a>四、<code>spring.factories</code> 解析</h3><p>​    在前文中我们提到<code>@SpringBootApplication</code>的核心作用是扫描所有JAR包中 <em>META-INF/spring.factories</em> 文件中配置的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>来完成各个组件的自动化配置。同时，在<code>SpringApplicaiton.run</code>的启动过程中，也多次通过<code>SpringFactoriesLoader.loadFactoryNames</code>从<em>META-INF/spring.factories</em>中加载各类预定义的组件（初始化器、监听器等）。那么这个文件究竟长什么样，里面都有哪些东西呢？下面我们就通过真实的实例来讲解，如下代码提取（有省略）自<code>spring-boot-autoconfig-2.1.0.RELEAST/META-INFO/spring.factories</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure><p>​    可以看到，这份主要分为 7 个部分，注意，这 7 个部分并非所有的 <strong>spring.factories</strong> 文件都会有，实际上每个部分都是可选的。这 7 个部分刚刚我们在源码分析中也见过一些了，分别是：</p><ul><li><p><strong>Initializers</strong>：应用初始化器，在应用初始化的时候执行。</p></li><li><p><strong>Application Listeners</strong>：应用监听器，监听应用启动的各个事件。</p></li><li><p><strong>Auto Configuration Import Listeners</strong>：自动配置引入时的监听器。</p></li><li><p><strong>Auto Configuration Import Filters</strong>：自动配置时的过滤器。</p></li><li><p><strong>Auto Configure</strong>：自动配置类，这个类别非常重要，它定义了各种需要自动配置的模板，这里只是摘取了一小部分，从源码中可以看到这个配置中包含了几乎所有目前能看到的（能集成）的框架，目前的版本一共有<strong><em>超过100</em></strong>个配置类。</p></li><li><p><strong>Failure analyzers</strong>：这个定义了启动过程中的失败处理器，它将用于分析失败的原因，则将一些诊断信息所示给用户，协助用户解决问题。</p></li><li><p><strong>Template availability providers</strong>：这里定义了一些模板引擎的支持，用于判定当前系统中是否支持一些模板引擎。非常遗憾的是，由于<strong><em>Velocity</em></strong>的疏于维护，在<strong>SpringBoot1.5</strong>的时候被除名，不再提供官方的支持了。需要的同学可以自行去扩展，或者<a href="mailto:huangfengjing@gmail.com" target="_blank" rel="noopener">联系我</a>。</p></li></ul><p>我们可以随便打开一个<strong>auto configure</strong>项，例如我们在传统<strong>Spring</strong>应用中熟知的<code>JdbcTemplateAutoConfiguration</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">JdbcTemplate</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnSingleCandidate</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">DataSourceAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">JdbcProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcTemplateAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> JdbcProperties properties;</span><br><span class="line"></span><br><span class="line">JdbcTemplateConfiguration(DataSource dataSource, JdbcProperties properties) &#123;</span><br><span class="line"><span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line"><span class="keyword">this</span>.properties = properties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(JdbcOperations<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">JdbcTemplate</span> <span class="title">jdbcTemplate</span>() </span>&#123;</span><br><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(<span class="keyword">this</span>.dataSource);</span><br><span class="line">JdbcProperties.Template template = <span class="keyword">this</span>.properties.getTemplate();</span><br><span class="line">jdbcTemplate.setFetchSize(template.getFetchSize());</span><br><span class="line">jdbcTemplate.setMaxRows(template.getMaxRows());</span><br><span class="line"><span class="keyword">if</span> (template.getQueryTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">jdbcTemplate.setQueryTimeout((<span class="keyword">int</span>) template.getQueryTimeout().getSeconds());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到，当系统中<code>@ConditionalOnMissingBean(JdbcOperations.class)</code>时，它会为我们创建一个<code>JdbcTemplate</code>，这样我们就可以直接在项目中使用 <code>@Autowired</code> 注入了。</p><blockquote><p>实际上，<strong>spring.factories</strong> 只是一个普通的 <strong>properties</strong>文件，里面的内容也是可以随意定制的，只不过<strong>SpringBoot</strong>用作了自动配置，给我们提供了一个范例。这 7 个部分也仅仅只是 <strong>spring-boot-autoconfigure</strong>所需要的，很多其它的第三方JAR包中的 <strong>spring.factories</strong> 会定义很多自己需要的配置。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，我们以源码解读的试完整地讲解了整个<strong>SpringBoot</strong>的启动过程。讲解了如何从<code>@SpringBootApplication</code>注解找到所有自动配置的类并完成配置过程，也从<code>SpringApplication.run</code>的执行过程中重现了<strong>SpringBoot</strong>应用在启动过程中的各个生命周期。也讲解了项目中常见的扩展点，以及如何去扩展我们的应用能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要基于SpringBoot-2.1.0.RELEASE版本分析其启动过程，以及如何完成自动配置的过程。学习理解SpringBoot是如何将我们从繁重的配置文件中解救出来的。&lt;/p&gt;
&lt;p&gt;为了演示重点和缩短文章，文中的代码引用通常会省略掉非讲解点的代码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://doboot.github.io/tags/SpringBoot/"/>
    
      <category term="源码阅读" scheme="http://doboot.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读与定制化</title>
    <link href="http://doboot.github.io/2018/12/20/ding-zhi-hua-de-le-qu/"/>
    <id>http://doboot.github.io/2018/12/20/ding-zhi-hua-de-le-qu/</id>
    <published>2018-12-20T11:26:15.000Z</published>
    <updated>2020-11-14T06:10:20.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>SpringFramework</code>，<code>Acegi(SpringSecurity)</code>，<code>Tomcat</code>，<code>SpringBoot</code>，<code>SpringCloud(部分)</code>, <code>Jetty</code>，<code>Velocity</code>，<code>MyBatis/Generator</code>，<code>Quercus(PHP in Java)</code>，<code>Guava</code>，<code>Android(UI部分)</code></p><h3 id="源码阅读的目的"><a href="#源码阅读的目的" class="headerlink" title="源码阅读的目的"></a>源码阅读的目的</h3><ol><li>分析与解决 BUG（Quercus）</li><li>寻找隐藏的交互方式（Spring）</li><li>弥补文档的不完善性（非著名项目）</li><li>扩展与定制（Velocity，MyBatis/Generator等）</li><li>安全性检查（Quercus）</li><li>学习（Spring, Tomcat, Android-UI）</li></ol><a id="more"></a><h3 id="源码阅读的方式"><a href="#源码阅读的方式" class="headerlink" title="源码阅读的方式"></a>源码阅读的方式</h3><ol><li>确定目标对象（建立自信 OR 被打击自信）</li><li>分析主脉络</li><li>分步调试</li><li>从抽象到具体</li></ol><h3 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h3><ol><li><p>Ali-Tomcat</p><p> 对 Tomcat 的增加，比如对于ClasaLoader并行加载的补丁<code>ClassLoader.registerAsParallelCapable</code>，并合入Tomcat7.0.65。另外就是对于HSF（High-Speed Service Framework）的支持。</p></li><li><p>Ali-JVM</p></li><li><p>PHP Support in Java</p></li><li><p>更全面的代码生成器</p></li><li><p>SpringBoot之兼容Velocity</p></li><li><p>权限平台的Boot化</p></li></ol><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>Tomcat -&gt; 容器组件构架模型，生命周期管理与事件处理模型，以及 Pipeline 模型</p><p>Quercus, Binlog -&gt; 协议的理解与实现</p><p>Android -&gt; 分而治之与事件管理</p><p>Spring全家桶 -&gt; 几乎囊括了所有的设计模式和架构模型</p><p>Tomcat 生命周期管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">           start()</span><br><span class="line"> -----------------------------</span><br><span class="line"> |                           |</span><br><span class="line"> | init()                    |</span><br><span class="line">NEW -»-- INITIALIZING        |</span><br><span class="line">| |           |              |     ------------------«-----------------------</span><br><span class="line">| |           |auto          |     |                                        |</span><br><span class="line">| |          \|/    start() \|/   \|/     auto          auto         stop() |</span><br><span class="line">| |      INITIALIZED --»-- STARTING_PREP --»- STARTING --»- STARTED --»---  |</span><br><span class="line">| |         |                                                            |  |</span><br><span class="line">| |destroy()|                                                            |  |</span><br><span class="line">| --»-----«--    ------------------------«--------------------------------  ^</span><br><span class="line">|     |          |                                                          |</span><br><span class="line">|     |         \|/          auto                 auto              start() |</span><br><span class="line">|     |     STOPPING_PREP ----»---- STOPPING ------»----- STOPPED -----»-----</span><br><span class="line">|    \|/                               ^                     |  ^</span><br><span class="line">|     |               stop()           |                     |  |</span><br><span class="line">|     |       --------------------------                     |  |</span><br><span class="line">|     |       |                                              |  |</span><br><span class="line">|     |       |    destroy()                       destroy() |  |</span><br><span class="line">|     |    FAILED ----»------ DESTROYING ---«-----------------  |</span><br><span class="line">|     |                        ^     |                          |</span><br><span class="line">|     |     destroy()          |     |auto                      |</span><br><span class="line">|     --------»-----------------    \|/                         |</span><br><span class="line">|                                 DESTROYED                     |</span><br><span class="line">|                                                               |</span><br><span class="line">|                            stop()                             |</span><br><span class="line">----»-----------------------------»------------------------------</span><br></pre></td></tr></table></figure><p><img src="E:\分享与培训\Java编译模型.png" alt="Java编译模型"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SpringFramework&lt;/code&gt;，&lt;code&gt;Acegi(SpringSecurity)&lt;/code&gt;，&lt;code&gt;Tomcat&lt;/code&gt;，&lt;code&gt;SpringBoot&lt;/code&gt;，&lt;code&gt;SpringCloud(部分)&lt;/code&gt;, &lt;code&gt;Jetty&lt;/code&gt;，&lt;code&gt;Velocity&lt;/code&gt;，&lt;code&gt;MyBatis/Generator&lt;/code&gt;，&lt;code&gt;Quercus(PHP in Java)&lt;/code&gt;，&lt;code&gt;Guava&lt;/code&gt;，&lt;code&gt;Android(UI部分)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码阅读的目的&quot;&gt;&lt;a href=&quot;#源码阅读的目的&quot; class=&quot;headerlink&quot; title=&quot;源码阅读的目的&quot;&gt;&lt;/a&gt;源码阅读的目的&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;分析与解决 BUG（Quercus）&lt;/li&gt;
&lt;li&gt;寻找隐藏的交互方式（Spring）&lt;/li&gt;
&lt;li&gt;弥补文档的不完善性（非著名项目）&lt;/li&gt;
&lt;li&gt;扩展与定制（Velocity，MyBatis/Generator等）&lt;/li&gt;
&lt;li&gt;安全性检查（Quercus）&lt;/li&gt;
&lt;li&gt;学习（Spring, Tomcat, Android-UI）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="源码阅读" scheme="http://doboot.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>PATCH与PUT and POST</title>
    <link href="http://doboot.github.io/2018/12/19/patch-yu-put-yi-ji-post-de-qu-bie/"/>
    <id>http://doboot.github.io/2018/12/19/patch-yu-put-yi-ji-post-de-qu-bie/</id>
    <published>2018-12-19T06:34:08.000Z</published>
    <updated>2020-11-14T06:10:20.930Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>另外：区分PATCH与PUT、POST方法</p><p>　　在HTTP原本的定义中[RFC2616]，用于上传数据的方法只有POST和PUT。后来鉴于POST和PUT语义和功能上的不足，又加入了PATCH方法[RFC5789]。POST与PUT方法的差异是显而易见的，而PUT与PATCH方法就比较相似，但它们的用法却完全不同。</p><a id="more"></a><p>　　PUT方法和PATCH方法所请求的目标地址都是直接指向资源的，而POST方法请求的目标是一个行为处理器，这点很容易区分。但PUT和PATCH呢？根据规范中所介绍的PUT用于替换资源，而PATCH用于更新部分资源。仅凭这个描述，我无法理解他们的区别，直到看到后面介绍PATCH是非幂等的时候才恍然大悟。</p><p>　　从这里开始要考虑一个问题，PATCH为什么是非幂等的呢？POST方法非幂等可以理解，因为它请求服务器执行一个动作，多次发起请求可能导致动作多次执行。而像PATCH这样请求的目标是一个资源的，如果它只是更新一个资源，不执行其它动作，又何来不幂等呢？其实是我忽略了一个问题，PATCH方法和POST方法有个很相似的地方，它们的实体部分都是结构化的数据。POST方法的实体结构一般是 multipart/form-data 或 application/x-www-form-urlencoded 而PATCH方法的实体结构则随其它规范定义。这和PUT方法的无结构实体相比就是最大的区别。</p><p>　　PUT方法的实体无结构的，它直接把实体部分的数据替换到服务器的资源上。而PATCH提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的数据。也就是说，PATCH请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是不幂等的了。</p><p>　　举个例子，如果服务器上有个资源/abc.int，里面存放一个整数，值为 1。也就是说，GET这个资源的话，服务器响应的实体只包含了 1 这个数字。现在在自己的框架中定义当提交PATCH请求，实体匹配^+\d+$的格式时就对服务器资源中的数字执行一个加法操作。于是当客户端向/abc.int地址发起PATCH请求，实体部分为+3之后，服务器的/abc.int资源中的数据就变成 4，也就是说，GET它会得到 4。如果客户端不小心重复提交了PATCH请求，那么+3就会被再执行一次，这个资源的数据就变成 7。</p><p>　　这么一看，PATCH和PUT的区别就非常明显了吧。</p><p>序号        方法        描述</p><p>1        GET        请求指定的页面信息，并返回实体主体。</p><p>2        HEAD        类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</p><p>3        POST        向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p><p>4        PUT        从客户端向服务器传送的数据取代指定的文档的内容。</p><p>5        DELETE        请求服务器删除指定的页面。</p><p>6        CONNECT        HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p>7        OPTIONS        允许客户端查看服务器的性能。</p><p>8        TRACE        回显服务器收到的请求，主要用于测试或诊断。</p><p>9        PATCH        实体中包含一个表，表中说明与该URI所表示的原内容的区别。</p><p>10        MOVE        请求服务器将指定的页面移至另一个网络地址。</p><p>11        COPY        请求服务器将指定的页面拷贝至另一个网络地址。</p><p>12        LINK        请求服务器建立链接关系。</p><p>13        UNLINK        断开链接关系。</p><p>14        WRAPPED        允许客户端发送经过封装的请求。</p><p>15        Extension-mothed        在不改动协议的前提下，可增加另外的方法。</p><p>草案规范：<a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5789</a></p><p><a href="https://tools.ietf.org/html/rfc5789#section-2" target="_blank" rel="noopener">2</a>.  The PATCH Method</p><p>The PATCH method requests that a set of changes described in the<br>​    request entity be applied to the resource identified by the Request-<br>​    URI.  The set of changes is represented in a format called a “patch<br>​    document” identified by a media type.  If the Request-URI does not<br>​    point to an existing resource, the server MAY create a new resource,<br>​    depending on the patch document type (whether it can logically modify<br>​    a null resource) and permissions, etc.</p><p>Dusseault &amp; Snell            Standards Track                    [Page 2]</p><p> <a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">RFC 5789</a>                       HTTP PATCH                     March 2010</p><p>The difference between the PUT and PATCH requests is reflected in the<br>​    way the server processes the enclosed entity to modify the resource<br>​    identified by the Request-URI.  In a PUT request, the enclosed entity<br>​    is considered to be a modified version of the resource stored on the<br>​    origin server, and the client is requesting that the stored version<br>​    be replaced.  With PATCH, however, the enclosed entity contains a set<br>​    of instructions describing how a resource currently residing on the<br>​    origin server should be modified to produce a new version.  The PATCH<br>​    method affects the resource identified by the Request-URI, and it<br>​    also MAY have side effects on other resources; i.e., new resources<br>​    may be created, or existing ones modified, by the application of a<br>​    PATCH.</p><p>PATCH is neither safe nor idempotent as defined by [<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC2616</a>], <a href="https://tools.ietf.org/html/rfc5789#section-9.1" target="_blank" rel="noopener">Section</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;另外：区分PATCH与PUT、POST方法&lt;/p&gt;
&lt;p&gt;　　在HTTP原本的定义中[RFC2616]，用于上传数据的方法只有POST和PUT。后来鉴于POST和PUT语义和功能上的不足，又加入了PATCH方法[RFC5789]。POST与PUT方法的差异是显而易见的，而PUT与PATCH方法就比较相似，但它们的用法却完全不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Restfule" scheme="http://doboot.github.io/tags/Restfule/"/>
    
      <category term="HttpMethod" scheme="http://doboot.github.io/tags/HttpMethod/"/>
    
  </entry>
  
  <entry>
    <title>在Spring中实现类似SpringBoot的环境检测能力</title>
    <link href="http://doboot.github.io/2018/12/17/zai-spring-zhong-shi-xian-lei-si-springboot-de-huan-jing-jian-ce-neng-li/"/>
    <id>http://doboot.github.io/2018/12/17/zai-spring-zhong-shi-xian-lei-si-springboot-de-huan-jing-jian-ce-neng-li/</id>
    <published>2018-12-17T11:43:27.000Z</published>
    <updated>2020-11-14T06:10:20.960Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>​    在<a href="http://km.vivo.xyz/pages/viewpage.action?pageId=38237577" target="_blank" rel="noopener">Boot 你的应用</a>一文中提到了有时候我们需要检测当前时环境是否匹配我们的运行时要求，并根据不同的环境进行个性化的适配。</p><p>​    <strong>Spring4</strong>已经引入了简单的扩展接口 <code>@Conditional</code>和<code>Condition</code>，允许大家自行去识别环境信息，但也仅此而已，并没有内置一些可以让大家在实际场景中使用的条件判定器。</p><p>​    真正将 <code>@Conditional</code>和<code>Condition</code>发扬光大的是<strong>SpringBoot</strong>，在<strong>SpringBoot</strong>是全面采用了 <code>AutoConfiguration</code>和 <code>@Conditional</code>将自动配置的强大功能展现得淋漓尽致，内置了超过<strong><em>10</em></strong>种不同类型支持超过<strong><em>100</em></strong>种不同场景的环境检测器。比如：检测当前环境中是否存在某个Class，检测当前容器中是否定义了某个SpringBean，检测当前是否有某个配置项，配置项的值是多少等等。所有的环境检测器都在 <code>org.springframework.boot.autoconfigure.condition</code> 下面，大家可以去翻阅源码学习了解。</p></blockquote><a id="more"></a><h3 id="Conditional-与-Condition-介绍"><a href="#Conditional-与-Condition-介绍" class="headerlink" title="@Conditional 与 Condition 介绍"></a>@Conditional 与 Condition 介绍</h3><p>​    前文提到在 Spring 框架中仅仅提供了这两个扩展点，并没有能运用在实际应用场景中的环境检测器，这一节我们将分析这两个接口，并实现一个简单的环境检测功能。</p><p>​    以下是<code>@Conditional</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates that a component is only eligible for registration when all</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #value() specified conditions&#125; match.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &lt;em&gt;condition&lt;/em&gt; is any state that can be determined programmatically</span></span><br><span class="line"><span class="comment"> * before the bean definition is due to be registered (see &#123;<span class="doctag">@link</span> Condition&#125; for details).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125; annotation may be used in any of the following ways:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;as a type-level annotation on any class directly or indirectly annotated with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125;, including &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;as a meta-annotation, for the purpose of composing custom stereotype</span></span><br><span class="line"><span class="comment"> * annotations&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;as a method-level annotation on any &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; method&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class is marked with &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125;, all of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods, &#123;<span class="doctag">@link</span> Import <span class="doctag">@Import</span>&#125; and &#123;<span class="doctag">@link</span> ComponentScan <span class="doctag">@ComponentScan</span>&#125;</span></span><br><span class="line"><span class="comment"> * annotations associated with that class will be subject to the conditions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;<span class="doctag">NOTE:</span> &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125; annotations are not inherited; any conditions from</span></span><br><span class="line"><span class="comment"> * superclasses or from overridden methods are not being considered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Condition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * All &#123;<span class="doctag">@link</span> Condition&#125;s that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</span></span><br><span class="line"><span class="comment"> * in order for the component to be registered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这是一个注解，从注释中我们看到这是 <code>@Since 4.0</code> 的，即在 Spring4 开始提供的，用来<strong><em>指定一系列的配置条件</em></strong>，当所有指定的条件都满足时，被 <code>@Configuration</code> 中标注的 <code>@Bean</code>，<code>@Import</code>，<code>@ComponentScan</code>才会生效。</p><p>​    它接受一个<code>Condition</code>数组，用来标记所有的筛选条件，当所有的<code>Condition.matches</code>条件均返回<code>true</code>时即可认为该<code>Conditional</code>成立，从而完成环境检测。</p><p>​    <code>Condition</code>接口只有一个方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A single &#123;<span class="doctag">@code</span> condition&#125; that must be &#123;<span class="doctag">@linkplain</span> #matches matched&#125; in order</span></span><br><span class="line"><span class="comment"> * for a component to be registered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Conditions are checked immediately before the bean-definition is due to be</span></span><br><span class="line"><span class="comment"> * registered and are free to veto registration based on any criteria that can</span></span><br><span class="line"><span class="comment"> * be determined at that point.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Conditions must follow the same restrictions as &#123;<span class="doctag">@link</span> BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * and take care to never interact with bean instances. For more fine-grained control</span></span><br><span class="line"><span class="comment"> * of conditions that interact with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; beans consider the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurationCondition&#125; interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationCondition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Conditional</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionContext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if the condition matches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata metadata of the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> false&#125; to veto registration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    只需要实现<code>matches</code>方法并根据自己的需要完成环境检测判定即可。</p><p>​    </p><h3 id="简单用法示例"><a href="#简单用法示例" class="headerlink" title="简单用法示例"></a>简单用法示例</h3><p>​    下面我们用一个小的示例来演示这两个接口的使用方法，假设需求：<strong><em>根据不同的操作系统注册不同的 MXBean 服务</em></strong></p><h4 id="1-实现在不同操作系统环境下的条件判定"><a href="#1-实现在不同操作系统环境下的条件判定" class="headerlink" title="1. 实现在不同操作系统环境下的条件判定"></a>1. 实现在不同操作系统环境下的条件判定</h4><p>​    这个过程我们就简化地判定当前的<code>os.name</code>就可以，代码如下：</p><p><strong><em>Windows 环境的判定器</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定当前环境是否为 Windows 的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * created on 2018/12/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Linux 环境的判定器</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定当前环境是否为 Windows 的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * created on 2018/12/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Linux"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-在Bean注册时带上条件注解"><a href="#2-在Bean注册时带上条件注解" class="headerlink" title="2. 在Bean注册时带上条件注解"></a>2. 在Bean注册时带上条件注解</h4><p>​    有了第1步的的条件判定器，那么在我们进行 <code>@Configuraiton</code>的Bean注册时就可以将这些条件附带上，让Spring容器根据不同的条件加载不同的Bean配置。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据不同的操作系统加载不同的 MXBean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * created on 2018/12/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalMXBeanConifg</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(WindowsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">BaseMXBean</span> <span class="title">windowsMXBeanService</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsMXBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">BaseMXBean</span> <span class="title">linuxMXBeanService</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinuxMXBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上的配置，在不同的操作系统环境下，Spring会分别注册不同的 MXBean 。</p><h3 id="高级用法示例"><a href="#高级用法示例" class="headerlink" title="高级用法示例"></a>高级用法示例</h3><p>​    在简单用法示例中我们可以看到，虽然实现了不同环境下的判定识别，但还是太简单了，还是比较静态的，如果我们要像<strong>SpringBoot</strong>那样动态的判定当前环境中是否存在某个类，Spring容器中是否存在某个Bean定义该怎么做呢？下面我们将演示这几种更高级的用法。</p><h4 id="判定当前-classpath-下是否存在某个类"><a href="#判定当前-classpath-下是否存在某个类" class="headerlink" title="判定当前 classpath 下是否存在某个类"></a>判定当前 classpath 下是否存在某个类</h4><p>​    这类条件判定器主要用在一些模板类SDK中，根据当前用户是否依赖了某些类来确定是否要定义相应的模板、工具、服务等。如同<a href="http://km.vivo.xyz/pages/viewpage.action?pageId=38239820" target="_blank" rel="noopener">应用分发 base-boot-starter 的使用说明</a>中对于 OA 权限平台的判定一样，当用户没有添加OA权限平台这个MAVEN依赖时，应用仍然能智能判定而不是抛出 <code>NoClassDefFoundError</code>。</p><ol><li><p>首先定义一个自定义的注解，供用户使用判定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否存在某个类的条件判定注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Time: 2018/12/7 : 19:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(OnClassCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">ConditionalOnClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须存在的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 必须存在的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须存在的类名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 必须存在的类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>当用户在注解某个<code>@Bean</code>进，可以添加这个注解来进行判定。这个注解本身还依赖另外一个注解<code>@Conditional(OnClassCondition.class)</code>，表示扫Spring容器在扫描到某个类定义被标注了<code>@ConditionalOnClass</code>时，会执行里面的<code>OnClassCondition</code>来完成条件判定。</p><ol start="2"><li><p>定义真正的条件判定器 <code>OnClassCondition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定某个类是否存在的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Time: 2018/12/7 : 19:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnClassCondition</span> <span class="keyword">extends</span> <span class="title">BaseCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; attributes = metadata</span><br><span class="line">                .getAllAnnotationAttributes(ConditionalOnClass<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == attributes) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addAll(candidates, attributes.get(<span class="string">"value"</span>));</span><br><span class="line">        addAll(candidates, attributes.get(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String candidate : candidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ClassUtils.isPresent(candidate, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也很简单，就是从注解中获取当前用户要判定是否存在的Class（支持类定义，和全类名），然后在当前 classpath 下去查找这个类是否存在即完成判定过程。</p></li><li><p>使用自定义的注解</p><p>使用起来就比较简单了，加上注解即可，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(SSOFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SsoAutoConfiguration</span> </span>&#123;...｝</span><br></pre></td></tr></table></figure></li></ol><h4 id="判定当前Spring容器中是否定义了某个Bean"><a href="#判定当前Spring容器中是否定义了某个Bean" class="headerlink" title="判定当前Spring容器中是否定义了某个Bean"></a>判定当前Spring容器中是否定义了某个Bean</h4><p>​    这类判定主要用在如下的场景：某些组件需要依赖某个SpringBean，如果当前Spring容器中不存在这个Bean，那么就要添加一个，如果存在就不能再添加，防止产生<code>NoSuchBeanDefinitionException</code>或者<code>NoUniqueBeanDefinitionException</code>异常。</p><p>​    其实现过程其实和<code>@ConditionalOnClass</code>大同小异，最主要的区别在于<code>Condition.matches</code>方法一个是判定类是否存在，一个是判定Bean是否存在。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定某个 bean 是否存在的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Time: 2018/12/7 : 19:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnBeanCondition</span> <span class="keyword">extends</span> <span class="title">BaseCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; conditionOnBeanAttrs = metadata</span><br><span class="line">                .getAllAnnotationAttributes(ConditionalOnBean<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != conditionOnBeanAttrs) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchBean(context, conditionOnBeanAttrs, metadata);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; conditionOnMissingBeanAttrs = metadata</span><br><span class="line">                .getAllAnnotationAttributes(ConditionalOnMissingBean<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (conditionOnMissingBeanAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchMissingBean(context, conditionOnMissingBeanAttrs, metadata);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchBean</span><span class="params">(ConditionContext context, MultiValueMap&lt;String, Object&gt; attributes, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (attributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; classNameCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addAll(classNameCandidates, attributes.get(<span class="string">"value"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String clsName : classNameCandidates) &#123;</span><br><span class="line">                beanFactory.getBean(Class.forName(clsName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.debug(<span class="string">"没有找到需要的 Bean: &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; beanNameCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addAll(beanNameCandidates, attributes.get(<span class="string">"name"</span>));</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNameCandidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beanFactory.containsBean(beanName)) &#123;</span><br><span class="line">                log.debug(<span class="string">"没有找到需要的 bean: &#123;&#125;"</span>, beanName);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchMissingBean</span><span class="params">(ConditionContext context, MultiValueMap&lt;String, Object&gt; attributes, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 和 matchBean 相反，判定是否不存在某个 Bean，省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文主要讲解了如何通过<code>@Conditional</code>和<code>Condition</code>实现环境检测的能力，并从源码及示例两方面演示了从简单到高级的用法支持。其它的诸如判定当时配置项中的值以及资源判定的实现原理都差不多，感兴趣的可以翻阅应用分发 <code>base-boot-starter</code> 的源码。</p><blockquote><p>当然，这里高级应用里面的判定规则并不如SpringBoot中的功能强大，但应付常规的应用已经足够，当不满足需求时，通过本文的讲解读者应该也已经了解到了如何自行扩展，或者<a href="mailto:huangfengjing@gmail.com" target="_blank" rel="noopener">联系我</a>协助。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;​    在&lt;a href=&quot;http://km.vivo.xyz/pages/viewpage.action?pageId=38237577&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Boot 你的应用&lt;/a&gt;一文中提到了有时候我们需要检测当前时环境是否匹配我们的运行时要求，并根据不同的环境进行个性化的适配。&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Spring4&lt;/strong&gt;已经引入了简单的扩展接口 &lt;code&gt;@Conditional&lt;/code&gt;和&lt;code&gt;Condition&lt;/code&gt;，允许大家自行去识别环境信息，但也仅此而已，并没有内置一些可以让大家在实际场景中使用的条件判定器。&lt;/p&gt;
&lt;p&gt;​    真正将 &lt;code&gt;@Conditional&lt;/code&gt;和&lt;code&gt;Condition&lt;/code&gt;发扬光大的是&lt;strong&gt;SpringBoot&lt;/strong&gt;，在&lt;strong&gt;SpringBoot&lt;/strong&gt;是全面采用了 &lt;code&gt;AutoConfiguration&lt;/code&gt;和 &lt;code&gt;@Conditional&lt;/code&gt;将自动配置的强大功能展现得淋漓尽致，内置了超过&lt;strong&gt;&lt;em&gt;10&lt;/em&gt;&lt;/strong&gt;种不同类型支持超过&lt;strong&gt;&lt;em&gt;100&lt;/em&gt;&lt;/strong&gt;种不同场景的环境检测器。比如：检测当前环境中是否存在某个Class，检测当前容器中是否定义了某个SpringBean，检测当前是否有某个配置项，配置项的值是多少等等。所有的环境检测器都在 &lt;code&gt;org.springframework.boot.autoconfigure.condition&lt;/code&gt; 下面，大家可以去翻阅源码学习了解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://doboot.github.io/tags/SpringMVC/"/>
    
      <category term="SpringBoot" scheme="http://doboot.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>油画里的乡愁</title>
    <link href="http://doboot.github.io/2018/11/22/you-hua-li-de-xiang-chou/"/>
    <id>http://doboot.github.io/2018/11/22/you-hua-li-de-xiang-chou/</id>
    <published>2018-11-22T07:56:00.000Z</published>
    <updated>2020-11-14T06:10:20.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-52.png" alt="upload successful"></p><p>本篇油画是画家李自健的作品，他以自己的童年生活为素材，画出了中国乡土文明中的人性光辉，也画出了刻骨的乡愁。<strong>在那个已逝的美丽时代，物质尽管匮乏，但不乏温暖，我们都是从那个时代走过来的，内心深处最真实的记忆，很温馨的回忆。如果也能引起你的共鸣，那么庆幸你拥有着如此美丽的乡愁</strong>，虽然那时候没有游戏机电视机，但是你有牛有狗有鸡猫，有山有水有鱼虾，你的童年拥有整个大自然最纯净的部分，比现在孩子的童年更幸福！<br><a id="more"></a></p><p><img src="/images/pasted-53.png" alt="upload successful"><br>拔刺儿，没有穿鞋，脚被磨破了——这代价我们曾经愿意付出，很感慨！</p><p><img src="/images/pasted-54.png" alt="upload successful"></p><p>姐姐的故事还没讲完就听睡着了。那时候，哪里都可以安静无虑的睡觉</p><p><img src="/images/pasted-55.png" alt="upload successful"></p><p>小狗陪伴河边憧憬，安静的疑望远方……想起了什么？</p><p><img src="/images/pasted-56.png" alt="upload successful"></p><p>是劳动也是玩耍，真是天真无邪</p><p><img src="/images/pasted-57.png" alt="upload successful"></p><p>那时从小就开始劳动了</p><p><img src="/images/pasted-58.png" alt="upload successful"></p><p>听泉的汶川女娃，小时的发呆也是一片片的期盼</p><p><img src="/images/pasted-59.png" alt="upload successful"></p><p>割草，干活也辛苦靠在姐姐就睡着了，现在的孩子已经没有多的兄弟姐妹了，这些画让我好怀念啊！</p><p><img src="/images/pasted-60.png" alt="upload successful"></p><p>还是姐姐呵护着——放牛，暮归的老牛是我们的同伴</p><p><img src="/images/pasted-61.png" alt="upload successful"></p><p>那时学的很多，也会做很多……</p><p><img src="/images/pasted-62.png" alt="upload successful"></p><p>感慨的童年，心酸的年代，很……</p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>憧憬，从小就会做很多的事情，到河边洗衣服……</p><p><img src="/images/pasted-64.png" alt="upload successful"></p><p>最熟悉的背，是姐姐的，对了，不要忘了她，我们最忠诚的亲人……</p><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>兄妹情深相依相靠很感动！不禁留下了泪水！曾经的纯真童年如今竟变成无处安放的回忆！</p><p><img src="/images/pasted-66.png" alt="upload successful"></p><p>勾起了埋藏的记忆，确实被触动了。一些内心深处的东西，因为我们小时都这样骑牛</p><p><img src="/images/pasted-67.png" alt="upload successful"></p><p>美好的年代，淳朴的民风，很感人，尤其是那姐、那狗、那牛、那山、那水、那些美好的童年时光……</p><p><img src="/images/pasted-68.png" alt="upload successful"></p><p>放牛娃</p><p><img src="/images/pasted-69.png" alt="upload successful"></p><p>草垛</p><p><img src="/images/pasted-70.png" alt="upload successful"></p><p>太累了</p><p><img src="/images/pasted-71.png" alt="upload successful"></p><p>山溪</p><p><img src="/images/pasted-72.png" alt="upload successful"></p><p>抓小鸡</p><p><img src="/images/pasted-73.png" alt="upload successful"></p><p>摘苹果</p><p><img src="/images/pasted-74.png" alt="upload successful"></p><p>读书</p><p><img src="/images/pasted-75.png" alt="upload successful"></p><p>洗衣服</p><p><img src="/images/pasted-76.png" alt="upload successful"></p><p>门神</p><p><img src="/images/pasted-77.png" alt="upload successful"></p><p>姐弟</p><p><img src="/images/pasted-78.png" alt="upload successful"></p><p>攀爬</p><p><img src="/images/pasted-79.png" alt="upload successful"></p><p>赤脚过河</p><p><img src="/images/pasted-80.png" alt="upload successful"></p><p>守推车</p><p><img src="/images/pasted-81.png" alt="upload successful"></p><p>洗个脚</p><p><img src="/images/pasted-82.png" alt="upload successful"></p><p>开心一刻</p><p><img src="/images/pasted-83.png" alt="upload successful"></p><p>喂饭</p><p><img src="/images/pasted-84.png" alt="upload successful"></p><p>姐弟</p><p><img src="/images/pasted-85.png" alt="upload successful"></p><p>割草</p><p><img src="/images/pasted-86.png" alt="upload successful"></p><p>和稀泥</p><p><img src="/images/pasted-87.png" alt="upload successful"></p><p>雀儿飞过</p><p><img src="/images/pasted-88.png" alt="upload successful"></p><p>春回大地</p><p><img src="/images/pasted-89.png" alt="upload successful"></p><p>自个玩</p><p><img src="/images/pasted-90.png" alt="upload successful"></p><p>啼晓</p><p><img src="/images/pasted-91.png" alt="upload successful"></p><p>初春的阳光</p><p><img src="/images/pasted-92.png" alt="upload successful"></p><p>眠</p><blockquote><p><strong>油画作者</strong>：<strong>李自建</strong>，著名的旅美画家，1954年生于湖南邵阳，1982年毕业于广州美术学院油画系，1988年移居美国洛杉矶。 现为中国艺术研究院中国油画院海外特聘画家、中国美术家协会会员、美国油画家协会会员。20年来，持续于六大洲三十个国家与地区举办大型环球巡回个展，自主、自费，以现实主义油画艺术巡展传播人性与爱普世价值，弘扬中华文化精神，影响广泛，瞩目画坛。国际和平特别贡献奖章及欧洲拜占庭“圣·约翰骑士勋章”获得者。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/pasted-52.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇油画是画家李自健的作品，他以自己的童年生活为素材，画出了中国乡土文明中的人性光辉，也画出了刻骨的乡愁。&lt;strong&gt;在那个已逝的美丽时代，物质尽管匮乏，但不乏温暖，我们都是从那个时代走过来的，内心深处最真实的记忆，很温馨的回忆。如果也能引起你的共鸣，那么庆幸你拥有着如此美丽的乡愁&lt;/strong&gt;，虽然那时候没有游戏机电视机，但是你有牛有狗有鸡猫，有山有水有鱼虾，你的童年拥有整个大自然最纯净的部分，比现在孩子的童年更幸福！&lt;br&gt;
    
    </summary>
    
    
      <category term="油画" scheme="http://doboot.github.io/tags/%E6%B2%B9%E7%94%BB/"/>
    
      <category term="童年" scheme="http://doboot.github.io/tags/%E7%AB%A5%E5%B9%B4/"/>
    
      <category term="乡愁" scheme="http://doboot.github.io/tags/%E4%B9%A1%E6%84%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码解读——打包启动器原理</title>
    <link href="http://doboot.github.io/2018/10/23/springboot-yuan-ma-jie-du-da-bao-qi-dong-qi-yuan-li/"/>
    <id>http://doboot.github.io/2018/10/23/springboot-yuan-ma-jie-du-da-bao-qi-dong-qi-yuan-li/</id>
    <published>2018-10-23T13:22:00.000Z</published>
    <updated>2020-11-14T06:10:20.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>SpringBoot</strong>提供了非常多的非常好用的特性，比如内置容器，一键运行，注解驱动，内置监控等等。其中一个非常吸引人也非常便捷的特性就是一键启动：即<strong>将应用打包成一个可执行的JAR，并直接启动运行</strong>；</p></blockquote><p>很多初学者都会比较困惑，SpringBoot是如何做到将应用代码和所有的依赖打包成一个独立的JAR并运行的，因为传统的开发方式如果要将应用打包成独立的JAR并通过<em>java -jar</em>命令的话，需要通过<em>-classpath</em>属性来指定依赖。我们今天就来分析讲解一下SpringBoot的打包、启动及运行的原理；</p><a id="more"></a><h2 id="1-SpringBoot打包插件"><a href="#1-SpringBoot打包插件" class="headerlink" title="1. SpringBoot打包插件"></a>1. SpringBoot打包插件</h2><p>我们先看一下SpringBoot打包后的结构是什么样的，打开target目录我们发现有两个jar包：</p><ol><li><em>boot2-example-0.0.1-SNAPSHOT.jar</em>：46.6MB</li><li><em>boot2-example-0.0.1-SNAPSHOT.jar.original</em>：52KB</li></ol><p>其中，<em>boot2-example-0.0.1-SNAPSHOT.jar</em>是通过SpringBoot提供的打包插件采用新的格式打成一体化的Jar，包含了所有的依赖，所以比较大，有<strong>46.6MB</strong>；而<em>boot2-example-0.0.1-SNAPSHOT.jar.original</em>则是Java原生的打包方式生成的，仅仅只包含了项目本身的内容，没有依赖，所以比较小，52KB。</p><p>简单的从大小来看也知道52KB的原生Jar包是不可能独立的运行的，想要通过这个Jar包运行的话，必须要通过<em>-classpath</em>来指定所需要的依赖路径；</p><p>而 SpringBoot 插件打出来的包就可以独立运行，因为它将所依赖的包也一同包括进来了，通过一定的组织结构和定制的 <em>ClassLoader</em> 实现了 <strong>Jar in Jar</strong> 的加载与执行；</p><p>我们通过<strong>Archetype</strong>或者通过<a href="http://start.spring.io" target="_blank" rel="noopener">http://start.spring.io</a>新建一个SpringBoot应用的时候，在<em>pom.xml</em>中我们都会看到SpringBoot内置的Maven打包插件，如所示（这是完整的插件配置，并不在项目的<em>pom.xml</em>，实际上它定义在<em>spring-boot-starter-parent</em>中）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>$&#123;start-class&#125;<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>感兴趣的同学可以去翻阅一下这个插件打包的源码，了解是怎么组织最终的代码结构的，这里我们只需要了解到其独特的包结构是通过这个插件打包出来的就行，我们重点分析最终打好的包，并分析SpringBoot是怎么运行起来的；</p><h2 id="2-SpringBoot-FatJar-的组织结构"><a href="#2-SpringBoot-FatJar-的组织结构" class="headerlink" title="2. SpringBoot FatJar 的组织结构"></a>2. SpringBoot FatJar 的组织结构</h2><p>我们将<strong>SpringBoot</strong>打的可执行Jar展开后的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.yml</span><br><span class="line">│   │   ├── com</span><br><span class="line">│   │   │   └── doleje</span><br><span class="line">│   │   │       └── boot2</span><br><span class="line">│   │   │           └── example</span><br><span class="line">│   │   └── i18n</span><br><span class="line">│   │       ├── message.properties</span><br><span class="line">│   │       ├── message_en_US.properties</span><br><span class="line">│   │       └── message_zh_CN.properties</span><br><span class="line">│   └── lib</span><br><span class="line">│       ├── spring-boot-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-autoconfigure-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-configuration-processor-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-aop-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-cache-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-data-jpa-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-jdbc-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-json-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-logging-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-security-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-tomcat-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-web-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── ...</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   ├── maven</span><br><span class="line">│   │   └── com.dole.framework</span><br><span class="line">│   │       └── boot2-example</span><br><span class="line">│   │           ├── pom.properties</span><br><span class="line">│   │           └── pom.xml</span><br><span class="line">│   └── spring-configuration-metadata.json</span><br><span class="line">├── org</span><br><span class="line">│   └── springframework</span><br><span class="line">│       └── boot</span><br><span class="line">│           └── loader</span><br><span class="line">│               ├── ExecutableArchiveLauncher.class</span><br><span class="line">│               ├── JarLauncher.class</span><br><span class="line">│               ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">│               ├── LaunchedURLClassLoader.class</span><br><span class="line">│               ├── Launcher.class</span><br><span class="line">│               ├── MainMethodRunner.class</span><br><span class="line">│               ├── ...</span><br></pre></td></tr></table></figure><ul><li>BOOT-INF：包含了我们的项目代码（<strong>classes</strong>目录），以及所需要的依赖（<strong>lib</strong> 目录）</li><li>META-INF：常见的Jar包元信息，我们的启动信息将在这里配置</li><li>org.springframework.boot.loader：SpringBoot的加载器代码，实现的<strong>Jar in Jar</strong>加载的魔法源</li></ul><p>我们看到，如果去掉<strong>BOOT-INF</strong>目录，这将是一个非常普通且标准的Jar包，包括元信息以及可执行的代码部分，其<em>/META-INF/MAINFEST.MF</em>指定了Jar包的启动元信息，<strong>org.springframework.boot.loader</strong>执行对应的逻辑操作。</p><h2 id="3-META-INF-MAINFEST-MF-元信息分析"><a href="#3-META-INF-MAINFEST-MF-元信息分析" class="headerlink" title="3. /META-INF/MAINFEST.MF 元信息分析"></a>3. /META-INF/MAINFEST.MF 元信息分析</h2><p>元信息内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: boot2-example</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Built-By: ivan</span><br><span class="line">Implementation-Vendor-Id: com.dole.framework</span><br><span class="line">Spring-Boot-Version: 2.1.0.RELEASE</span><br><span class="line">Implementation-Vendor: DoLe Team</span><br><span class="line"></span><br><span class="line"># 整个Jar包的执行入口</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br><span class="line"></span><br><span class="line"># 定义了应用的入口</span><br><span class="line">Start-Class: com.doleje.boot2.example.Boot2ExampleApplication</span><br><span class="line"></span><br><span class="line"># 定义了应用的代码目录</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line"></span><br><span class="line"># 定义了应用所依赖的库目录</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line"></span><br><span class="line">Created-By: Apache Maven 3.3.9</span><br><span class="line">Build-Jdk: 1.8.0_191</span><br><span class="line">Implementation-URL: https://projects.spring.io/spring-boot/#/spring-bo</span><br><span class="line"> ot-starter-parent/dole-boot2-parent/boot2-example</span><br></pre></td></tr></table></figure><p>根据上面的注释我们了解到，除了一些常规提版本信息之外，主要指定了：</p><ol><li>两个入口：一个用于执行标准的<em>java -jar</em>命令，一个用于查询真正的业务入口类；</li><li>两个目录：一个用于指定加载应用类的入口，一个指定了应用的依赖库，即我们所说的<em>-classpath</em>；</li></ol><h2 id="4-JarLauncher"><a href="#4-JarLauncher" class="headerlink" title="4. JarLauncher"></a>4. JarLauncher</h2><p>根据上一段落的讲解，我们知道在通过独立<em>java -jar</em>执行时，是一个标准的Jar执行过程，即通过<em>MAINFEST.MF</em>的定义进入到我们的<em>Main-Class</em>进行执行，即：<em>org.springframework.boot.loader.JarLauncher</em>，注意这个类不在我们的应用中，也不在<strong>SpringBoot</strong>的基础框架中，所以我们直接在应用代码中是找不到这个类的，如果想看这个类的源码，我们可以将下面的依赖加入到项目中去：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-loader<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>JarLauncher</em>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarLauncher</span> <span class="keyword">extends</span> <span class="title">ExecutableArchiveLauncher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_CLASSES = <span class="string">"BOOT-INF/classes/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_LIB = <span class="string">"BOOT-INF/lib/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JarLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">JarLauncher</span><span class="params">(Archive archive)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(archive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line"><span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> JarLauncher().launch(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类比较简单，真正的启动逻辑都在其父类中（两级父类<em>ExecutableArchiveLauncher</em>&amp;<em>Launcher</em>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutableArchiveLauncher</span> <span class="keyword">extends</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Archive archive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先把启动流程放一放，来看看这里出现的一个很重要的一个概念：<em>Archive</em>。</p><p>archive即归档文件，这个概念在linux下比较常见，通常就是一个tar/zip格式的压缩包，jar是zip格式。<br>在spring boot里，抽象出了Archive的概念，一个archive可以是一个jar（JarFileArchive），也可以是一个文件目录（ExplodedArchive）。可以理解为Spring boot抽象出来的统一访问资源的层。</p><p>上面的demo-0.0.1-SNAPSHOT.jar 是一个Archive，然后demo-0.0.1-SNAPSHOT.jar里的/lib目录下面的每一个Jar包，也是一个Archive，就是嵌套的 Archive 概念。</p><p>每个 Archive 有一个自己的 URL，便于 ClassLoader 来加载，标准的 Java Archive 提供的 URL 如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/</span><br></pre></td></tr></table></figure><p>以 <em>!/</em> 分隔，且只支持一个，不支持嵌套，而 SpringBoot 对其的扩展后的 URL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar:file:/demo/target/demo-0.0.1-SNAPSHOT.jar!/lib/spring-beans-4.2.3.RELEASE.jar!/META-INF/MANIFEST.MF</span><br></pre></td></tr></table></figure><p>可以看到以 <em>!/</em>分隔的 Jar in Jar 的资源表达方式。</p><p>当然，标准的 ClassLoader 是不支持这种资源 URL 格式的，而为了支持这种 Jar in Jar 的嵌套资源，SpringBoot 实现了自己扩展的 ClassLoader。</p><p>构建 Archive 的代码在 <em>Launcher</em> 里面，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Archive <span class="title">createArchive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">   CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">   URI location = (codeSource != <span class="keyword">null</span>) ? codeSource.getLocation().toURI() : <span class="keyword">null</span>;</span><br><span class="line">   String path = (location != <span class="keyword">null</span>) ? location.getSchemeSpecificPart() : <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to determine code source archive"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   File root = <span class="keyword">new</span> File(path);</span><br><span class="line">   <span class="keyword">if</span> (!root.exists()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"Unable to determine code source archive from "</span> + root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (root.isDirectory() ? <span class="keyword">new</span> ExplodedArchive(root)</span><br><span class="line">         : <span class="keyword">new</span> JarFileArchive(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见最后一行，如果是目录的话将会创建 <em>ExplodedArchive</em>，否则将会创建一个 <em>JarFileArchive</em>。</p><h2 id="5-LaunchedURLClassLoader"><a href="#5-LaunchedURLClassLoader" class="headerlink" title="5. LaunchedURLClassLoader"></a>5. LaunchedURLClassLoader</h2><p>前面提到 SpringBoot 定义了一种嵌套的 Jar in Jar 格式，这种格式是不被标准的 Java ClassLoader 所支持，这就需要自定义的 ClassLoader 来完成这种内嵌的资源加载。</p><p>一般来说 ClassLoader 除了加载 Java 字节码生成类之外，还需要加载指定的资源。SpringBoot 的扩展 ClassLoader 是 <em>LaunchedURLClassLoader</em>，入口地址仍然在 <em>Launcher</em> 中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application. This method is the initial entry point that should be</span></span><br><span class="line"><span class="comment"> * called by a subclass &#123;<span class="doctag">@code</span> public static void main(String[] args)&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the incoming arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the application fails to launch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   JarFile.registerUrlProtocolHandler();</span><br><span class="line">   ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">   launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果知道了资源的格式（自己定义的，当然知道），再根据规则来自定义实现相应的 <em>ClassLoader</em> 是一件非常容易的事情，只需要实现 <em>ClassLoader.findResource</em> 并根据规则来返回资源的路由即可。SpringBoot 通过定义了一个 <em>URLStreamHandler</em> 来实现这种资源的查找与路由，具体的实现过程可以查阅 <em>org.springframework.boot.loader.jar.Handler</em>，这里不再帖出来了。</p><p>而 <em>Handler</em> 是如何和我们的资源关联起来的呢，这部分代码是在 <em>JarFile.getUrl()</em> 方法里面，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a URL that can be used to access this JAR file. <span class="doctag">NOTE:</span> the specified URL</span></span><br><span class="line"><span class="comment"> * cannot be serialized and or cloned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException if the URL is malformed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.url == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Handler handler = <span class="keyword">new</span> Handler(<span class="keyword">this</span>);</span><br><span class="line">      String file = <span class="keyword">this</span>.rootFile.getFile().toURI() + <span class="keyword">this</span>.pathFromRoot + <span class="string">"!/"</span>;</span><br><span class="line">      file = file.replace(<span class="string">"file:////"</span>, <span class="string">"file://"</span>); <span class="comment">// Fix UNC paths</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 关联定制的 Handler 以处理 Jar in Jar 的资源路由</span></span><br><span class="line">      <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(<span class="string">"jar"</span>, <span class="string">""</span>, -<span class="number">1</span>, file, handler);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>JarFile</em> 组成了我们的 <em>JarFileArchive</em>，而我们的 <em>JarFile</em> 在执行 <em>getUrl()</em> 时，会通过之前定义好的 <em>Handler</em> 来完成嵌套资源的路由，以便定制的 <em>ClassLoader</em> 加载。</p><p>至此，我们解决了 SpringBoot 打包，并解压完成压缩包内嵌套资源的加载问题，之后的执行过程将和普通的 Java 应用程序是一样的，大家可以参考另外一篇文章<a href="/2018/12/20/springboot-yuan-ma-jie-du-qi-dong-pian/">SpringBoot源码解读——启动篇</a>来了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;提供了非常多的非常好用的特性，比如内置容器，一键运行，注解驱动，内置监控等等。其中一个非常吸引人也非常便捷的特性就是一键启动：即&lt;strong&gt;将应用打包成一个可执行的JAR，并直接启动运行&lt;/strong&gt;；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多初学者都会比较困惑，SpringBoot是如何做到将应用代码和所有的依赖打包成一个独立的JAR并运行的，因为传统的开发方式如果要将应用打包成独立的JAR并通过&lt;em&gt;java -jar&lt;/em&gt;命令的话，需要通过&lt;em&gt;-classpath&lt;/em&gt;属性来指定依赖。我们今天就来分析讲解一下SpringBoot的打包、启动及运行的原理；&lt;/p&gt;
    
    </summary>
    
      <category term="源码解读" scheme="http://doboot.github.io/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="SpringBoot" scheme="http://doboot.github.io/tags/SpringBoot/"/>
    
      <category term="源码阅读" scheme="http://doboot.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>JavaConfig</title>
    <link href="http://doboot.github.io/2018/06/17/javaconfig-jie-shao/"/>
    <id>http://doboot.github.io/2018/06/17/javaconfig-jie-shao/</id>
    <published>2018-06-17T01:51:34.000Z</published>
    <updated>2020-11-14T06:10:20.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JavaConfig的历史"><a href="#JavaConfig的历史" class="headerlink" title="JavaConfig的历史"></a>JavaConfig的历史</h3><p>　　Spring在最初的时候，一直是采用XML作为容器配置的手段，但随着现代项目的复杂性越来越高，Spring项目大量的烂用XML反而变成一个灾难，遭受了非常严励的一个批评。由于Spring会把几乎所有的业务类都以Bean的形式配置在XML文件中，造成了大量的XML文件。使用XML来配置Bean失去了编译时的类型安全检查。大量的XML配置使得整个项目变得更加复杂。Rod  Johnson也注意到了这个非常严重的问题。当随着JAVA EE  5.0的发布，其中引入了一个非常重要的特性——<strong>Annotations(注解)</strong>。注解是源代码的标签，这些标签可以在源代码层进行处理或通过编译器把它融入到class文件中。在JAVA  EE  5以后的版本中，注解成为了一个主要的配置选项。</p><a id="more"></a><p>　　相对于传统的XML配置方式，<strong>JavaConfig</strong>有如下的优势：</p><ol><li>它是纯Java的配置方式，这意味着你可以利用所有面向对象的优势，重用、继承、多态以及类型检查等。</li><li>拥有对于实例及其依赖更完全的控制权。</li><li>拥有更好的IDE支持。</li><li>配置与业务逻辑是在<strong>一起</strong>的，而不是分散成代码和配置。</li><li>当然，它仍然是和 XML 兼容的，你可以同时在项目中使用 XML 和 <strong>JavaConfig</strong> 进行配置。</li></ol><h3 id="常见的JavaConfig用法"><a href="#常见的JavaConfig用法" class="headerlink" title="常见的JavaConfig用法"></a>常见的JavaConfig用法</h3><p>​    我想大部分同学都已经使用<strong>JavaConfig</strong>来注解我们的SpringBean了，比如我们常用的：</p><table><thead><tr><th>@Component</th><th>通用组件，可以标注在任意的SprinbBean上</th></tr></thead><tbody><tr><td>@Repository</td><td>通常作为存储层的Bean定义，派生自 @Component</td></tr><tr><td>@Service</td><td>通常作为服务层的Bean定义，派生自 @Component</td></tr><tr><td>@Controller</td><td>通常作为控制层的Bean定义，派生自 @Component</td></tr></tbody></table><p>​    当然，以上所有的注解都必须配合<code>ComponentScan</code>才能生效，比如我们会在XML配置中配置如下的节点：<code>&lt;component-scan base-package=&quot;packages.to.scan&quot;</code>或者更加 <strong>JavaConfig</strong> 的做法是通过Java代码来声明，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"packages.to.scan"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Configuration-的用法"><a href="#Configuration-的用法" class="headerlink" title="@Configuration 的用法"></a>@Configuration 的用法</h3><p>​    <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>等这些注解就不讲解了，实在太过于简单和常见，我们主要讲解一下<code>@Configuration</code>的用法，习惯于用XML配置的同学可能对这个注解了解得比较少，也很少会使用。</p><p>​    在上面的代码中我们看到一个注解<code>@Configuration</code>，这个注解是Spring基于<strong>JavaConfig</strong>配置的核心，这个注解的说明如下：</p><blockquote><p>Indicates that a class declares one or more {@link Bean @Bean} methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime</p></blockquote><p>​    Spring会去解析标注这个注解的类，将它作为Spring容器的配置入口，它将会通过一系列的方法定义SpringBean。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExternalObjectA <span class="title">externalObjectA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ExternalObjectA();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExternalObjectB <span class="title">externalObjectB1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ExternalObjectB(externalObjectA());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExternalObjectB <span class="title">externalObjectB2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ExternalObjectB(externalObjectA());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这段代码就是通过<strong>JavaConfig</strong>定义了三个SpringBean，需要注意的是：</p><ol><li><p><code>ExternalObjectB</code>类型的Bean注册了<strong><em>2</em></strong>个，分别来自于<code>externalObjectB1()</code>方法的调用和<code>externalObjectB2()</code>方法的调用，它们的名字分别来自于<code>@Bean</code>对应的方法名。</p></li><li><p><code>ExternalObjectA</code>被<code>externalObjectB1</code>和<code>externalObjectB2</code>以参数的方式依赖。</p></li><li><p>由于<code>ExternalObjectA</code>也被注解为<code>@Bean</code>，同时，默认的SpringBean的<strong>Scope是Singleton</strong>，所以虽然被<strong><em>2</em></strong>个Bean依赖以参数方式调用了<strong><em>2</em></strong>次，但实际上<code>externalObjectA()</code>只会执行一次。</p></li></ol><p>通过以下的代码测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Import的用法"><a href="#Import的用法" class="headerlink" title="@Import的用法"></a>@Import的用法</h3><p>​    在现实的编码过程中，我们通常会将所需要的SpringBean分门别类的在不同的<code>@Configuration</code>类中进行声明配置，而不是写一个超级大的配置类来管理所有的SpringBean，有点类似于我们在XML配置时写好几个文件比如<code>application-context-dao.xml</code>，<code>application-context-service.xml</code>之类的。</p><p>​    在这种情况下，我们就需要在不同的场景组合不同的配置类，这个组合的注解就是<code>@Import</code>，该注解可以将其它的<code>@Configuration</code>导入到当前的配置中。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; SpringConfig1<span class="class">.<span class="keyword">class</span>, <span class="title">SpringConfig2</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JavaConfigImport</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    同时，如果其它的配置是在XML文件中，也可以通过<code>@ImportResource</code>来导入，也是非常方便的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classptah: /application-context-*.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfigImportResource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JavaConfig的历史&quot;&gt;&lt;a href=&quot;#JavaConfig的历史&quot; class=&quot;headerlink&quot; title=&quot;JavaConfig的历史&quot;&gt;&lt;/a&gt;JavaConfig的历史&lt;/h3&gt;&lt;p&gt;　　Spring在最初的时候，一直是采用XML作为容器配置的手段，但随着现代项目的复杂性越来越高，Spring项目大量的烂用XML反而变成一个灾难，遭受了非常严励的一个批评。由于Spring会把几乎所有的业务类都以Bean的形式配置在XML文件中，造成了大量的XML文件。使用XML来配置Bean失去了编译时的类型安全检查。大量的XML配置使得整个项目变得更加复杂。Rod  Johnson也注意到了这个非常严重的问题。当随着JAVA EE  5.0的发布，其中引入了一个非常重要的特性——&lt;strong&gt;Annotations(注解)&lt;/strong&gt;。注解是源代码的标签，这些标签可以在源代码层进行处理或通过编译器把它融入到class文件中。在JAVA  EE  5以后的版本中，注解成为了一个主要的配置选项。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://doboot.github.io/tags/Spring/"/>
    
      <category term="JavaConfig" scheme="http://doboot.github.io/tags/JavaConfig/"/>
    
  </entry>
  
  <entry>
    <title>[转]这两首名诗到底是谁作的？</title>
    <link href="http://doboot.github.io/2018/03/23/zhe-liang-shou-ming-shi-dao-di-shi-shui-zuo-de/"/>
    <id>http://doboot.github.io/2018/03/23/zhe-liang-shou-ming-shi-dao-di-shi-shui-zuo-de/</id>
    <published>2018-03-23T09:42:00.000Z</published>
    <updated>2020-11-14T06:10:20.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-99.png" alt="upload successful"></p><p>翻读唐诗，关注到两宗“悬案”。</p><p>涉及到的两首唐诗都是流传千古的名篇。<br>一首是《登鹳雀楼》：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">白日依山尽，黄河入海流。</span><br><span class="line"></span><br><span class="line">欲穷千里目，更上一层楼。</span><br></pre></td></tr></table></figure></p><p>另一首是《清明》：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">清明时节雨纷纷，路上行人欲断魂。</span><br><span class="line"></span><br><span class="line">借问酒家何处有，牧童遥指杏花村。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>众所周知，《登鹳雀楼》的作者是王之涣，《清明》的作者是杜牧。两位都是唐代极负盛名的诗人。一千多年的吟诵流传，两人的名字早已与两首古诗融为一体了。但是，如果有人告诉你，这两首诗的作者另有其人，你惊不惊讶，诧不诧异？</p><p>先说《清明》。有什么证据证明这诗不是杜牧所写呢？翻阅《全唐诗·杜牧卷》，里面没有这首诗的存在。如此有名的诗却未被收录在名家诗歌存目下，实属蹊跷。杜牧去世后，他的外甥裴延翰又整理编订了《樊川文集》，里面也没有这首诗。后来又有宋人补编《樊川外集》《樊川别集》，里面亦未见《清明》一诗的影子，使得此诗出处更加疑云重重。</p><p>《清明》最早出现在文献中，是在南宋末期。从时间上来说，这已经是杜牧去世三百多年之后的事儿了。</p><p>假若此诗真非杜牧所写，为什么偏偏冠上了他的名字呢？我们都知道，杜牧有“七绝之王”的美誉，曾写出“南朝四百八十寺，多少楼台烟雨中”，“东风不与周郎便，铜雀春深锁二乔”，“一骑红尘妃子笑，无人知是荔枝来”，“停车坐爱枫林晚，霜叶红于二月花”，“春风十里扬州路，卷上珠帘总不如”等等诸多或清新通俗、或意味隽永的诗句，而“清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村”的风格，与他的诗风是十分接近的。</p><p><img src="/images/pasted-100.png" alt="upload successful"></p><p>是不是当时有诗者写出这首诗，但因没有一定知名度，担心作品很难被流传下去，遂干脆就把署名“送”给了大名鼎鼎的杜牧呢？在那个当时代文化文本都很容易散佚或消失的时代，如果不把这首作品安在杜牧头上，写出此诗几年、十几年或者几十年之后，它便失传于凄风冷雨中，也未可知。</p><p>再说《登鹳雀楼》。芮挺章是盛唐时期一位非常有名气的文人，他编选了一本《国秀集》，把唐代的经典诗篇都选进集子里，当然也包括《登鹳雀楼》。然而，此诗署名却是一个叫朱斌的人。《国秀集》里选了王之涣三首诗，但《登鹳雀楼》不在他的名下。芮着手编《国秀集》之时，王之涣刚刚离世，但他的家人及老友王昌龄、高适等都还健在，如果《登鹳雀楼》确是出自王之涣之手，王昌龄与高适怎会视而不见？那还不得在第一时间找到芮挺章，为好友讨个说法？</p><p>清代康熙年间开始纂修《全唐诗》。这部《全唐诗》真的很“全”，共计九百卷，里面收录了当时人们所能看到的所有唐诗，共计四万八千九百余首，其中当然包含《登鹳雀楼》。有意思的是，作者那栏写的是“一作朱斌诗”，又在“一作朱斌诗”下面写了“一作王之涣诗”。估计当时负责编校《全唐诗》的彭定求、沈三曾等十人也非常“头大”，经过各方考证仍未得到确切答案，两难之中，只好采用这种“出选择题”似的署名办法。这一学术问题，几百年后的今天仍在探讨当中，只是亦未取得进展。</p><p><img src="/images/pasted-101.png" alt="upload successful"></p><p>到底谁写的《清明》？《登鹳雀楼》究竟出自王之涣还是朱斌之手？历史的真相迷失在风雨中，答案似乎已经没有那么重要了。五千年文化，三千年诗韵，这都是我们的祖先给后世子孙留下的财富，在中华诗词这条从未断流的大河之中，这些绝句佳篇姓王姓杜还是姓朱，无疑都不影响它们发散出最闪亮的光芒。</p><p>如果从哲学的角度出发，板桥先生的话值得一听。他说：难得糊涂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/pasted-99.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;翻读唐诗，关注到两宗“悬案”。&lt;/p&gt;
&lt;p&gt;涉及到的两首唐诗都是流传千古的名篇。&lt;br&gt;一首是《登鹳雀楼》：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;白日依山尽，黄河入海流。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;欲穷千里目，更上一层楼。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另一首是《清明》：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;清明时节雨纷纷，路上行人欲断魂。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;借问酒家何处有，牧童遥指杏花村。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="诗词鉴赏" scheme="http://doboot.github.io/categories/%E8%AF%97%E8%AF%8D%E9%89%B4%E8%B5%8F/"/>
    
    
      <category term="诗词鉴赏" scheme="http://doboot.github.io/tags/%E8%AF%97%E8%AF%8D%E9%89%B4%E8%B5%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot/Cloud 的背后</title>
    <link href="http://doboot.github.io/2018/03/23/spring-boot-cloud-de-bei-hou/"/>
    <id>http://doboot.github.io/2018/03/23/spring-boot-cloud-de-bei-hou/</id>
    <published>2018-03-23T07:48:00.000Z</published>
    <updated>2020-11-14T06:10:20.932Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-45.png" alt="upload successful"></p><p>我们刚开始学习 Spring Boot 的时候肯定都会看到这么一句话：</p><blockquote><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。</p></blockquote><p>这里的 Pivotal 团队肯定就是 Spring Boot 的研发团队了，那么这个 Pivotal 团队到底是个什么来头呢？和 Spring 又有那些关系？不着急且听我慢慢道来。</p><p>要说起这个 Pivotal 公司的由来，我得先从 Spring 企业的这条线来说起。<br><a id="more"></a></p><h3 id="Spring-的发展"><a href="#Spring-的发展" class="headerlink" title="Spring 的发展"></a>Spring 的发展</h3><p>时间回到 2002 年，当时正是 Java EE 和 EJB 大行其道的时候，很多知名公司都是采用此技术方案进行项目开发。这时候有一个美国的小伙子认为 EJB 太过臃肿，并不是所有的项目都需要使用 EJB 这种大型框架，应该会有一种更好的方案来解决这个问题。</p><p>他为了证明自己的想法是正确的，在 2002 年 10 月写了一本书《Expert One-on-One J2EE》，介绍了当时 Java 企业应用程序开发的情况，并指出了 Java EE 和 EJB 组件框架中存在的一些主要缺陷。在这本书中，他提出了一个基于普通 Java 类和依赖注入的更简单的解决方案。</p><p>在书中，他展示了如何在不使用 EJB 的情况下构建高质量、可扩展的在线座位预留系统。为了构建应用程序，他编写了超过 30,000 行的基础结构代码，项目中的根包命名为 com.interface21，所以人们最初称这套开源框架为 interface21，这就是 Spring 的前身。</p><p>这个小伙子是谁呢？他就是大名鼎鼎的 Rod Johnson（下图），Rod Johnson 在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位，更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。现在 Rod Johnson 已经离开了 Spring，成为了一个天使投资人，同时也是多个公司的董事，早已走上人生巅峰。</p><p><img src="/images/pasted-46.png" alt="upload successful"></p><p>在这本书发布后，一对一的 J2EE 设计和开发一炮而红。这本书免费提供的大部分基础架构代码都是高度可重用的。2003 年 Rod Johnson 和同伴在此框架的基础上开发了一个全新的框架命名为 Spring，据 Rod Johnson 介绍 Spring 是传统 J2EE 新的开始，随后 Spring 发展进入快车道。</p><ul><li>2004 年 03 月，1.0 版发布。</li><li>2006 年 10 月，2.0 版发布。</li><li>2007 年 11 月，更名为 SpringSource，同时发布了 Spring 2.5。</li><li>2009 年 12 月，Spring 3.0 发布。</li><li>2013 年 12 月，Pivotal 宣布发布 Spring 框架 4.0。</li><li>2017 年 09 月，Spring 5.0 发布。</li></ul><p>网上有一张图，清晰的展示了 Spring 发展：</p><p><img src="/images/pasted-47.png" alt="upload successful"></p><p>从上面这个时间线我们可以看出 Pivotal 团队和 Spring 在 2013 年交上了线，这是为什么呢？</p><blockquote><p>友情提示，接下来科技行业的一系列商业并购大片即将开启。</p></blockquote><h3 id="Pivotal-公司"><a href="#Pivotal-公司" class="headerlink" title="Pivotal 公司"></a>Pivotal 公司</h3><p>上面说的 Pivotal 团队是指 Pivotal 公司，先给大家来一段 Pivotal 公司的简介：</p><blockquote><p>Pivotal 成立于2013年4月，致力于“改变世界构造软件的方式（We are transforming how the world builds software）”，提供云原生应用开发 PaaS 平台及服务，帮助企业客户采用敏捷软件开发方法论，从而提高软件开发人员工作效率、减少运维成本，实现数字化转型、IT 创新，并最终实现业务创新。</p><p>截至目前，财富 100 强中超过三分之一的企业使用 Pivotal 云原生平台。Pivotal 部分大型客户在采用 Pivotal 产品后，开发人员与运营人员比例可提高到 200:1，开发人员专注于编写软件代码时间增长了 50%。</p></blockquote><p>看了简介大家可能会有点犯迷糊，这不是一个 2013 年成立的 IT 服务公司吗，和 2002 年发展起来的 Spring 又是怎么扯上关系的呢？其实呀，要说起 Pivotal 公司的起源要追溯到 1989 年的 Pivotal Labs 实验室。</p><p><img src="/images/pasted-49.png" alt="upload successful"></p><p>Pivotal Labs 公司</p><p>1989 年，Rob Mee 创立的咨询公司 Pivotal Labs，专注于快速的互联网式软件开发，即敏捷编程。创立 Pivotal Labs 的时候，它还是一家非常小的软件顾问公司，它的主营业务就是与客户合作，帮助客户开发软件。</p><p>Pivotal Labs 一直是敏捷开发领域的领导者，为部分硅谷最有影响力的公司塑造了软件开发文化，并树立了良好口碑，其中 Google、Twitter 都曾是 Pivotal Labs 客户。</p><p>时间很快到了 2012 年，深受客户喜爱的 Pivotal 终于引起了商用软件巨头 EMC 的关注，EMC 在 2012 年以现金方式收购了 Pivotal 并照单全收了它的 200 名员工。</p><p>刚开始的时候，公司并没有发生太大的变化，只是作为新部门成为了 EMC 的一部分，Pivotal Labs 仍然继续像以前样与客户合作。</p><p>但是到 2013 年的时候，EMC 突然扔下了一颗重磅炸弹。它将 Pivotal Labs 的核心业务分拆出去，成立了一家名为 Pivotal Software 的新公司。这家新公司的股东是 EMC 、 VMware 和通用电气，之前在 EMC 子公司 VMware 担任首席执行官的马瑞兹出任公司的首席执行官。</p><p>EMC 和 VMware 分拆出其 Cloud Foundry、Pivotal Labs、Greenplum 等云计算、大数据资源，GE 投资 1.05 亿美元，成立新公司 Pivotal。新生的 Pivotal 是名副其实的“富二代”，这轮估值高达 10.5 亿美元。</p><p>那么 EMC 和 VMware 又有什么关联呢？</p><p>2003 年 12 月， EMC 公司宣布以 6.35 亿美元收购了 VMware 公司。</p><p>EMC 于 1979 年成立于美国麻州 Hopkinton 市，1989 年开始进入企业数据储存市场。二十多年来，EMC 全心投注在各项新的储存技术，已获得了 1,300 个已通过或审核中的储存技术专利。无论是全球外接 RAID 储存系统、网络储存亦或是储存管理软件等储存专业领域，EMC 均是业界公认的领导厂商。</p><p>EMC 是全球第六大企业软件公司，全球信息基础架构技术与解决方案的领先开发商与提供商。同时也是美国财富五百强之一，在全世界拥有超过四万二千名员工，在全球 60 个国家或地区拥有分支机构。我们接触比较多就是 EMC 的各种存储产品。</p><p>EMC 公司做大 EMC 的秘诀，就是研发与并购双轮驱动，研发与并购的投入占当年营业收入的 22% 左右，并购投入略高于研发。从 2003 年到2 015 年的 12 年间，EMC 总共投入超过 420 亿美元用于研发和收购。其中，206 亿美元用于研发，213 亿美元用于并购，总共并购了 100 多家公司。</p><p>VMware 收购 Spring</p><p>2009 年是 Spring 企业的一个转折点，VMware 以 4.2 亿美元收购 Spring Source (3.6亿现金外加5800万股份） 。</p><p><strong>可以说虚拟化就是 VMware 发明的</strong></p><p>VMware 于 1998 年成立，公司总部位于美国加州帕洛阿尔托，是全球云基础架构和移动商务解决方案厂商，提供基于VMware的解决方案，企业通过数据中心改造和公有云整合业务，借助企业安全转型维系客户信任，实现任意云端和设备上运行、管理、连接及保护任意应用。2018 财年全年收入 79.2 亿美元。</p><p>相信作为研发人员肯定都使用过 VMware 公司的产品，最常用的是 VMware 的虚拟机产品，但其实 VMware 公司的产品线非常多。</p><p>从发展路线来看，VMware 具备三大特点：</p><ul><li>第一，是技术具备领先性，虚拟化技术在70年代就已出现，但VMware是第一个将这项技术应用到X86服务器上，并在这个基础上不断完善，使其能够满足企业级客户需求；</li><li>第二，是瞄准大型企业客户。VMware 刚刚上市时，年营收不到4亿美金，但已经覆盖80%的财富1000强客户；</li><li>第三，是高度产品化。VMware 的毛利率长期保持在 85% 左右，咨询业务占比非常少，几乎将所有部署工作都交给合作伙伴。</li></ul><p>VMware 也是一个并购大户，通过投资和收购补全业务线，客户资源是一大优势。</p><p><img src="/images/pasted-50.png" alt="upload successful"></p><blockquote><p>2012 年 Rod Johnson 宣布他将要离开 Spring Source 。</p></blockquote><h3 id="EMC-又被收购"><a href="#EMC-又被收购" class="headerlink" title="EMC 又被收购"></a>EMC 又被收购</h3><p>2015 年的时候，曾经被大量报道 EMC 考虑被子公司 VMware 收购，让人大跌眼镜，竟然可以有这样的骚动作，这是为什么呢？</p><p>EMC 在 2003 年斥资 6.25 亿美元收购了 VMware，四年之后，EMC 选择让 VMware 分拆上市，结果独立上市的 VMware 发展越来越好，反观 EMC 的各项业务持续陷入低潮。到 2015 年的时候，VMware 的市值已达到约 370 亿美元，占据了 EMC 总市值的近 75%。</p><p>可能各方利益不能达成一致，最终 EMC 却被戴尔（dell）收购。</p><p>2015 年 10 月 12 日，戴尔（Dell）和EMC（易安信）公司宣布签署最终协议，戴尔公司与其创始人、主席和首席执行官麦克尔•戴尔，与 MSD Partner 以及银湖资本一起，收购 EMC 公司，交易总额达 670亿 美元，成为科技史上最大并购。</p><p>当时业界最关心的云计算软件商 VMware 仍然保持独立上市公司的身份。据悉，EMC 当前持有 VMware 大约 80% 的股权，市值约为 320 亿美元。而戴尔收购 EMC 实际上是项庄舞剑，VMware 才是戴尔收购 EMC 的关键。</p><p>戴尔的故事</p><p>1984 年，创办人迈克尔·戴尔在德州大学奥斯汀分校就学时创立了 PCs Limited 这家计算机公司。在 1985 年，公司生产了第一部拥有自己独特设计的计算机“Turbo PC”，售价为 795 美元。从此开启了戴尔公司的发展史，下面为戴尔公司的里程碑</p><ul><li>1984年 - 年仅19岁的Michael Dell凭借1,000美元的资金建立了PC’s Limited，并且树立了颠覆技术行业的愿景。</li><li>1988年 - 我们完成了首次公开募股，募集了3,000万美元资金，公司市值从1,000美元增长到8500万美元。</li><li>1992年 - 戴尔跻身财富500强公司行列，Michael Dell也成为榜单上最年轻的CEO。</li><li>1996年 - Dell.com上线，该站点上线仅六个月之后，每天销售额即达100万美元。</li><li>2001年 - 戴尔成为 全球第一大计算机系统提供商。</li><li>2005年 - 在《财富》杂志的“美国最受赞赏公司”排名中，戴尔位列第一。</li><li>2010年 - 戴尔被 Gartner, Inc.评为世界第一大医疗保健信息技术服务提供商。</li><li>2013年 - Michael Dell携手私人股本公司Silver Lake Partners，从公众股东手里买回了戴尔股份，旨在加快解决方案战略的实施并专注于大多数客户重视的创新和长期投资。</li><li>2016年 - 戴尔与EMC合并为Dell Technologies，这是业内最大的技术集成事件。</li><li>戴尔提供的工作</li></ul><p>2018年的时候又传出，VMware 反收购戴尔？写到这里的时候我都感觉有点乱了？戴尔收购了 EMC， ECM 收购了 VMware ，那么 VMware 就差不多算戴尔的重孙子，那么怎么又来 VMware 反收购戴尔？</p><p>原来是这样，在 2015 年 10 月 12 日业界正式爆料戴尔收购 EMC（包括 VMware），当时的 VMware 股价在 60－70 美元左右。到了 2016 年 9 月戴尔宣布正式并购 EMC 包括 VMware，只是让 VMware 独立运营，VMware 当时股价也还是在 70 美元左右。</p><p>可是到了 2018 年初一看，VMware 股价已经到达了 130 多美元，在 2018 年的最高点，股价甚至达到了 160 多美元，股价又 TM 涨了一倍多，VMware 公司简直发展太好了。VMware 最新的市值快到了 600 亿美金，当初收购时 VMware 市值也就 200 多亿美金，简直赚翻了呀！</p><p>传言只是传言，最终 2018 年 7 月，戴尔还是选择了独立上市，拥有 VMware 80% 的股份。</p><p>并购时间表</p><p>上面写的有点乱，大家看完之后也许有点迷糊，在这里重新整理一下这里面几个关键公司的收购时间点：</p><ul><li>1989 年，Rob Mee 创立的咨询公司 Pivotal Labs;</li><li>2003 年，Rod Johnson 和同伴创建了 Spring；</li><li>2003 年，EMC 收购了 VMware 公司；</li><li>2009 年，VMware 收购了 Spring ;</li><li>2012 年，EMC 又收购了 Pivotal Labs 公司；</li><li>2013 年，EMC 、 VMware 和收购来的 Pivotal Labs 公司重新组建了新的公司 Pivotal;</li><li>2015 年，戴尔又并购了 EMC;</li><li>2018 年，戴尔独立上市。</li></ul><p>接着说 Pivotal 公司</p><p>上面一系列的商业并购搞的眼花缭乱的，但是大家只要知道 Pivotal 公司出身高贵，来自几个都不太差钱的世界 500 强公司联合组建而成，Pivotal 公司的产品非常的高大上，就连我们平时使用的 12306 都使用了他们公司的产品。</p><p>Pivotal 公司可谓是大牛云集，公司的开源产品有：Spring 以及 Spring 衍生产品、Web 服务器 Tomcat、缓存中间件 Redis、消息中间件 RabbitMQ、平台即服务的 Cloud Foundry、Greenplum 数据引擎、还有大名鼎鼎的 GemFire（12306 系统解决方案组件之一）。</p><p>这些著名开源产品背后的开发者都在 Pivotal 公司，其研发团队汇集了全球的一流开发者，Spring Boot 为什么如此优秀，或许在这里可以找到一些答案。</p><p>Pivotal 中国研发中心在中国创建于 2010 年，它的前身是 EMC Greenplum 部门，其团队成员分布在北京和上海两地，目前正致力于以下产品的研发和服务的提供：Pivotal Web Service (PWS), Pivotal Hadoop (PHD), Hawq 和 Greenplum Database (GPDB)。</p><p>毕威拓科技（北京）有限公司（Pivotal中国公司）2015年3月1日正式成立并单独运营。</p><p>Pivotal 公司成立之后，于 2014 年发布了 Spring Boot，2015 年发布了 Spring Cloud，2018 年 Pivotal 公司在纽约上市。我们可以通过一张图来了解 Pivotal 公司的发展史。</p><p><img src="/images/pasted-51.png" alt="upload successful"></p><p>Pivotal 的定位是一家下一代云计算和大数据应用相结合的公司，而 VMWare 和原 EMC 的业务方向则依然是软件定义数据中心和信息基础架构。</p><p>官网这样介绍他们的产品：Pivotal 提供的工具能够帮助开发人员构建更出色软件，可让您在任意云环境中运行应用的平台，帮助您打造未来。</p><p>公司的产品主要分为三大类：部署和运行软件，规划、构建和集成软件，分析和决策</p><h3 id="部署和运行软件"><a href="#部署和运行软件" class="headerlink" title="部署和运行软件"></a>部署和运行软件</h3><ul><li>Pivotal Cloud Foundry (PCF)，用于快速交付应用、容器和函数的多云平台。</li><li>PCF: Pivotal Application Service，</li><li>在具有内置日志记录、监控和自动扩展功能且高度可用的自助服务平台上，运行使用任意语言构建的应用。</li><li>PCF: Pivotal Container Service，基于企业级Kubernetes环境构建应用，该环境采用按需群集、滚动升级和VMware NSX提供的软件定义的网络。</li><li>Pivotal Services Marketplace，</li><li>将您的应用与托管、代理或按需服务相结合。产品涵盖数据管理、API管理、消息传递、日志记录等。</li></ul><h3 id="规划、构建和集成软件"><a href="#规划、构建和集成软件" class="headerlink" title="规划、构建和集成软件"></a>规划、构建和集成软件</h3><ul><li>Spirng Boot，借助领先的Java框架快速构建功能强大的应用和服务。</li><li>Spirng Cloud，</li><li>将经过验证的微服务模式融入您的软件。提供配置存储、服务发现、消息传递等功能。</li><li>Steeltoe，受 Spring Cloud 启发，用该框架构建恢复力强、可扩展的.NET应用。</li><li>Pivotal Cloud Cache，采用基于 Pivotal GemFire 的快速且高度可用的缓存，可提供地理复制和后台写入功能。</li><li>Pivotal GemFire，利用可扩展、事件驱动的分布式数据网格执行内存中计算。12306采用的商业方案。</li><li>RabbitMQ，借助这款广受欢迎的消息传递代理，分离服务并扩展处理进程。</li><li>Pivotal Tracker，经过验证的项目管理工具，帮您打造成功的敏捷团队。</li><li>Concourse，利用自动化管道实现 PCF 的持续升级。</li></ul><h3 id="分析和决策"><a href="#分析和决策" class="headerlink" title="分析和决策"></a>分析和决策</h3><ul><li>Pivotal Greenplum，使用这个功能齐全的多云大规模并行处理(MPP)数据平台，可以对大型数据集进行高级分析。。</li><li>Apache MADlib，通过采用数据并行方式实施多结构数据的数学、统计和机器学习方法来执行数据库内分析。</li></ul><p>Pivotal 公司的产品有 Spring Boot 、Spring Cloud 、RabbitMQ 等非常著名的开源软件，也有很多类似 GemFire 等商业解决方案，通过他们公司的产品即可发现，一边通过开源软件打造生态，一方面通过商业解决方案来挣钱。</p><p>曾经有一段时间，有人就问我一个问题，说开源的是不是就意味着是免费的，不免费的服务，是不是就意味着不是开源的软件？这种商业模式其实就是对这种观点的一种反驳，开源不等于免费，开源是一种开放分享的精神，不要什么东西来到国内都变味了。</p><p>Pivotal 掌握很多最新前沿的开源技术，公司提供的从云端部署到一整套的大数据解决方案，从开发到平台到提供解决方案到提供咨询，可以说真正依赖技术挣钱的典范，我辈之楷模！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/pasted-45.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们刚开始学习 Spring Boot 的时候肯定都会看到这么一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的 Pivotal 团队肯定就是 Spring Boot 的研发团队了，那么这个 Pivotal 团队到底是个什么来头呢？和 Spring 又有那些关系？不着急且听我慢慢道来。&lt;/p&gt;
&lt;p&gt;要说起这个 Pivotal 公司的由来，我得先从 Spring 企业的这条线来说起。&lt;br&gt;
    
    </summary>
    
    
      <category term="业界传奇" scheme="http://doboot.github.io/tags/%E4%B8%9A%E7%95%8C%E4%BC%A0%E5%A5%87/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤（Bloom Filter）</title>
    <link href="http://doboot.github.io/2018/03/21/bu-long-guo-lu/"/>
    <id>http://doboot.github.io/2018/03/21/bu-long-guo-lu/</id>
    <published>2018-03-21T00:18:23.000Z</published>
    <updated>2020-11-14T06:10:20.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either “possibly in set” or “definitely not in set”. —— From wikipedia.</p></blockquote><a id="more"></a><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>数据字典</li><li>进行数据的判重</li><li>黑名单</li><li>CDN（squid）代理缓存技术</li></ol><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Bloom Filter是一种空间效率极高的随机数据结构，它的原理是：当一个元素被加入集合时，通过 K 个Hash函数将这个元素映射成一个位阵列（Bit array）中的 K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检索元素一定不在；如果都是1，则被检索元素很可能在。</p><p><strong>重点：牺牲一定的准确率换取非常高的空间利用率</strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（O(k)）。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><p>在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p><h3 id="Java-实现（Guava）"><a href="#Java-实现（Guava）" class="headerlink" title="Java 实现（Guava）"></a>Java 实现（Guava）</h3><p>Google Guava 库在第 <strong>v11.0</strong> 版本加入了 <strong>Bloom Filter</strong> 的实现，常用 API 介绍如下：</p><ol><li>Bloom Filter 构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> funnel 漏斗模型，用于添加要检测的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedInsertions   预期要检测的数据总量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fpp                  误报率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>                     Bloom Filter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这是全参数的构造器，还有几个重载的构造函数（可以不指定误报率，默认为 3%）</p><blockquote><p><strong>注意事项</strong>  ：正确估计预期插入数量是很关键的一个参数，当插入的数量接近或高于预期值的时候，布隆过滤器将会填满，这样的话，它会产生很多无用的误报点。</p></blockquote><ol start="2"><li>检测内容是否存在</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测数据是否存在</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object  要检测的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>        是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong> ：当返回不存在时，一定不存在，但返回存在时，则有可能存在，误报率在构造器中已经说明</p></blockquote><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><blockquote><p><strong>需求</strong> ：给10亿用户每人发送一条消息</p></blockquote><h4 id="方案一：在内存中记录用户消息发送的状态"><a href="#方案一：在内存中记录用户消息发送的状态" class="headerlink" title="方案一：在内存中记录用户消息发送的状态"></a>方案一：在内存中记录用户消息发送的状态</h4><ul><li>详细描述：在内存设计一个缓存，地将所有的用户 <strong>已</strong> 发送状态放入缓存中，当下一个用户过来时，校验缓存中是否已经存在。</li><li>优点：实现方式逻辑简单；</li><li>缺点：按 UTF-8 编码，用户标识符 10 个字符（10个字节） <em> 10亿 = 10 </em> 10^9 ~= 10 G，基本超出常用的 JVM 内存；</li></ul><h4 id="方案二：将10亿用户号码存到数据库中，并标记发送状态"><a href="#方案二：将10亿用户号码存到数据库中，并标记发送状态" class="headerlink" title="方案二：将10亿用户号码存到数据库中，并标记发送状态"></a>方案二：将10亿用户号码存到数据库中，并标记发送状态</h4><ul><li>详细描述：设计数据库表记录各个用户的发送状态；</li><li>优点：无内存问题，逻辑简单；</li><li>缺点：10 亿级的数据记录存储本身的架构设计、高性能查询就是一个需要解决的很复杂的难题。</li></ul><h4 id="方案三：利用分布式缓存存储用户消息发送状态"><a href="#方案三：利用分布式缓存存储用户消息发送状态" class="headerlink" title="方案三：利用分布式缓存存储用户消息发送状态"></a>方案三：利用分布式缓存存储用户消息发送状态</h4><ul><li><p>详细描述：通过分布式 K-V 数据库（Redis）记录用户的发送状态；</p></li><li><p>优点：无内存问题，逻辑相对简单；</p></li><li>缺点：每条记录都需要跟缓存服务交互 2 次，存在分布式网络延迟；</li></ul><h4 id="方案四：Bloom-Filter-分布式缓存"><a href="#方案四：Bloom-Filter-分布式缓存" class="headerlink" title="方案四：Bloom Filter + 分布式缓存"></a>方案四：Bloom Filter + 分布式缓存</h4><ul><li>详细描述：本地将所有的用户 <strong>已</strong> 发送状态放入 Bloom Filter 中（<strong>以及分布式缓存中</strong>），当下一个用户过来时，先在 Bloom Filter 中查询状态。如果不存在，则 <strong>一定</strong> 未发送，执行发送逻辑；如果存在，则 <strong>不一定</strong> 发送过，则去分布式缓存中进行二次确认，确认之前的 <strong>不一定</strong> 状态；</li><li>优点：无内存问题，绝大部分校验过程在本地完成，只有极少部分（<strong>来源于之前介绍的 Bloom Filter 的误差</strong>）会去分布式缓存进行二次校验，无网络延迟问题；</li><li>缺点：逻辑上会相对复杂一些；</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bloom_filter</a></li><li><a href="https://blog.csdn.net/v_JULY_v/article/details/6685894" target="_blank" rel="noopener">海量数据处理之Bloom Filter详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either “possibly in set” or “definitely not in set”. —— From wikipedia.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="大数据分析" scheme="http://doboot.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Controller 层的职责</title>
    <link href="http://doboot.github.io/2017/11/07/controller-ceng-de-zhi-ze/"/>
    <id>http://doboot.github.io/2017/11/07/controller-ceng-de-zhi-ze/</id>
    <published>2017-11-07T10:33:08.000Z</published>
    <updated>2020-11-14T06:10:20.917Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>controller 层的主要职责：<strong>是对用户的输入进行校验、组织、重组、转换等，之后调用 service 层或者 repository 层对业务数据进行处理，同时对 service/repository 层的输出进行包装，不应该逾越其职责范围进行业务的处理或者数据层的读写</strong></p><a id="more"></a><p>典型的 controller 代码结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"获取首页数据"</span>, notes = <span class="string">"获取首页数据"</span>)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.OK)</span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseData <span class="title">index</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    validParams(request);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包装并转换参数</span></span><br><span class="line">    BizData data = extractParam(request);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用服务 A</span></span><br><span class="line">    Data data1 = serviceA.call(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用服务 B</span></span><br><span class="line">    Data data2 = serviceB.call(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包装返回结果</span></span><br><span class="line">    Data result = wrap(data1, data2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"创建Banner数据"</span>, notes = <span class="string">"创建Banner数据"</span>)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Banner <span class="title">create</span><span class="params">(@ApiParam(value = <span class="string">"Banner信息"</span>)</span> @RequestBody Banner banner) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    validBanner(banner);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用服务，并（包装）返回结果</span></span><br><span class="line">    <span class="keyword">return</span> bannerRepository.save(banner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;controller 层的主要职责：&lt;strong&gt;是对用户的输入进行校验、组织、重组、转换等，之后调用 service 层或者 repository 层对业务数据进行处理，同时对 service/repository 层的输出进行包装，不应该逾越其职责范围进行业务的处理或者数据层的读写&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://doboot.github.io/tags/SpringMVC/"/>
    
      <category term="规范与最佳实践" scheme="http://doboot.github.io/tags/%E8%A7%84%E8%8C%83%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>URL 规范</title>
    <link href="http://doboot.github.io/2017/11/06/url-gui-fan/"/>
    <id>http://doboot.github.io/2017/11/06/url-gui-fan/</id>
    <published>2017-11-06T02:28:18.000Z</published>
    <updated>2020-11-14T06:10:20.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="模式规范"><a href="#模式规范" class="headerlink" title="模式规范"></a>模式规范</h4><blockquote><p><strong>强制</strong>：统一采用小写，并以中划线（-）作为分隔符，<strong>不得</strong> 进行驼峰式的大小写混合，<strong>不得</strong> 采用其它分割符。</p><p>比如：<a href="http://www.example.com/green-dress.html" target="_blank" rel="noopener">http://www.example.com/green-dress.html</a></p></blockquote><p><strong>参考文献</strong>：</p><ol><li>IETF 草案：<a href="https://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc1738.txt</a></li><li>来自Google的建议：<a href="https://support.google.com/webmasters/answer/76329" target="_blank" rel="noopener"><strong>“we recommend that you use hyphens (-) instead of underscores (_) in your URLs”</strong></a></li><li>参考文档：<a href="https://www.webfirm.com/blog/dash-or-underscore-in-url/" target="_blank" rel="noopener">Dash- or underscore_ in URL Web address?</a></li></ol><h4 id="URL-的生成与拼接"><a href="#URL-的生成与拼接" class="headerlink" title="URL 的生成与拼接"></a>URL 的生成与拼接</h4><blockquote><p><strong>建议：</strong> 采用 <code>UriComponent</code> 相关的组件，而非字符串拼接，可以避免较多的不规范及编码问题，如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(<span class="string">"http://www.example.com/query"</span>)</span><br><span class="line">                    .queryParam(<span class="string">"fromUserCode"</span>, config.getVmsFromUserCode())</span><br><span class="line">                    .queryParam(<span class="string">"toUserCode"</span>, account)</span><br><span class="line">                    .queryParam(<span class="string">"msgText"</span>, content);</span><br><span class="line"> log.info(<span class="string">"URL:&#123;&#125;"</span>, uriComponents.toUriString());</span><br></pre></td></tr></table></figure><p>​    更多的实用方法请自行查阅API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="规范与最佳实践" scheme="http://doboot.github.io/tags/%E8%A7%84%E8%8C%83%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>重试机制（RetryTemplate）</title>
    <link href="http://doboot.github.io/2017/04/23/chong-shi-ji-zhi-retrytemplate/"/>
    <id>http://doboot.github.io/2017/04/23/chong-shi-ji-zhi-retrytemplate/</id>
    <published>2017-04-23T06:34:36.000Z</published>
    <updated>2020-11-14T06:10:20.971Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>强制：</strong> 统一采用<code>Spring-Retry</code>库来完成重试操作，<strong>不得</strong> 通过循环等方式来自实现</p></blockquote><p>方案有如下两种（推荐采用注解方式，特殊场景可以通过 <code>RetryTemplate</code> 自行定制）：</p><ol><li><p>注解式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryCallService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ATTEMPTS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY = <span class="number">1000</span> * <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_DELAY = DELAY * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retryable</span>(value = &#123;BizException<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">            <span class="title">maxAttempts</span> </span>= MAX_ATTEMPTS,</span><br><span class="line">            backoff = <span class="meta">@Backoff</span>(delay = DELAY, maxDelay = MAX_DELAY, multiplier = <span class="number">2</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">retry</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 达到最大重试次数后的补偿方案</span></span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">recover</span><span class="params">(BizException e)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"达到最大尝试次数，执行最后的补偿操作，异常信息为：&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        log.info(<span class="string">"进行第 &#123;&#125; 次尝试，当前时间过去了：&#123;&#125; 秒"</span>, count, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(<span class="string">"模拟业务异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>模板模式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryCallServiceTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ATTEMPTS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INITIAL_INTERVAL = TimeUnit.SECONDS.toMillis(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_INTERVAL = TimeUnit.MINUTES.toMillis(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RetryTemplate retryTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化重试模板</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRetryTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        ExponentialBackOffPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackOffPolicy();</span><br><span class="line">        retryPolicy.setInitialInterval(INITIAL_INTERVAL);</span><br><span class="line">        retryPolicy.setMaxInterval(MAX_INTERVAL);</span><br><span class="line">        retryPolicy.setMultiplier(<span class="number">2</span>);</span><br><span class="line">        retryTemplate.setRetryPolicy(<span class="keyword">new</span> SimpleRetryPolicy(MAX_ATTEMPTS));</span><br><span class="line">        retryTemplate.setBackOffPolicy(retryPolicy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">retry</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 典型的 Spring Template 用法</span></span><br><span class="line">        retryTemplate.execute(<span class="keyword">new</span> RetryCallback&lt;Boolean, Exception&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                doSomething();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> RecoveryCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">recover</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RetryCallServiceTwo.<span class="keyword">this</span>.recover(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 达到最大重试次数后的补偿方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">recover</span><span class="params">(RetryContext retryContext)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"达到最大尝试次数，执行最后的补偿操作，异常信息为：&#123;&#125;"</span>, retryContext.getLastThrowable().getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">0</span>) &#123;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        log.info(<span class="string">"进行第 &#123;&#125; 次尝试，当前时间过去了：&#123;&#125; 秒"</span>, count, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(<span class="string">"模拟业务异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;强制：&lt;/strong&gt; 统一采用&lt;code&gt;Spring-Retry&lt;/code&gt;库来完成重试操作，&lt;strong&gt;不得&lt;/strong&gt; 通过循环等方式来自实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方案有如下两种（推荐采用注解方式，特殊场景可以通过 &lt;code&gt;RetryTemplate&lt;/code&gt; 自行定制）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注解式&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Slf&lt;/span&gt;4j&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@EnableRetry&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RetryCallService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 最大重试次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; MAX_ATTEMPTS = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 延迟策略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; DELAY = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;2L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; MAX_DELAY = DELAY * &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Retryable&lt;/span&gt;(value = &amp;#123;BizException&lt;span class=&quot;class&quot;&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;            &lt;span class=&quot;title&quot;&gt;maxAttempts&lt;/span&gt; &lt;/span&gt;= MAX_ATTEMPTS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            backoff = &lt;span class=&quot;meta&quot;&gt;@Backoff&lt;/span&gt;(delay = DELAY, maxDelay = MAX_DELAY, multiplier = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Boolean &lt;span class=&quot;title&quot;&gt;retry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (start == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            start = System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 达到最大重试次数后的补偿方案&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Recover&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Boolean &lt;span class=&quot;title&quot;&gt;recover&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(BizException e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        log.info(&lt;span class=&quot;string&quot;&gt;&quot;达到最大尝试次数，执行最后的补偿操作，异常信息为：&amp;#123;&amp;#125;&quot;&lt;/span&gt;, e.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 具体的业务逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        log.info(&lt;span class=&quot;string&quot;&gt;&quot;进行第 &amp;#123;&amp;#125; 次尝试，当前时间过去了：&amp;#123;&amp;#125; 秒&quot;&lt;/span&gt;, count, (System.currentTimeMillis() - start) / &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BizException(&lt;span class=&quot;string&quot;&gt;&quot;模拟业务异常&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="最佳实践" scheme="http://doboot.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>JDK/bin下工具列表说明</title>
    <link href="http://doboot.github.io/2017/04/17/jdk-gong-ju-shuo-ming/"/>
    <id>http://doboot.github.io/2017/04/17/jdk-gong-ju-shuo-ming/</id>
    <published>2017-04-17T11:43:08.000Z</published>
    <updated>2020-11-14T06:10:20.920Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>appletviewer.exe</strong></p><blockquote><p>一种执行HTML文件上的Java小程序类的Java浏览器</p></blockquote><p><strong>apt.exe</strong></p><blockquote><p>注解处理工具(Annotation Processing Tool), SolarisTM 操作系统和 Linux上用于处理注释的工具</p></blockquote><p><strong>extcheck.exe</strong></p><blockquote><p>扩展检测工具，检测目标 jar 文件与当前安装方式扩展jar 文件间的版本冲突</p></blockquote><a id="more"></a><p><strong>HtmlConverter.exe</strong></p><blockquote><p>Java(TM) 插件 HTML 转换器是一种实用程序，可用于将任一包含小程序的 HTML 页面,转换为使用 Java(TM)插件的格式</p></blockquote><p><strong>idlj.exe</strong></p><blockquote><p>IDL转Java编译器(IDL-to-Java Compiler)，用于为指定的IDL文件生成Java绑定，IDL意即接口定义语言(Interface Definition Language)</p></blockquote><p><strong>jabswitch.exe</strong></p><blockquote><p>Java访问桥开关(JavaAccess Bridge switch)，用于启用/禁用Java访问桥。Java访问桥内置于Java 7 Update 6及以上版本，主要为Windows系统平台提供一套访问Java应用的API</p></blockquote><p><strong>jar.exe</strong></p><blockquote><p>文件管理工具，是个java应用程序，可将多个文件合并为单个JAR归档文件</p></blockquote><p><strong>jarsigner.exe</strong></p><blockquote><p>密钥签名工具，为 Java 归档 (JAR) 文件产生签名，并校验已签名的 JAR文件的签名</p></blockquote><p><strong>java.exe</strong></p><blockquote><p>运行工具，Java解释器，直接从类文件执行Java应用程序代码</p></blockquote><p><strong>javac.exe</strong></p><blockquote><p>编译工具，Java编译器，将Java源代码换成字节代</p></blockquote><p><strong>javadoc.exe</strong></p><blockquote><p>文档工具，根据Java源代码及其说明语句生成的HTML文档</p></blockquote><p><strong>javafxpackager.exe</strong></p><blockquote><p>JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务</p></blockquote><p><strong>javah.exe</strong></p><blockquote><p>头文件工具，用于根据Java类生成C/C++头文件和源文件(主要用于JNI开发领域)</p></blockquote><p><strong>javap.exe</strong></p><blockquote><p>Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件</p></blockquote><p><strong>javapackager.exe</strong></p><blockquote><p>Java包装器，执行与包装并签署Java和JavaFX应用程序的任务</p></blockquote><p><strong>java-rmi.exe</strong></p><blockquote><p>Java远程方法调用(JavaRemote Method Invocation)工具，主要用于在客户机上调用远程服务器上的对象</p></blockquote><p><strong>javaw.exe</strong></p><blockquote><p>Java运行工具，用于运行.class字节码文件或.jar文件，但不会显示控制台输出信息，适用于运行图形化程序</p></blockquote><p><strong>Javaws.exe</strong></p><blockquote><p>用于启动和控制Web上的java程序。Java Web Start，可从Web下载和运行Java应用程序，下载、安装、运行、更新Java应用程序都非常简单方便</p></blockquote><p><strong>jcmd.exe</strong></p><blockquote><p>Java 命令行(JavaCommand)，用于向正在运行的JVM发送诊断命令请求</p></blockquote><p><strong>jconsole.exe</strong></p><blockquote><p>图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息</p></blockquote><p><strong>Jdb.exe</strong></p><blockquote><p>Java调试工具(Java Debugger)，主要用于对Java应用进行断点调试</p></blockquote><p><strong>jdeps.exe</strong></p><blockquote><p>类依赖分析器，显示Java类的包级别或类级别的依赖，接受一个.class文件，一个目录，或者一个jar文件作为输入，默认把结果输出到系统输出（控制台）上 (Java8新特性)</p></blockquote><p><strong>jhat.exe</strong></p><blockquote><p>java堆分析工具(Java Heap Analysis Tool)，用于分析Java堆内存中的对象信息</p></blockquote><p><strong>jinfo.exe</strong></p><blockquote><p>Java配置信息工具(Java Configuration Information)，打印指定Java进程、核心文件或远程调试服务器的配置信息</p></blockquote><p><strong>jjs.exe</strong></p><blockquote><p>Nashorn引擎，接受一些JavaScript源代码为参数，并且执行这些源代码  (Java8新特性)</p></blockquote><p><strong>jmap.exe</strong></p><blockquote><p>Java内存映射工具(Java Memory Map)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节</p></blockquote><p><strong>jmc.exe</strong></p><blockquote><p>Java任务控制工具(Java Mission Control)，主要用于HotSpot JVM的生产时间监测、分析、诊断</p></blockquote><p><strong>jps.exe</strong></p><blockquote><p>JVM进程状态工具(JVM Process Status Tool)，用于显示目标系统上的HotSpotJVM的Java进程信息</p></blockquote><p><strong>jrunscript.exe</strong></p><blockquote><p>Java命令行脚本外壳工具(commandline script shell)，用于解释执行javascript、groovy、ruby等脚本语言</p></blockquote><p><strong>jsadebugd.exe</strong></p><blockquote><p>Java可用性代理调试守护进程(JavaServiceability Agent Debug Daemon)，主要用于附加到指定的Java进程、核心文件，或充当一个调试服务器</p></blockquote><p><strong>jstack.exe</strong></p><blockquote><p>Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息</p></blockquote><p><strong>jstat.exe</strong></p><blockquote><p>JVM统计监测工具(JVM Statistics Monitoring Tool)，主要用于监测并显示JVM的性能统计信息</p></blockquote><p><strong>jstatd.exe</strong></p><blockquote><p>jstatd(VM jstatd Daemon)工具是一个RMI服务器应用，用于监测HotSpotJVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上</p></blockquote><p><strong>jvisualvm.exe</strong></p><blockquote><p>JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息</p></blockquote><p><strong>keytool.exe</strong></p><blockquote><p>密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等</p></blockquote><p><strong>kinit.exe</strong></p><blockquote><p>主要用于获取或缓存Kerberos协议的票据授权票据</p></blockquote><p><strong>klist.exe</strong></p><blockquote><p>允许用户查看本地凭据缓存和密钥表中的条目(用于Kerberos协议)</p></blockquote><p><strong>ktab.exe</strong></p><blockquote><p>Kerberos密钥表管理工具，允许用户管理存储于本地密钥表中的主要名称和服务密钥</p></blockquote><p><strong>native2ascii.exe</strong></p><blockquote><p>本地编码到ASCII编码的转换器(Native-to-ASCIIConverter)，用于”任意受支持的字符编码”和与之对应的”ASCII编码和(或)Unicode转义”之间的相互转换</p></blockquote><p><strong>orbd.exe</strong></p><blockquote><p>对象请求代理守护进程(Object Request Broker Daemon)，它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象</p></blockquote><p><strong>pack200.exe</strong></p><blockquote><p>AR文件打包压缩工具，它可以利用Java类特有的结构，对普通JAR文件进行高效压缩，以便于能够更快地进行网络传输</p></blockquote><p><strong>packager.exe</strong></p><blockquote><p>这是微软提供的对象包装程序，用于对象安装包</p></blockquote><p><strong>policytool.exe</strong></p><blockquote><p>策略工具，用于管理用户策略文件(.java.policy)</p></blockquote><p><strong>rmic.exe</strong></p><blockquote><p>Java RMI 编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMG IDL</p></blockquote><p><strong>rmid.exe</strong></p><blockquote><p>Java RMI 激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象</p></blockquote><p><strong>rmiregistry.exe</strong></p><blockquote><p>Java 远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表</p></blockquote><p><strong>schemagen.exe</strong></p><blockquote><p>XML schema生成器，用于生成XMLschema文件</p></blockquote><p><strong>serialver.exe</strong></p><blockquote><p>序列版本命令，用于生成并返回serialVersionUID</p></blockquote><p><strong>servertool.exe</strong></p><blockquote><p>Java IDL 服务器工具，用于注册、取消注册、启动和终止持久化的服务器</p></blockquote><p><strong>tnameserv.exe</strong></p><blockquote><p>Java IDL瞬时命名服务</p></blockquote><p><strong>unpack200.exe</strong></p><blockquote><p>JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件</p></blockquote><p><strong>wsgen.exe</strong></p><blockquote><p>XML Web Service 2.0的Java API，生成用于JAX-WS Web Service的JAX-WS便携式产物</p></blockquote><p><strong>wsimport.exe</strong></p><blockquote><p>XML Web Service 2.0的Java API，主要用于根据服务端发布的wsdl文件生成客户端存根及框架</p></blockquote><p><strong>xjc.exe</strong></p><blockquote><p>主要用于根据XML schema文件生成对应的Java类</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;appletviewer.exe&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一种执行HTML文件上的Java小程序类的Java浏览器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;apt.exe&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注解处理工具(Annotation Processing Tool), SolarisTM 操作系统和 Linux上用于处理注释的工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;extcheck.exe&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展检测工具，检测目标 jar 文件与当前安装方式扩展jar 文件间的版本冲突&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://doboot.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL分库分表的一些技巧</title>
    <link href="http://doboot.github.io/2017/04/17/mysql-fen-ku-fen-biao-de-yi-xie-ji-qiao/"/>
    <id>http://doboot.github.io/2017/04/17/mysql-fen-ku-fen-biao-de-yi-xie-ji-qiao/</id>
    <published>2017-04-17T11:43:08.000Z</published>
    <updated>2020-11-14T06:10:20.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="纵向分表"><a href="#纵向分表" class="headerlink" title="纵向分表"></a>纵向分表</h4><p>​    将本来可以在同一个表的内容，人为划分为多个表。（所谓的本来，是指按照关系型数据库的第三范式要求，是应该在同一个表的。）<br>分表理由：根据数据的活跃度进行分离，（因为不同活跃的数据，处理方式是不同的） </p><p><strong>案例</strong><br>对于一个博客系统，文章标题，作者，分类，创建时间等，是变化频率慢，查询次数多，而且最好有很好的实时性的数据，我们把它叫做冷数据。而博客的浏览量，回复数等，类似的统计信息，或者别的变化频率比较高的数据，我们把它叫做活跃数据。</p><p>所以，在进行数据库结构设计的时候，就应该考虑分表，首先是纵向分表的处理。<br>这样纵向分表后： 首先存储引擎的使用不同，冷数据使用MyIsam 可以有更好的查询数据。活跃数据，可以使用Innodb ,可以有更好的更新速度。 </p><p>其次，对冷数据进行更多的从库配置，因为更多的操作时查询，这样来加快查询速度。对热数据，可以相对有更多的主库的横向分表处理。 </p><p>其实，对于一些特殊的活跃数据，也可以考虑使用memcache ,redis之类的缓存，等累计到一定量再去更新数据库。或者mongodb 一类的nosql 数据库，这里只是举例，就先不说这个。 </p><a id="more"></a><h3 id="横向分表"><a href="#横向分表" class="headerlink" title="横向分表"></a>横向分表</h3><p>​    字面意思，就可以看出来，是把大的表结构，横向切割为同样结构的不同表，如，用户信息表，user_1,user_2 等。表结构是完全一样，但是，根据某些特定的规则来划分的表，如根据用户ID来取模划分。<br>分表理由：根据数据量的规模来划分，保证单表的容量不会太大，从而来保证单表的查询等处理能力。<br>案例：同上面的例子，博客系统。当博客的量达到很大时候，就应该采取横向分割来降低每个单表的压力，来提升性能。例如博客的冷数据表，假如分为100个表，当同时有100万个用户在浏览时，如果是单表的话，会进行100万次请求，而现在分表后，就可能是每个表进行1万个数据的请求（因为，不可能绝对的平均，只是假设），这样压力就降低了很多很多。 </p><p>数据库的复制能解决访问问题，并不能解决大规模的并发写入问题，要解决这个问题就要考虑mysql数据切分了 </p><p>数据切分，顾名思义，就是数据分散，将一台主机上的数据分摊到多台，减轻单台主机的负载压力，有两种切分方式，一种是分库，即按照业务模块分多个库，每个库中的表不一样，还有一种就是分表，按照一定的业务规则或者逻辑将数据拆分到不同的主机上，每个主机上的表是一样的，这个有点类似于Oracle的表分区。 </p><p>分库又叫垂直分区，这种方式实现起来比较简单，重要的是对业务要细化，分库时候要想清楚各个模块业务之间的交互情况，避免将来写程序时出现过多的跨库操作。 </p><p>分表又叫水平分区，这种方式实现起来就比垂直分区复杂些，但是它能解决垂直分区所不能解决的问题，即单张表的访问及写入很频繁，这时候就可以根据一定的业务规则（PS:如互联网BBS论坛的会员等级概念：根据会员等级来分表）来分表，这样就能减轻单表压力，并且还能解决各个模块的之间的频繁交互问题。 </p><p>分库的优点是：实现简单，库与库之间界限分明，便于维护，缺点是不利于频繁跨库操作，单表数据量大的问题解决不了。</p><p>分表的优点是：能解决分库的不足点，但是缺点却恰恰是分库的优点，分表实现起来比较复杂，特别是分表规则的划分，程序的编写，以及后期的数据库拆分移植维护。 </p><p>实际应用中，一般互联网企业的路线都是先分库再分表，两者结合使用，取长补短，这样发挥了mysql扩展的最大优势，但是缺点是架构很大，很复杂，应用程序的编写也比较复杂。 </p><p>以上是mysql的数据切分的一些概念，数据切完了，现在要做的是怎么样在整合起来以便于外界访问，因为程序访问的入口永远只有一个，现在比较常用的解决方案是通过中间代理层来统一管控所有数据源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;纵向分表&quot;&gt;&lt;a href=&quot;#纵向分表&quot; class=&quot;headerlink&quot; title=&quot;纵向分表&quot;&gt;&lt;/a&gt;纵向分表&lt;/h4&gt;&lt;p&gt;​    将本来可以在同一个表的内容，人为划分为多个表。（所谓的本来，是指按照关系型数据库的第三范式要求，是应该在同一个表的。）&lt;br&gt;分表理由：根据数据的活跃度进行分离，（因为不同活跃的数据，处理方式是不同的） &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例&lt;/strong&gt;&lt;br&gt;对于一个博客系统，文章标题，作者，分类，创建时间等，是变化频率慢，查询次数多，而且最好有很好的实时性的数据，我们把它叫做冷数据。而博客的浏览量，回复数等，类似的统计信息，或者别的变化频率比较高的数据，我们把它叫做活跃数据。&lt;/p&gt;
&lt;p&gt;所以，在进行数据库结构设计的时候，就应该考虑分表，首先是纵向分表的处理。&lt;br&gt;这样纵向分表后： 首先存储引擎的使用不同，冷数据使用MyIsam 可以有更好的查询数据。活跃数据，可以使用Innodb ,可以有更好的更新速度。 &lt;/p&gt;
&lt;p&gt;其次，对冷数据进行更多的从库配置，因为更多的操作时查询，这样来加快查询速度。对热数据，可以相对有更多的主库的横向分表处理。 &lt;/p&gt;
&lt;p&gt;其实，对于一些特殊的活跃数据，也可以考虑使用memcache ,redis之类的缓存，等累计到一定量再去更新数据库。或者mongodb 一类的nosql 数据库，这里只是举例，就先不说这个。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://doboot.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Caffeine</title>
    <link href="http://doboot.github.io/2017/04/15/introduction-to-caffeine/"/>
    <id>http://doboot.github.io/2017/04/15/introduction-to-caffeine/</id>
    <published>2017-04-15T03:32:00.000Z</published>
    <updated>2020-11-14T06:10:20.919Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>In this article, we’re going to take a look at <a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine</a> — a <strong>high-performance caching library for Java</strong>.</p><p>One fundamental difference between a cache and a <em>Map</em> is that a cache evicts stored items.</p><p>An <strong>eviction policy decides which objects should be deleted</strong> at any given time. This policy <strong>directly affects the cache’s hit rate</strong> — a crucial characteristic of caching libraries.</p><p>Caffeine uses the <em>Window TinyLfu</em> eviction policy, which provides a <strong>near-optimal hit rate</strong>.</p><a id="more"></a><h3 id="2-Dependency"><a href="#2-Dependency" class="headerlink" title="2 Dependency"></a>2 Dependency</h3><p>We need to add the <em>caffeine</em> dependency to our <em>pom.xml</em>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>You can find the latest version of <em>caffeine</em> <a href="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22com.github.ben-manes.caffeine%22%20AND%20a%3A%22caffeine%22" target="_blank" rel="noopener">on Maven Central</a>.</p><h3 id="3-Populating-Cache"><a href="#3-Populating-Cache" class="headerlink" title="3 Populating Cache"></a>3 Populating Cache</h3><p>Let’s focus on Caffeine’s <strong>three strategies for cache population</strong>: manual, synchronous loading, and asynchronous loading.</p><p>First, let’s write a class for the types of values that we’ll store in our cache:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> objectCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// standard constructors/getters</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataObject <span class="title">get</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        objectCounter++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataObject(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-Manual-Populating"><a href="#3-1-Manual-Populating" class="headerlink" title="3.1 Manual Populating"></a>3.1 Manual Populating</h4><p>In this strategy, we manually put values into the cache and retrieve them later.</p><p>Let’s initialize our cache:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>Now, <strong>we can get some value from the cache using the getIfPresent method</strong>. This method will return <em>null</em> if the value is not present in the cache:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"A"</span>;</span><br><span class="line">DataObject dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNull(dataObject);</span><br></pre></td></tr></table></figure><p>We can <strong>populate the cache</strong> manually using the <em>put</em> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.put(key, dataObject);</span><br><span class="line">dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br></pre></td></tr></table></figure><p><strong>We can also get the value using the get method</strong>, which takes a <em>Function</em> along with a key as an argument. This function will be used for providing the fallback value if the key is not present in the cache, which would be inserted in the cache after computation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataObject = cache</span><br><span class="line">  .get(key, k -&gt; DataObject.get(<span class="string">"Data for A"</span>));</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br><span class="line">assertEquals(<span class="string">"Data for A"</span>, dataObject.getData());</span><br></pre></td></tr></table></figure><p>The <em>get</em> method performs the computation atomically. This means that the computation will be made only once — even if several threads ask for the value simultaneously. That’s why <strong>using get is preferable to getIfPresent</strong>.</p><p>Sometimes we need to <strong>invalidate some cached values</strong> manually:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.invalidate(key);</span><br><span class="line">dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNull(dataObject);</span><br></pre></td></tr></table></figure><h4 id="3-2-Synchronous-Loading"><a href="#3-2-Synchronous-Loading" class="headerlink" title="3.2 Synchronous Loading"></a>3.2 Synchronous Loading</h4><p>This method of loading the cache takes a <em>Function,</em> which is used for initializing values, similar to the <em>get</em> method of the manual strategy. Let’s see how we can use that.</p><p>First of all, we need to initialize our cache:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure><p>Now we can retrieve the values using the <em>get</em> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataObject dataObject = cache.get(key);</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br><span class="line">assertEquals(<span class="string">"Data for "</span> + key, dataObject.getData());</span><br></pre></td></tr></table></figure><p>We can also get a set of values using the <em>getAll</em> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, DataObject&gt; dataObjectMap </span><br><span class="line">  = cache.getAll(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">3</span>, dataObjectMap.size());</span><br></pre></td></tr></table></figure><p>Values are retrieved from the underlying back-end initialization <em>Function</em> that was passed to the <em>build</em> method. <strong>This makes it possible to use the cache as the main facade for accessing values.</strong></p><h4 id="3-3-Asynchronous-Loading"><a href="#3-3-Asynchronous-Loading" class="headerlink" title="3.3 Asynchronous Loading"></a>3.3 Asynchronous Loading</h4><p>This strategy <strong>works the same as the previous but performs operations asynchronously and returns a CompletableFuture</strong> holding the actual value:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(100)</span><br><span class="line">  .expireAfterWrite(1, TimeUnit.MINUTES)</span><br><span class="line">  .buildAsync(k -&gt; DataObject.get(&quot;Data for &quot; + k));</span><br></pre></td></tr></table></figure><p>We can <strong>use the get and getAll methods</strong>, in the same manner, taking into account the fact that they return <em>CompletableFuture</em>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"A"</span>;</span><br><span class="line"> </span><br><span class="line">cache.get(key).thenAccept(dataObject -&gt; &#123;</span><br><span class="line">    assertNotNull(dataObject);</span><br><span class="line">    assertEquals(<span class="string">"Data for "</span> + key, dataObject.getData());</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">cache.getAll(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>))</span><br><span class="line">  .thenAccept(dataObjectMap -&gt; assertEquals(<span class="number">3</span>, dataObjectMap.size()));</span><br></pre></td></tr></table></figure><p><em>CompletableFuture</em> has a rich and useful API, which you can read more about <a href="https://www.doleje.com/java-completablefuture" target="_blank" rel="noopener">in this article</a>.</p><h3 id="4-Eviction-of-Values"><a href="#4-Eviction-of-Values" class="headerlink" title="4 Eviction of Values"></a>4 Eviction of Values</h3><p>Caffeine has <strong>three strategies for value eviction</strong>: size-based, time-based, and reference-based.</p><h4 id="4-1-Size-Based-Eviction"><a href="#4-1-Size-Based-Eviction" class="headerlink" title="4.1 Size-Based Eviction"></a>4.1 Size-Based Eviction</h4><p>This type of eviction assumes that <strong>eviction occurs when the configured size limit of the cache is exceeded</strong>. There are <strong>two ways of getting the size</strong> — counting objects in the cache, or getting their weights.</p><p>Let’s see how we could <strong>count objects in the cache</strong>. When the cache is initialized, its size is equal to zero:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">1</span>)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">0</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure><p>When we add a value, the size obviously increases:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure><p>We can add the second value to the cache, which leads to the removal of the first value:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.get(<span class="string">"B"</span>);</span><br><span class="line">cache.cleanUp();</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure><p>It is worth mention that we <strong>call the cleanUp method before getting the cache size</strong>. This is because the cache eviction is executed asynchronously, and this method <strong>helps to await the completion of the eviction</strong>.</p><p>We can also <strong>pass a weigher</strong> <strong><em>Function</em></strong> to get the size of the cache:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumWeight(<span class="number">10</span>)</span><br><span class="line">  .weigher((k,v) -&gt; <span class="number">5</span>)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">0</span>, cache.estimatedSize());</span><br><span class="line"> </span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br><span class="line"> </span><br><span class="line">cache.get(<span class="string">"B"</span>);</span><br><span class="line">assertEquals(<span class="number">2</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure><p>The values are removed from the cache when the weight is over 10:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.get(<span class="string">"C"</span>);</span><br><span class="line">cache.cleanUp();</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">2</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure><h4 id="4-2-Time-Based-Eviction"><a href="#4-2-Time-Based-Eviction" class="headerlink" title="4.2 Time-Based Eviction"></a>4.2 Time-Based Eviction</h4><p>This eviction strategy is <strong>based on the expiration time of the entry</strong> and has three types:</p><ul><li><strong>Expire after access</strong> — entry is expired after period is passed since the last read or write occurs</li><li><strong>Expire after write</strong> — entry is expired after period is passed since the last write occurs</li><li><strong>Custom policy</strong> — an expiration time is calculated for each entry individually by the <em>Expiry</em> implementation</li></ul><p>Let’s configure the expire-after-access strategy using the <em>expireAfterAccess</em> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure><p>To configure expire-after-write strategy, we use the <em>expireAfterWrite</em> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .weakKeys()</span><br><span class="line">  .weakValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure><p>To initialize a custom policy, we need to implement the <em>Expiry</em> interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cache = Caffeine.newBuilder().expireAfter(<span class="keyword">new</span> Expiry&lt;String, DataObject&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getData().length() * <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDuration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterRead</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure><h4 id="4-3-Reference-Based-Eviction"><a href="#4-3-Reference-Based-Eviction" class="headerlink" title="4.3 Reference-Based Eviction"></a>4.3 Reference-Based Eviction</h4><p>We can configure our cache to allow <strong>garbage-collection of cache keys and/or values</strong>. To do this, we’d configure usage of the <em>WeakRefence</em> for both keys and values, and we can configure the <em>SoftReference</em> for garbage-collection of values only.</p><p>The <em>WeakRefence</em> usage allows garbage-collection of objects when there are not any strong references to the object. <em>SoftReference</em> allows objects to be garbage-collected based on the global Least-Recently-Used strategy of the JVM. More details about references in Java can be found <a href="https://www.doleje.com/java-weakhashmap" target="_blank" rel="noopener">here</a>.</p><p>We should use <em>Caffeine.weakKeys()</em>, <em>Caffeine.weakValues(),</em> and <em>Caffeine.softValues()</em> to enable each option:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .weakKeys()</span><br><span class="line">  .weakValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .softValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure><h3 id="5-Refreshing"><a href="#5-Refreshing" class="headerlink" title="5 Refreshing"></a>5 Refreshing</h3><p>It’s possible to configure the cache to refresh entries after a defined period automatically. Let’s see how to do this using the <em>refreshAfterWrite</em> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caffeine.newBuilder()</span><br><span class="line">  .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure><p>Here we should understand a <strong>difference between expireAfter and refreshAfter</strong>. When the expired entry is requested, an execution blocks until the new value would have been calculated by the build <em>Function</em>.</p><p>But if the entry is eligible for the refreshing, then the cache would return an old value and <strong>asynchronously reload the value</strong>.</p><h3 id="6-Statistics"><a href="#6-Statistics" class="headerlink" title="6 Statistics"></a>6 Statistics</h3><p>Caffeine has a means of <strong>recording statistics about cache usage</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .recordStats()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.stats().hitCount());</span><br><span class="line">assertEquals(<span class="number">1</span>, cache.stats().missCount());</span><br></pre></td></tr></table></figure><p>We may also pass into <em>recordStats</em> supplier, which creates an implementation of the <em>StatsCounter.</em> This object will be pushed with every statistics-related change.</p><h3 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h3><p>In this article, we got acquainted with the Caffeine caching library for Java. We saw how to configure and populate a cache, as well as how to choose an appropriate expiration or refresh policy according to our needs.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1 Introduction&quot;&gt;&lt;/a&gt;1 Introduction&lt;/h3&gt;&lt;p&gt;In this article, we’re going to take a look at &lt;a href=&quot;https://github.com/ben-manes/caffeine&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Caffeine&lt;/a&gt; — a &lt;strong&gt;high-performance caching library for Java&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;One fundamental difference between a cache and a &lt;em&gt;Map&lt;/em&gt; is that a cache evicts stored items.&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;eviction policy decides which objects should be deleted&lt;/strong&gt; at any given time. This policy &lt;strong&gt;directly affects the cache’s hit rate&lt;/strong&gt; — a crucial characteristic of caching libraries.&lt;/p&gt;
&lt;p&gt;Caffeine uses the &lt;em&gt;Window TinyLfu&lt;/em&gt; eviction policy, which provides a &lt;strong&gt;near-optimal hit rate&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="缓存" scheme="http://doboot.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Caffine" scheme="http://doboot.github.io/tags/Caffine/"/>
    
  </entry>
  
  <entry>
    <title>为 Hexo 增加流程图解析功能</title>
    <link href="http://doboot.github.io/2017/04/14/wei-hexo-zeng-jia-liu-cheng-tu-jie-xi-gong-neng/"/>
    <id>http://doboot.github.io/2017/04/14/wei-hexo-zeng-jia-liu-cheng-tu-jie-xi-gong-neng/</id>
    <published>2017-04-14T09:33:00.000Z</published>
    <updated>2020-11-14T06:10:20.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p><a href="https://github.com/bubkoo/hexo-filter-flowchart" target="_blank" rel="noopener">hexo-filter-flowchart</a> 插件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>站点配置文件 _config.yml 中增加如下配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flowchart:</span></span><br><span class="line"><span class="comment"># raphael:   # optional, the source url of raphael.js</span></span><br><span class="line"><span class="comment"># flowchart: # optional, the source url of flowchart.js</span></span><br><span class="line"><span class="attr">options:</span> <span class="comment"># options used for `drawSVG`</span></span><br><span class="line">      <span class="attr">scale:</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">      <span class="attr">line-width:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">line-length:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">text-margin:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">font-size:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h2><p>新建文章，增加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: 操作</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">cond=&gt;condition: 成功</span><br><span class="line">io=&gt;inputoutput: 输入输出...</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op1</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><div id="flowchart-0" class="flow-chart"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始e=>end: 结束op1=>operation: 操作sub1=>subroutine: 子流程cond=>condition: 成功io=>inputoutput: 输入输出...st->op1->condcond(yes)->io->econd(no)->sub1(right)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装&quot;&gt;&lt;/a&gt;1. 安装&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bubkoo/hexo-filter-flowchart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-filter-flowchart&lt;/a&gt; 插件:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save hexo-filter-flowchart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://doboot.github.io/tags/Hexo/"/>
    
      <category term="博客" scheme="http://doboot.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="流程图" scheme="http://doboot.github.io/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下安装Nginx</title>
    <link href="http://doboot.github.io/2017/03/02/linux-huan-jing-xia-an-zhuang-nginx/"/>
    <id>http://doboot.github.io/2017/03/02/linux-huan-jing-xia-an-zhuang-nginx/</id>
    <published>2017-03-02T07:19:00.000Z</published>
    <updated>2020-11-14T06:10:20.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>Nginx</strong> 是一个高性能的HTTP和反向代理服务器，官方地址为<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a>，这里不多做介绍。本次介绍使用源码编译安装，安装Nginx前需要安装C++编译环境，可使用以下命令安装：</p><p>Centos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gcc gcc-c++</span><br></pre></td></tr></table></figure><p>Ubuntu:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install libtool</span><br></pre></td></tr></table></figure><p>Nginx下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a><br><a id="more"></a></p><p><strong>安装Nginx需要3个依赖包：</strong></p><ul><li>gzip模块需要 zlib (<a href="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net/</a>)</li><li>rewrite模块需要 pcre(<a href="http://www.pcre.org/" target="_blank" rel="noopener">http://www.pcre.org/</a>)</li><li>ssl 需要 openssl (<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a>)</li></ul><h2 id="2-安装pcre"><a href="#2-安装pcre" class="headerlink" title="2. 安装pcre"></a>2. 安装pcre</h2><p><strong>pcre</strong> 的作用是让Nginx支持Rewrite功能。本次介绍使用pcre，非pcre2版本，我在使用pcre2安装Nginx时出现错误，后来改用pcre没有报错。</p><p>下载pcre，地址: <a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载</span><br><span class="line">sudo wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf pcre-8.38.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd pcre-8.38</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="3-安装zlib"><a href="#3-安装zlib" class="headerlink" title="3. 安装zlib"></a>3. 安装zlib</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载 </span><br><span class="line">sudo wget http://www.zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd zlib-1.2.11</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="4-安装openssl"><a href="#4-安装openssl" class="headerlink" title="4. 安装openssl"></a>4. 安装openssl</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载 </span><br><span class="line">sudo wget https://www.openssl.org/source/openssl-1.0.2n.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf openssl-1.0.2n.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd openssl-1.0.2n</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo ./config --prefix=/usr/local/openssl</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="5-安装Nginx"><a href="#5-安装Nginx" class="headerlink" title="5. 安装Nginx"></a>5. 安装Nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载 </span><br><span class="line">sudo wget http://nginx.org/download/nginx-1.8.1.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf nginx-1.8.1.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd nginx-1.8.1</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo ./configure --prefix=/usr/local/nginx --with-pcre=/home/user-01/download/pcre-8.38 --with-zlib=/home/user-01/download/zlib-1.2.11 --with-openssl=/usr/local/openssl</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 指定<code>pcre</code>和<code>zlib</code>的路径是源码路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--with-pcre=/home/user-01/download/pcre-8.38         # 指的是pcre-8.38 的源码路径。</span><br><span class="line">--with-zlib=/home/user-01/download/zlib-1.2.11       # 指的是zlib-1.2.11 的源码路径。</span><br></pre></td></tr></table></figure><h2 id="6-启动Nginx"><a href="#6-启动Nginx" class="headerlink" title="6. 启动Nginx"></a>6. 启动Nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>浏览器访问，看到下图则说明Nginx安装并启动成功。</p><p><img src="/images/pasted-111.png" alt="upload successful"></p><h2 id="7-Nginx-常用命令"><a href="#7-Nginx-常用命令" class="headerlink" title="7. Nginx 常用命令"></a>7. Nginx 常用命令</h2><p>检查配置文件<code>nginx.conf</code>的正确性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure><p>停止Nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure><p>重新加载配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt; 是一个高性能的HTTP和反向代理服务器，官方地址为&lt;a href=&quot;http://nginx.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://nginx.org/&lt;/a&gt;，这里不多做介绍。本次介绍使用源码编译安装，安装Nginx前需要安装C++编译环境，可使用以下命令安装：&lt;/p&gt;
&lt;p&gt;Centos&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install gcc gcc-c++&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Ubuntu:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get install build-essential&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-get install libtool&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Nginx下载地址：&lt;a href=&quot;http://nginx.org/en/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://doboot.github.io/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://doboot.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>MapStruct 介绍</title>
    <link href="http://doboot.github.io/2017/02/28/mapstruct-jie-shao/"/>
    <id>http://doboot.github.io/2017/02/28/mapstruct-jie-shao/</id>
    <published>2017-02-28T07:52:00.000Z</published>
    <updated>2020-11-14T06:10:20.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在一个成熟的工程中，尤其是现在的分布式系统中，应用与应用之间，还有单独的应用细分模块之后，DO 一般不会让外部依赖，这时候需要在提供对外接口的模块里放 DTO 用于对象传输，也即是 DO 对象对内，DTO对象对外，DTO 可以根据业务需要变更，并不需要映射 DO 的全部属性。</p><p>这种 对象与对象之间的互相转换，就需要有一个专门用来解决转换问题的工具，毕竟每一个字段都 get/set 会很麻烦。</p><p>MapStruct 就是这样的一个属性映射工具，只需要定义一个 Mapper 接口，MapStruct 就会自动实现这个映射接口，避免了复杂繁琐的映射实现。MapStruct官网地址： <a href="mapstruct.org">mapstruct.org</a>。<br><a id="more"></a></p><h2 id="2-Maven"><a href="#2-Maven" class="headerlink" title="2. Maven"></a>2. Maven</h2><p>让我们在Maven <em>pom.xml中</em>添加以下依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.Beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最新的<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.mapstruct&quot; AND a%3A&quot;mapstruct-jdk8&quot;" target="_blank" rel="noopener">Mapstruct</a>及其<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.mapstruct&quot; AND a%3A&quot;mapstruct-processor&quot;" target="_blank" rel="noopener">processor</a>稳定版本均可从Maven Central Repository获得。</p><p>我们还将<em>annotationProcessorPaths</em>部分添加到<em>maven-compiler-plugin</em>插件的配置部分，用于生成具体的映射器实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.Beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-基本映射"><a href="#3-基本映射" class="headerlink" title="3. 基本映射"></a>3. 基本映射</h2><h3 id="3-1-创建基本的-POJO"><a href="#3-1-创建基本的-POJO" class="headerlink" title="3.1 创建基本的 POJO"></a>3.1 创建基本的 POJO</h3><p>让我们首先创建一个简单的Java POJO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDestination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-映射器接口"><a href="#3-2-映射器接口" class="headerlink" title="3.2. 映射器接口"></a>3.2. 映射器接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span></span>;</span><br><span class="line">    <span class="function">SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们没有为<em>SimpleSourceDestinationMapper</em>创建实现类- 因为MapStruct将为我们创建它。</p><h3 id="3-3-映射器接口实现"><a href="#3-3-映射器接口实现" class="headerlink" title="3.3. 映射器接口实现"></a>3.3. 映射器接口实现</h3><p>我们可以通过执行<em>mvn clean install</em>来触发MapStruct处理，插件将在 <em>/target/generated-sources/annotations/</em>下生成具体的实现类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperImpl</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( source == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDestination simpleDestination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        simpleDestination.setName( source.getName() );</span><br><span class="line">        simpleDestination.setDescription( source.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleDestination;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( destination == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName( destination.getName() );</span><br><span class="line">        simpleSource.setDescription( destination.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-测试用例"><a href="#3-4-测试用例" class="headerlink" title="3.4 测试用例"></a>3.4 测试用例</h3><p>最后，通过生成所有内容，让我们编写一个测试用例，将显示<em>SimpleSource</em>中的值与<em>SimpleDestination</em>中的值匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SimpleSourceDestinationMapper mapper</span><br><span class="line">      = Mappers.getMapper(SimpleSourceDestinationMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenSourceToDestination_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName(<span class="string">"SourceName"</span>);</span><br><span class="line">        simpleSource.setDescription(<span class="string">"SourceDescription"</span>);</span><br><span class="line">        SimpleDestination destination = mapper.sourceToDestination(simpleSource);</span><br><span class="line">  </span><br><span class="line">        assertEquals(simpleSource.getName(), destination.getName());</span><br><span class="line">        assertEquals(simpleSource.getDescription(), </span><br><span class="line">          destination.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDestinationToSource_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDestination destination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        destination.setName(<span class="string">"DestinationName"</span>);</span><br><span class="line">        destination.setDescription(<span class="string">"DestinationDescription"</span>);</span><br><span class="line">        SimpleSource source = mapper.destinationToSource(destination);</span><br><span class="line">        assertEquals(destination.getName(), source.getName());</span><br><span class="line">        assertEquals(destination.getDescription(),</span><br><span class="line">          source.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用-Spring-依赖注入"><a href="#4-使用-Spring-依赖注入" class="headerlink" title="4. 使用 Spring 依赖注入"></a>4. 使用 Spring 依赖注入</h2><p>在上面的单元测试中，我们通过调用<em>Mappers.getMapper（YourClass.class）来</em>获取MapStruct中mapper的实例。当然，这是获取实例的一种非常手动的方式 - 更好的替代方法是将mapper直接注入我们需要的位置（如果我们的项目使用任何依赖注入解决方案）。</p><p><strong>幸运的是，MapStruct对Spring和CDI</strong>（<em>上下文和依赖注入</em>）<strong>都提供了很好的支持</strong>。</p><p>要在我们的映射器中使用Spring IoC，只需要给<em>@Mapper</em>注解添加 <em>componentModel=spring</em> 属性，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span></span></span><br></pre></td></tr></table></figure><h2 id="5-使用不同字段名称映射字段"><a href="#5-使用不同字段名称映射字段" class="headerlink" title="5. 使用不同字段名称映射字段"></a>5. 使用不同字段名称映射字段</h2><p>从前面的示例中，MapStruct能够自动映射我们的bean，因为它们具有相同的字段名称。那么如果我们要映射的bean有不同的字段名称呢？</p><p>对于我们的示例，我们将创建一个名为<em>Employee</em>和<em>EmployeeDTO</em>的新bean 。</p><h3 id="5-1-新的-POJO"><a href="#5-1-新的-POJO" class="headerlink" title="5.1 新的 POJO"></a>5.1 新的 POJO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-Mapper"><a href="#5-2-Mapper" class="headerlink" title="5.2 Mapper"></a>5.2 Mapper</h3><p>在映射不同的字段名称时，我们需要将其源字段配置为其目标字段，为此，我们需要添加<em>@Mappings</em>注释。此批注接受一个<em>@Mapping</em>批注数组，我们将使用它来添加目标和源属性。</p><p>在MapStruct中，我们还可以使用点表示法来定义bean的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-测试用例"><a href="#5-3-测试用例" class="headerlink" title="5.3 测试用例"></a>5.3 测试用例</h3><p>我们再次需要测试源和目标对象值是否匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-嵌套映射"><a href="#6-嵌套映射" class="headerlink" title="6. 嵌套映射"></a>6. 嵌套映射</h2><p>接下来，我们将展示如何使用对其他bean的引用来映射bean。</p><h3 id="6-1-修改-POJO"><a href="#6-1-修改-POJO" class="headerlink" title="6.1 修改 POJO"></a>6.1 修改 POJO</h3><p>让我们为<em>Employee</em>对象添加一个新的bean引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="keyword">private</span> DivisionDTO division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Division division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Division</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// default constructor, getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-修改Mapper"><a href="#6-2-修改Mapper" class="headerlink" title="6.2 修改Mapper"></a>6.2 修改Mapper</h3><p>这里我们需要添加一个方法将<em>Division</em>转换为<em>DivisionDTO</em>，反之亦然; 如果MapStruct检测到需要转换对象类型并且转换方法存在于同一个类中，那么它将自动使用它。</p><p>让我们将它添加到映射器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DivisionDTO <span class="title">divisionToDivisionDTO</span><span class="params">(Division entity)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Division <span class="title">divisionDTOtoDivision</span><span class="params">(DivisionDTO dto)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-3-修改测试用例"><a href="#6-3-修改测试用例" class="headerlink" title="6.3 修改测试用例"></a>6.3 修改测试用例</h3><p>让我们修改并添加一些测试用例到现有测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpDTONestedMappingToEmp_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmployeeDTO dto = <span class="keyword">new</span> EmployeeDTO();</span><br><span class="line">    dto.setDivision(<span class="keyword">new</span> DivisionDTO(<span class="number">1</span>, <span class="string">"Division1"</span>));</span><br><span class="line">    Employee entity = mapper.employeeDTOtoEmployee(dto);</span><br><span class="line">    assertEquals(dto.getDivision().getId(), </span><br><span class="line">      entity.getDivision().getId());</span><br><span class="line">    assertEquals(dto.getDivision().getName(), </span><br><span class="line">      entity.getDivision().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-映射过程中的类型转换"><a href="#7-映射过程中的类型转换" class="headerlink" title="7. 映射过程中的类型转换"></a>7. 映射过程中的类型转换</h2><p>MapStruct还提供了几个现成的隐式类型转换，对于我们的示例，我们将尝试将String日期转换为实际的<em>Date</em>对象。</p><p>有关隐式类型转换的更多详细信息，可以阅读<a href="http://mapstruct.org/documentation/1.0/reference/html/#implicit-type-conversions" target="_blank" rel="noopener">MapStruct参考指南</a>。</p><h3 id="7-1-修改-POJO"><a href="#7-1-修改-POJO" class="headerlink" title="7.1 修改 POJO"></a>7.1 修改 POJO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">    <span class="keyword">private</span> Date startDt;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">    <span class="keyword">private</span> String employeeStartDt;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-修改Mapper"><a href="#7-2-修改Mapper" class="headerlink" title="7.2 修改Mapper"></a>7.2 修改Mapper</h3><p>修改映射器并为我们的开始日期提供<em>dateFormat</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source = <span class="string">"entity.id"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source = <span class="string">"entity.name"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeStartDt"</span>, source = <span class="string">"entity.startDt"</span>,</span><br><span class="line">           dateFormat = <span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"startDt"</span>, source=<span class="string">"dto.employeeStartDt"</span>,</span><br><span class="line">           dateFormat=<span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-3-修改测试用例"><a href="#7-3-修改测试用例" class="headerlink" title="7.3 修改测试用例"></a>7.3 修改测试用例</h3><p>让我们再添加一些测试用例来验证转换是否正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATE_FORMAT = <span class="string">"dd-MM-yyyy HH:mm:ss"</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpStartDtMappingToEmpDTO_whenMaps_thenCorrect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    Employee entity = <span class="keyword">new</span> Employee();</span><br><span class="line">    entity.setStartDt(<span class="keyword">new</span> Date());</span><br><span class="line">    EmployeeDTO dto = mapper.employeeToEmployeeDTO(entity);</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(DATE_FORMAT);</span><br><span class="line">  </span><br><span class="line">    assertEquals(format.parse(dto.getEmployeeStartDt()).toString(),</span><br><span class="line">      entity.getStartDt().toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpDTOStartDtMappingToEmp_whenMaps_thenCorrect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    EmployeeDTO dto = <span class="keyword">new</span> EmployeeDTO();</span><br><span class="line">    dto.setEmployeeStartDt(<span class="string">"01-04-2016 01:00:00"</span>);</span><br><span class="line">    Employee entity = mapper.employeeDTOtoEmployee(dto);</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(DATE_FORMAT);</span><br><span class="line">  </span><br><span class="line">    assertEquals(format.parse(dto.getEmployeeStartDt()).toString(),</span><br><span class="line">      entity.getStartDt().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-自定义映射结合（抽象类）"><a href="#8-自定义映射结合（抽象类）" class="headerlink" title="8. 自定义映射结合（抽象类）"></a>8. 自定义映射结合（抽象类）</h2><p>有时，我们希望通过自定义一些映射方式来扩展 <em>@Mapping</em>功能，比如除了类型转换之外，我们可能希望以某种方式转换值，如下面的示例所示，在这种情况下，我们可以创建一个抽象类并实现我们想要自定义的方法，并留下那些应该由MapStruct生成的抽象类。</p><h3 id="8-1-基本模型"><a href="#8-1-基本模型" class="headerlink" title="8. 1 基本模型"></a>8. 1 基本模型</h3><p>在这个例子中，我们将使用以下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//standard getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配的 DTO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDTO</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="keyword">private</span> Long totalInCents;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里棘手的部分是将<em>BigDecimal</em>  <em>总</em>金额转换为<em>Long totalInCents</em>。</p><h3 id="8-2-定义-Mapper"><a href="#8-2-定义-Mapper" class="headerlink" title="8.2 定义 Mapper"></a>8.2 定义 Mapper</h3><p>我们可以通过将<em>Mapper</em> 创建  为抽象类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionDTO <span class="title">toTransactionDTO</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">        TransactionDTO transactionDTO = <span class="keyword">new</span> TransactionDTO();</span><br><span class="line">        transactionDTO.setUuid(transaction.getUuid());</span><br><span class="line">        transactionDTO.setTotalInCents(transaction.getTotal()</span><br><span class="line">          .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>)).longValue());</span><br><span class="line">        <span class="keyword">return</span> transactionDTO;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;TransactionDTO&gt; <span class="title">toTransactionDTO</span><span class="params">(Collection&lt;Transaction&gt; transactions)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们为单个对象转换实现了完全自定义的映射方法。</p><p>另一方面，我们留下了将<em>Collection</em>映射到<em>List</em>抽象的方法，因此<em>MapStruct</em> 将为我们实现它。</p><h3 id="8-3-生成的结果"><a href="#8-3-生成的结果" class="headerlink" title="8.3 生成的结果"></a>8.3 生成的结果</h3><p>由于我们已经实现了将单个<em>Transaction</em>映射到<em>TransactionDTO的方法</em>，我们希望<em>Mapstruct</em>在第二种方法中使用它。将生成以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Generated</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionMapperImpl</span> <span class="keyword">extends</span> <span class="title">TransactionMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TransactionDTO&gt; <span class="title">toTransactionDTO</span><span class="params">(Collection&lt;Transaction&gt; transactions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( transactions == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        List&lt;TransactionDTO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( Transaction transaction : transactions ) &#123;</span><br><span class="line">            list.add( toTransactionDTO( transaction ) );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们在第12行中看到的，<em>MapStruct</em> 在它生成的方法中使用我们的实现。</p><h2 id="9-支持-Lombok"><a href="#9-支持-Lombok" class="headerlink" title="9. 支持 Lombok"></a>9. 支持 Lombok</h2><p>在最新版本的MapStruct中，已经提供了对Lombok的支持。<strong>因此，我们可以使用Lombok轻松映射源实体和目标。</strong> 要启用Lombok支持，我们需要在注释处理器路径中添加<a href="https://search.maven.org/search?q=a:lombok" target="_blank" rel="noopener">依赖项</a>。所以现在我们在Maven编译器插件中有了mapstruct-processor和Lombok：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.Beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让我们使用Lombok注释定义源实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和目标数据传输对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个mapper接口仍然类似于我们前面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarMapper</span> </span>&#123;</span><br><span class="line">    CarMapper INSTANCE = Mappers.getMapper(CarMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function">CarDTO <span class="title">carToCarDTO</span><span class="params">(Car car)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-支持-defaultExpression"><a href="#10-支持-defaultExpression" class="headerlink" title="10. 支持  defaultExpression"></a>10. 支持  defaultExpression</h2><p>从版本1.3.0开始，<strong>我们可以使用@Mapping批注的defaultExpression属性来指定一个表达式，如果源字段为null，则该表达式确定目标字段的值。</strong>这是现有<em>defaultValue</em>属性功能的补充。</p><p>源实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标数据传输对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果源实体的<em>id</em>字段为<em>null，</em>我们想要生成一个随机<em>id</em>并将其分配给目标，保持其他属性值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"id"</span>, source = <span class="string">"person.id"</span>, </span><br><span class="line">      defaultExpression = <span class="string">"java(java.util.UUID.randomUUID().toString())"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">personToPersonDTO</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们添加一个测试用例来验证表达式的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPersonEntitytoPersonWithExpression_whenMaps_thenCorrect</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    Person entity  </span>= <span class="keyword">new</span> Person();</span><br><span class="line">    entity.setName(<span class="string">"Micheal"</span>);</span><br><span class="line">    PersonDTO personDto = PersonMapper.INSTANCE.personToPersonDTO(entity);</span><br><span class="line">    assertNull(entity.getId());</span><br><span class="line">    assertNotNull(personDto.getId());</span><br><span class="line">    assertEquals(personDto.getName(), entity.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;在一个成熟的工程中，尤其是现在的分布式系统中，应用与应用之间，还有单独的应用细分模块之后，DO 一般不会让外部依赖，这时候需要在提供对外接口的模块里放 DTO 用于对象传输，也即是 DO 对象对内，DTO对象对外，DTO 可以根据业务需要变更，并不需要映射 DO 的全部属性。&lt;/p&gt;
&lt;p&gt;这种 对象与对象之间的互相转换，就需要有一个专门用来解决转换问题的工具，毕竟每一个字段都 get/set 会很麻烦。&lt;/p&gt;
&lt;p&gt;MapStruct 就是这样的一个属性映射工具，只需要定义一个 Mapper 接口，MapStruct 就会自动实现这个映射接口，避免了复杂繁琐的映射实现。MapStruct官网地址： &lt;a href=&quot;mapstruct.org&quot;&gt;mapstruct.org&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
