<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Acegi 组件概览</title>
    <url>/2008/02/15/acegi-zu-jian-gai-lan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、Filter-组件"><a href="#一、Filter-组件" class="headerlink" title="一、Filter 组件"></a>一、Filter 组件</h3><h4 id="HttpSessionContextIntegrationFilter"><a href="#HttpSessionContextIntegrationFilter" class="headerlink" title="HttpSessionContextIntegrationFilter"></a>HttpSessionContextIntegrationFilter</h4><p>该Filter 负责每次请求从HttpSession中获取Authentication对象，然后把Authentication存于一个新的 ContextHolder对象(其实质上只是一个ThreadLocal对象)中，则让该次请求过程中的任何Filter都可以通过 ContextHolder来共享Authentication，而不需要从HttpSession中取，减少传HttpRequest参数的麻烦。在请求完后把Authentication对象保存到HttpSession中供下次请求使用，最后把刚才生成的ContextHolder对象销毁。这样就达到了让Authentication对象跨越多个请求的目的，注意此filter须在调用其他Acegi filter前使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"httpSessionContextIntegrationFilter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.context.HttpSessionContextIntegrationFilter"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="AuthenticationProcessingFilter"><a href="#AuthenticationProcessingFilter" class="headerlink" title="AuthenticationProcessingFilter"></a>AuthenticationProcessingFilter</h4><p>该Filter 负责处理登陆身份验证。当接受到与filterProcessesUrl所定义相同的请求时，它会首先通过AuthenticationManager来验证用户身份。如果验证成功，则重定向到defaultTargetUrl所定义的成功登陆页面。如果验证失败，则再从 rememberMeServices中获取用户身份，若再获取失败，则重定向到auhenticationFailureUrl所定义的登陆失败页面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationProcessingFilter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.webapp.AuthenticationProcessingFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"authenticationManager"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationFailureUrl"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>/acegilogin.jsp?login_error=1<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultTargetUrl"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>/<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterProcessesUrl"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>/j_acegi_security_check<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeServices"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"rememberMeServices"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="LogoutFilter"><a href="#LogoutFilter" class="headerlink" title="LogoutFilter"></a>LogoutFilter</h4><p>该Filter负责处理退出登录后所需要的清理工作。它会把session销毁，把ContextHolder清空，把rememberMeService从cookies中清除掉，然后重定向到指定的退出登陆页面。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logoutFilter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.logout.LogoutFilter"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- URL redirected to after logout --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"/index.jsp"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"rememberMeServices"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.logout.SecurityContextLogoutHandler"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="FilterInvocationInterceptor"><a href="#FilterInvocationInterceptor" class="headerlink" title="FilterInvocationInterceptor"></a>FilterInvocationInterceptor</h4><p>该Filter 会首先调用AuthenticationManager判断用户是否已登陆认证，如还没认证成功，则重定向到登陆界面。认证成功，则从 Authentication中获取用户的权限。然后从objectDefinitionSource属性获取各种URL资源所对应的权限。最后调用 AccessDecisionManager来判断用户所拥有的权限与当前受保护的URL资源所对应的权限是否相匹配。如果匹配失败，则返回403错误给用户。匹配成功则用户可以访问受保护的URL资源。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"filterInvocationInterceptor"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.intercept.web.FilterSecurityInterceptor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"authenticationManager"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDecisionManager"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"httpRequestAccessDecisionManager"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"objectDefinitionSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON</span><br><span class="line">            PATTERN_TYPE_APACHE_ANT</span><br><span class="line">            /index.jsp=ROLE_ANONYMOUS，ROLE_USER</span><br><span class="line">            /hello.htm=ROLE_ANONYMOUS，ROLE_USER</span><br><span class="line">            /logoff.jsp=ROLE_ANONYMOUS，ROLE_USER</span><br><span class="line">            /switchuser.jsp=ROLE_SUPERVISOR</span><br><span class="line">            /j_acegi_switch_user=ROLE_SUPERVISOR</span><br><span class="line">            /acegilogin.jsp*=ROLE_ANONYMOUS，ROLE_USER</span><br><span class="line">            /**=ROLE_USER</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="SecurityContextHolderAwareRequestFilter"><a href="#SecurityContextHolderAwareRequestFilter" class="headerlink" title="SecurityContextHolderAwareRequestFilter"></a>SecurityContextHolderAwareRequestFilter</h4><p>该Filter 负责通过Decorate Model(装饰模式)，装饰的HttpServletRequest对象。其Wapper是ServletRequest包装类 HttpServletRequestWrapper的子类(SavedRequestAwareWrapper或者 SecurityContextHolderAwareRequestWrapper)，附上获取用户权限信息，request参数，header， Date，headers和cookies的方法。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityContextHolderAwareRequestFilter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.wrapper.SecurityContextHolderAwareRequestFilter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="BasicProcessingFilter"><a href="#BasicProcessingFilter" class="headerlink" title="BasicProcessingFilter"></a>BasicProcessingFilter</h4><p>该Filter负责处理HTTP头的认证信息，如从Spring远程协议(如Hessian和Burlap)或普通的浏览器如IE，Navigator的HTTP头中获取用户信息，将他们转交给通过authenticationManager属性装配的认证管理器。如果认证成功，会将一个Authentication对象放到会话中，否则，如果认证失败，会将控制转交给认证入口点(通过authenticationEntryPoint属性装配)。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"basicProcessingFilter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.basicauth.BasicProcessingFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"authenticationManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationEntryPoint"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"basicProcessingFilterEntryPoint"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"basicProcessingFilterEntryPoint"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.basicauth.BasicProcessingFilterEntryPoint"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realmName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>Contacts Realm<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="RememberMeProcessingFilter"><a href="#RememberMeProcessingFilter" class="headerlink" title="RememberMeProcessingFilter"></a>RememberMeProcessingFilter</h4><p>该Filter 负责在用户登录后在本地机上记录用户cookies信息，免除下次再次登陆。检查AuthenticationManager 中是否已存在Authentication对象，如果不存在则会调用RememberMeServices的aotoLogin方法来从cookies中获取Authentication对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeProcessingFilter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.rememberme.RememberMeProcessingFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span> <span class="attr">ref</span>=<span class="string">"authenticationManager"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeServices"</span> <span class="attr">ref</span>=<span class="string">"rememberMeServices"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="ExceptionTranslationFilter"><a href="#ExceptionTranslationFilter" class="headerlink" title="ExceptionTranslationFilter"></a>ExceptionTranslationFilter</h4><p>该过滤器负责处理各种异常，然后重定向到相应的页面中。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exceptionTranslationFilter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.ExceptionTranslationFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationEntryPoint"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.webapp.AuthenticationProcessingFilterEntryPoint"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginFormUrl"</span> <span class="attr">value</span>=<span class="string">"/login.jsp"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceHttps"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDeniedHandler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.AccessDeniedHandlerImpl"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"errorPage"</span> <span class="attr">value</span>=<span class="string">"/accessDenied.jsp"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="二、拦截器组件"><a href="#二、拦截器组件" class="headerlink" title="二、拦截器组件"></a>二、拦截器组件</h3><h4 id="MethodSecurityInterceptor"><a href="#MethodSecurityInterceptor" class="headerlink" title="MethodSecurityInterceptor"></a>MethodSecurityInterceptor</h4><p>该拦截器实现了<code>org.aopalliance.intercept.MethodInterceptor</code>接口。在方法被调用之前，拦截器会先调用 AuthenticationManager判断用户身份是否已验证，然后从objectDefinitionSource中获取方法所应用的权限，再调用AccessDecisionManager来匹配用户权限和方法对应的权限。如果用户没有足够权限调用当前方法，则抛出 AccessDeniedException是方法不能被调用。调用runAsManager，使在调用方法前动态改变authentication中获取用户权限。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityInterceptor"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validateConfigAttributes"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"authenticationManager"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessDecisionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"accessDecisionManager"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"runAsManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"runAsManager"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"objectDefinitionSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            sample.contact.ContactManager.create=ROLE_USER</span><br><span class="line">            sample.contact.ContactManager.getAllRecipients=ROLE_ADMIN</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a>BeanNameAutoProxyCreator</h4><p>设置AOP代理的最简单方法就是用Spring的BeanNameAutoProxyCreator。在BeanNameAutoProxyCreator中选出你所需要的interceptor，和列出你所需要保护的Bean。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoProxyCreator"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyTargetClass"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">idref</span> <span class="attr">local</span>=<span class="string">"securityInterceptor"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanNames"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"userManager"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"roleManager"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"rescManager"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="三、其他组件"><a href="#三、其他组件" class="headerlink" title="三、其他组件"></a>三、其他组件</h3><h4 id="AccessDecisionManager"><a href="#AccessDecisionManager" class="headerlink" title="AccessDecisionManager"></a>AccessDecisionManager</h4><p>AccessDecisionManager 接口有decide()和support()方法。decide()方法是进行决策是否批准通过，如果没有抛出 AccessDeniedException则为允许访问资源，否则拒绝访问。support()方法是根据配置属性和受保护资源的类来判断是否需要对该资源作出决策判断。<br>AccessDecisionManager有三个实现类，功能各不相同： </p>
<ul>
<li><code>AffirmativeBased</code>：当至少有一个Voter投允许票才通过</li>
<li><code>UnanimousBased</code>：没有Voter投反对票时才通过</li>
<li><code>ConsensusBased</code>：当所有Voter都投允许票时才通过 </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accessDecisionManager"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.vote.UnanimousBased"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"allowIfAllAbstainDecisions"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"decisionVoters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"roleVoter"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"roleVoter"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.vote.RoleVoter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h4><p>AuthenticationManager的其中一个实现是ProviderManager，它负责把身份验证的工作委托给一个或多个Provider(认证提供者)。 </p>
<p>Provider 都是实现AuthenticationProvider接口，该接口有两个方法authenticate()和support()。 authenticate()方法会尝试验证用户身份，若验证成功则返回一个Authentication对象，否则抛出一个 AuthenticationException。 </p>
<p>support()方法会评估当前Authentication对象是否适合这个Provider来进行进一步的处理，而不是指已经通过。 </p>
<p>Provir有多个实现。例如daoAuthenticationProvider，anonymousAuthenticationProvider，rememberMeAuthenticationProvider。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationManager"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.providers.ProviderManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"providers"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"daoAuthenticationProvider"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"anonymousAuthenticationProvider"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"rememberMeAuthenticationProvider"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>daoAuthenticationProvider负责提供用户信息，包括用户名和密码。其中取用户名密码的工作就交给userDetailsService来做。通过userCache来缓存用户信息，减少查询数据库次数。用passwordEncoder 来使用加密密码。userDetailsService的接口实现有jdbcDaoImpl和inMemoryDaoImpl。jdbcDaoImpl通过数据库获取用户名和密码，而inMemoryDaoImpl则只是通过xml定义的方式来获取。<br>userCache的接口实现有EhCacheBasedUserCache和NullUserCache。NullUserCache实际上就是不进行缓存。EhCacheBasedUserCache是基于ehcache的开源缓存项目来实现的。<br>passwordEncoder是使用加密器对用户输入的明文进行加密。Acegi提供了三种加密器： </p>
<ul>
<li><code>PlaintextPasswordEncoder</code>：默认，不加密，返回明文</li>
<li><code>ShaPasswordEncoder</code>：哈希算法(SHA)加密</li>
<li><code>MD5PasswordEncoder</code>：消息摘要(MD5)加密</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"daoAuthenticationProvider"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.providers.dao.DaoAuthenticationProvider"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDetailsService"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"jdbcDaoImpl"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userCache"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"userCache"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordEncoder"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"passwordEncoder"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcDaoImpl"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.userdetails.jdbc.JdbcDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"dataSource"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userCache"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.providers.dao.cache.EhCacheBasedUserCache"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"userCacheBackend"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"passwordEncoder"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.providers.encoding.Md5PasswordEncoder"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userCacheBackend"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>userCache<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.ehcache.EhCacheManagerFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>anonymousAuthenticationProvider负责匿名用户的AnonymousAuthenticationToken的进一步处理：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anonymousAuthenticationProvider"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.providers.anonymous.AnonymousAuthenticationProvider"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>foobar<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>rememberMeAuthenticationProvider负责Cookies记忆用户RememberMeAuthenticationToken的进一步处理：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeAuthenticationProvider"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.providers.rememberme.RememberMeAuthenticationProvider"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>springRocks<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="RememberMeServices"><a href="#RememberMeServices" class="headerlink" title="RememberMeServices"></a>RememberMeServices</h4><p>rememberMeServices 负责通过以cookie的形式保存先前的用户登录信息。在Authentication对象不存在时， rememberMeProcessingFilter会调用rememberMeServices的autoLogin()方法，尝试在cookies 中获取用户登录信息，如果存在则并返回Authentication对象。在每次用户登录时，如果设置了RememberMe功能，在验证用户身份成功后，则会调用loginSuccess()方法记录用信息在cookies中，否则调用loginFail()方法清楚cookie。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeServices"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDetailsService"</span> <span class="attr">ref</span>=<span class="string">"userDetailsService"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">"changeThis"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="RunAsManager"><a href="#RunAsManager" class="headerlink" title="RunAsManager"></a>RunAsManager</h4><p>RunAsmanager提供了动态替换ContextHolder中Ahthentication对象的功能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runAsManager"</span> <span class="attr">class</span>=<span class="string">"org.acegisecurity.runas.RunAsManagerImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"key"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>my_run_as_password<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Acegi</tag>
        <tag>应用安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Acegi源码解读——FilterToBeanProxy</title>
    <url>/2011/04/27/acegi-yuan-ma-jie-du-filtertobeanproxy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>　　这个类最早是在基于Spring的安全框架<strong>Acegi</strong>中提出来的，一个非常不错的创意性的代理类：将<strong>Servlet Filter</strong>代理成Spring容器中的Bean，这样可以让<strong>Filter</strong>也能享受到Spring容器的依赖注入。</p>
<a id="more"></a>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>　　我们通常在配置过滤器（比如编码设置，比如XSS过滤等）时，都是在 <strong>web.xml</strong> 中通过<code>&lt;filter&gt;</code>节点来完成，这个是基于Tomcat与J2EE规范的，并不在Spring容器的管理范围内。如果我想要在<code>Filter</code>的执行过程中利用到Spring容器里面依赖管理的话该怎么处理呢？比如，我们想要在<code>Filter</code>中获取某个<strong>SpringBean</strong>该怎么办呢？其方法之一就是通过<code>WebApplicationContextUtils</code>的工具方法来获取到<code>ApplicationContext</code>，再通过<code>ApplicationContext</code>来获取相应的<strong>SpringBean</strong>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = WebApplicationContextUtils.getRequiredWebApplicationContext(filterConfig.getServletContext());</span><br><span class="line">MyBean myBean = applicationContext.getBean(<span class="string">"myBean"</span>, MyBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　这个过程虽然能达到我们获取容器组件的目标，但如果我们所依赖的组件较多，同时还想要其它有关Spring容器的功能时会比较繁琐。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>　　    <code>FilterToBeanProxy</code>是<strong>Acegi</strong>（现在已经成为SpringSecurity框架的一部分）专门为了解决这类问题，它在内部维护了一个<code>delegate</code>对象，并将<code>Filter</code>的操作都代理到<code>delegate</code>上，而这个对象<code>delegate</code>是<strong>Spring</strong>容器中的组件，这样一来，既能够满足我们<code>Filter</code>的功能，也能利用到<strong>Spring</strong>容器带来的增强。</p>
<p>　　它的使用方法跟普通的<code>Filter</code>一样，是在<code>web.xml</code>配置<code>FilterToBeanProxy</code>，只不过它的<code>filter-name</code>是有特殊含义的，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Acegi Filter Chain Proxy<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.acegisecurity.util.FilterToBeanProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.acegisecurity.util.FilterChainProxy<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　它的特殊性就在于，这个<code>Filter</code>最终所有的操作都是代理到<strong>FilterChainProxy</strong>类型的SpringBean上面去的。 </p>
<h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p>　　我们来看看它的源码（省略非关注点代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterToBeanProxy</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Filter delegate;</span><br><span class="line">    <span class="keyword">private</span> FilterConfig filterConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> servletContainerManaged = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判定初始化策略，如果是 lazy 则是在第一次请求过滤的时候执行初始化，而非容器启动</span></span><br><span class="line">        String strategy = filterConfig.getInitParameter(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((strategy != <span class="keyword">null</span>) &amp;&amp; strategy.toLowerCase().equals(<span class="string">"lazy"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doInit</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="comment">// already initialized, so don't re-initialize</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找 targetBean 属性，如果配置过了的话</span></span><br><span class="line">        String targetBean = filterConfig.getInitParameter(<span class="string">"targetBean"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(targetBean)) &#123;</span><br><span class="line">            targetBean = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定生命周期，这个是为后面决定是否需要初始化做准备的，如果是由 servlet 容器来管理的话，才需要执行 init</span></span><br><span class="line">        String lifecycle = filterConfig.getInitParameter(<span class="string">"lifecycle"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"servlet-container-managed"</span>.equals(lifecycle)) &#123;</span><br><span class="line">            servletContainerManaged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ApplicationContext ctx = <span class="keyword">this</span>.getContext(filterConfig);</span><br><span class="line"></span><br><span class="line">        String beanName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了 targetBean 而且 Spring 容器中也存在这个名称的 bean 的话，就直接用这个名称</span></span><br><span class="line">        <span class="keyword">if</span> ((targetBean != <span class="keyword">null</span>) &amp;&amp; ctx.containsBean(targetBean)) &#123;</span><br><span class="line">            beanName = targetBean;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"targetBean '"</span> + targetBean + <span class="string">"' not found in context"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则的话获取目标的 class，并根据 class 从容器中获取 SpringBean 定义，如果存在的话就获取第一个该类型的 Bean Name</span></span><br><span class="line">            String targetClassString = filterConfig.getInitParameter(<span class="string">"targetClass"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((targetClassString == <span class="keyword">null</span>) || <span class="string">""</span>.equals(targetClassString)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"targetClass or targetBean must be specified"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class targetClass;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetClass = Thread.currentThread().getContextClassLoader().loadClass(targetClassString);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Class of type "</span> + targetClassString + <span class="string">" not found in classloader"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(ctx, targetClass, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (beans.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Bean context must contain at least one bean of type "</span> + targetClassString);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            beanName = (String) beans.keySet().iterator().next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 beanName 从容器中获取组件</span></span><br><span class="line">        Object object = ctx.getBean(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个组件一定要同时是一个常规的 Filter ，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Filter)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Bean '"</span> + beanName + <span class="string">"' does not implement javax.servlet.Filter"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将找到的组件赋值给 delegate</span></span><br><span class="line">        delegate = (Filter) object;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (servletContainerManaged) &#123;</span><br><span class="line">            delegate.init(filterConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set initialized to true at the end of the synchronized method, so</span></span><br><span class="line">        <span class="comment">// that invocations of doFilter() before this method has completed will not</span></span><br><span class="line">        <span class="comment">// cause NullPointerException</span></span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allows test cases to override where application context obtained from.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterConfig which can be used to find the &lt;code&gt;ServletContext&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the Spring application context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ApplicationContext <span class="title">getContext</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WebApplicationContextUtils.getRequiredWebApplicationContext(filterConfig.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　可以看到，在 <code>doInit</code>的时候就是根据配置查找对应的Spring容器组件的过程，步骤如下：</p>
<ol>
<li>判定初始化策略，如果是 lazy 则是在第一次请求过滤的时候执行初始化，而非容器启动时；</li>
<li>查找<code>targetBean</code>属性，如果存在，则 <code>beanName</code>就是该配置值；</li>
<li>检查<code>lifecycle</code>配置，如果是<code>servlet-container-managed</code>则标记该组件是一个<strong>Servlet管控</strong>的组件。</li>
<li>如果<code>targetBean</code>忏悔存在，但是Spring容器中没有这个bean，则直接抛出异常。</li>
<li>查找<code>targetClass</code>属性，如果不存在则报错（该属性和 <code>targetBean</code>必须选配一个），如果存在则在Spring容器中查找该类型的组件。<ul>
<li>如果找到了，则<code>beanName</code>为该类型第一个组件的<code>beanName</code>；</li>
<li>如果没找到，则抛出异常；</li>
</ul>
</li>
<li>判定找到的组件是否是一个<code>Servlet Filter</code>，如果不是则抛出异常；</li>
<li>如果是<strong>Servlet管控</strong>的组件，则调用组件的<code>init</code>方法。</li>
</ol>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>　　执行过程就比较简单了，就是将<code>doFilter</code> 方法代理给Spring组件，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// 判定初始化策略，如果是 lazy 则是在第一次请求过滤的时候执行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        doInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理到 spring 组件上</span></span><br><span class="line">    delegate.doFilter(request, response, chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Acegi</tag>
        <tag>Spring</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller 层的职责</title>
    <url>/2017/11/07/controller-ceng-de-zhi-ze/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>controller 层的主要职责：<strong>是对用户的输入进行校验、组织、重组、转换等，之后调用 service 层或者 repository 层对业务数据进行处理，同时对 service/repository 层的输出进行包装，不应该逾越其职责范围进行业务的处理或者数据层的读写</strong></p>
<a id="more"></a>
<p>典型的 controller 代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"获取首页数据"</span>, notes = <span class="string">"获取首页数据"</span>)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.OK)</span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseData <span class="title">index</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    validParams(request);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包装并转换参数</span></span><br><span class="line">    BizData data = extractParam(request);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用服务 A</span></span><br><span class="line">    Data data1 = serviceA.call(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用服务 B</span></span><br><span class="line">    Data data2 = serviceB.call(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包装返回结果</span></span><br><span class="line">    Data result = wrap(data1, data2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"创建Banner数据"</span>, notes = <span class="string">"创建Banner数据"</span>)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Banner <span class="title">create</span><span class="params">(@ApiParam(value = <span class="string">"Banner信息"</span>)</span> @RequestBody Banner banner) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    validBanner(banner);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用服务，并（包装）返回结果</span></span><br><span class="line">    <span class="keyword">return</span> bannerRepository.save(banner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
        <tag>规范与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Dom4j读写XML简介</title>
    <url>/2008/07/09/dom4j-du-xie-xml-jian-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要使用dom4j读写XML文档，需要先下载dom4j包,dom4j官方网站在 <a href="http://www.dom4j.org/" target="_blank" rel="noopener">http://www.dom4j.org/</a><br>目前最新dom4j包下载地址：<a href="http://nchc.dl.sourceforge.net/sourceforge/dom4j/dom4j-1.6.1.zip" target="_blank" rel="noopener">http://nchc.dl.sourceforge.net/sourceforge/dom4j/dom4j-1.6.1.zip</a> 解开后有两个包,仅操作XML文档的话把 <em>dom4j-1.6.1.jar</em> 加入工程就可以了，如果需要使用XPath的话还需要加入包 <em>jaxen-1.1-beta-7.jar</em>。</p>
<a id="more"></a>
<p>以下是相关操作:</p>
<h4 id="一、Document对象相关"><a href="#一、Document对象相关" class="headerlink" title="一、Document对象相关"></a>一、Document对象相关</h4><ol>
<li><p>读取XML文件,获得document对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document   document = reader.read( <span class="keyword">new</span> File( <span class="string">" input.xml "</span> ));</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析XML形式的文本,得到document对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = <span class="string">" &lt;members&gt;&lt;/members&gt; "</span> ;</span><br><span class="line">Document document = DocumentHelper.parseText(text);</span><br></pre></td></tr></table></figure>
</li>
<li><p>主动创建document对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Document document = DocumentHelper.createDocument();</span><br><span class="line">Element root = document.addElement( <span class="string">" members "</span> ); <span class="comment">// 创建根节点</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二、节点相关"><a href="#二、节点相关" class="headerlink" title="二、节点相关"></a>二、节点相关</h4><ol>
<li><p>获取文档的根节点</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element rootElm = document.getRootElement();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>取得某节点的单个子节点</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element memberElm = root.element( <span class="string">" member "</span> ); <span class="comment">// "member"是节点名</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>取得节点的文字</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = memberElm.getText();</span><br></pre></td></tr></table></figure>
<p> 也可以用:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = root.elementText( <span class="string">" name "</span> );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>取得某节点下名为”member”的所有字节点并进行遍历</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List nodes = rootElm.elements( <span class="string">" member "</span> );</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> (Iterator it = nodes.iterator(); it.hasNext();) &#123;</span><br><span class="line">    Element elm = (Element) it.next();</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>对某节点下的所有子节点进行遍历</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator it = root.elementIterator();it.hasNext();) &#123;</span><br><span class="line">    Element element = (Element) it.next();</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>在某节点下添加子节点</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element ageElm = newMemberElm.addElement( <span class="string">" age "</span> );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p>设置节点文字</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ageElm.setText( <span class="string">" 29 "</span> );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="8">
<li><p>删除某节点</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parentElm.remove(childElm); <span class="comment">// childElm是待删除的节点,parentElm是其父节点</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="9">
<li><p>添加一个CDATA节点</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element contentElm = infoElm.addElement( <span class="string">" content "</span> );</span><br><span class="line">contentElm.addCDATA(diary.getContent());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="三、属性相关"><a href="#三、属性相关" class="headerlink" title="三、属性相关"></a>三、属性相关</h4><ol>
<li><p>取得某节点下的某属性</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element root = document.getRootElement();    </span><br><span class="line">Attribute attribute = root.attribute( <span class="string">" size "</span> ); <span class="comment">// 属性名name</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>取得属性的文字</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = attribute.getText();</span><br></pre></td></tr></table></figure>
<p> 也可以用:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text2 = root.element( <span class="string">" name "</span> ).attributeValue( <span class="string">" firstname "</span> );</span><br></pre></td></tr></table></figure>
<p> 这个是取得根节点下name字节点的属性firstname的值.</p>
</li>
<li><p>遍历某节点的所有属性</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element root = document.getRootElement();    </span><br><span class="line"><span class="keyword">for</span> (Iterator it = root.attributeIterator();it.hasNext();) &#123;</span><br><span class="line">    Attribute attribute = (Attribute) it.next();</span><br><span class="line">    String text = attribute.getText();</span><br><span class="line">    System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>设置某节点的属性和文字</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newMemberElm.addAttribute( <span class="string">" name "</span> , <span class="string">" sitinspring "</span> );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>设置属性的文字</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Attribute attribute = root.attribute( <span class="string">" name "</span> );</span><br><span class="line">attribute.setText( <span class="string">" sitinspring "</span> );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>删除某属性</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Attribute attribute = root.attribute( <span class="string">" size "</span> ); <span class="comment">// 属性名name </span></span><br><span class="line">root.remove(attribute);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="四、将文档写入XML文件"><a href="#四、将文档写入XML文件" class="headerlink" title="四、将文档写入XML文件"></a>四、将文档写入XML文件</h4><ol>
<li><p>文档中全为英文,不设置编码,直接写入的形式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter( <span class="keyword">new</span> FileWriter( <span class="string">" output.xml "</span> ));</span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>文档中含有中文,设置编码格式写入的形式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">format.setEncoding( <span class="string">" GBK "</span> );     <span class="comment">// 指定XML编码         </span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter( <span class="keyword">new</span> FileWriter( <span class="string">" output.xml "</span> ),format);</span><br><span class="line"></span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="五、字符串与XML的转换"><a href="#五、字符串与XML的转换" class="headerlink" title="五、字符串与XML的转换"></a>五、字符串与XML的转换</h4><ol>
<li><p>将字符串转化为XML</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = <span class="string">" &lt;members&gt; &lt;member&gt;sitinspring&lt;/member&gt; &lt;/members&gt; "</span> ;</span><br><span class="line">Document document = DocumentHelper.parseText(text);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>将文档或节点的XML转化为字符串</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document   document = reader.read( <span class="keyword">new</span> File( <span class="string">" input.xml "</span> ));            </span><br><span class="line">Element root = document.getRootElement();                </span><br><span class="line">String docXmlText = document.asXML();</span><br><span class="line">String rootXmlText = root.asXML();</span><br><span class="line">Element memberElm = root.element( <span class="string">" member "</span> );</span><br><span class="line">String memberXmlText = memberElm.asXML();</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>开源组件</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>Get All Connected Users</title>
    <url>/2008/10/23/get-all-connected-users/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Sometimes you may be wanna get all users who connected to your server in order to manage them, such as force to kill someone’s session.  When sessionRegistry.getAllPrincipals() methods will get it’s play show, this method could get all the connetced users, although that implementation would prevent simultaneous logins with the same credentials.</p>
<p>Following is the example code to kill all connetced users sission:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] principals = sessionRegistery.getAllPrincipals();</span><br><span class="line"><span class="keyword">for</span>(Object principal : principals) &#123;</span><br><span class="line">    SessionInformations[] sis = sessionRegistery.getAllSessions(principal, <span class="keyword">true</span>);</span><br><span class="line">    sis[<span class="number">0</span>].expireNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Acegi</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>EhCache的使用</title>
    <url>/2008/06/20/ehcache-de-shi-yong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先来说说ehcache，目前的版本为1.2,已经支持集群了。对于ehcache的使用，感觉很容易上手，基本上都是配置。以前在hibernate的时候配置过，所以也不是很陌生。API也挺简单，<code>CacheManager</code> 是主要的缓存管理类，一般一个应用为一个实例，<code>CacheManager.create()</code> 或者使用 <code>new CacheManager()</code>的方式创建。默认的配置文件为 <em>classes/ehcache.xml</em> 文件，也可以指定其它的配置路径。<br><a id="more"></a></p>
<h4 id="常见的-API-示例"><a href="#常见的-API-示例" class="headerlink" title="常见的 API 示例"></a>常见的 API 示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheManager manager = <span class="keyword">new</span> CacheManager(<span class="string">'src/config/other.xml'</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存的创建，采用自动的方式</span></span><br><span class="line"></span><br><span class="line">CacheManager singletonManager = CacheManager.create();</span><br><span class="line">singletonManager.addCache(<span class="string">'testCache'</span>);</span><br><span class="line">Cache test = singletonManager.getCache(<span class="string">'testCache'</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接创建Cache</span></span><br><span class="line"></span><br><span class="line">CacheManager singletonManager = CacheManager.create();</span><br><span class="line">Cache memoryOnlyCache = <span class="keyword">new</span> Cache(<span class="string">'testCache'</span>, <span class="number">5000</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">manager.addCache(memoryOnlyCache);</span><br><span class="line">Cache test = singletonManager.getCache(<span class="string">'testCache'</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除cache</span></span><br><span class="line"></span><br><span class="line">CacheManager singletonManager = CacheManager.create();</span><br><span class="line">singletonManager.removeCache(<span class="string">'sampleCache1'</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用ehcache后，需要关闭</span></span><br><span class="line"></span><br><span class="line">CacheManager.getInstance().shutdown()   </span><br><span class="line"></span><br><span class="line"><span class="comment">// caches 的使用</span></span><br><span class="line"></span><br><span class="line">Cache cache = manager.getCache(<span class="string">'sampleCache1'</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行crud操作</span></span><br><span class="line"></span><br><span class="line">Cache cache = manager.getCache(<span class="string">'sampleCache1'</span>);</span><br><span class="line">Element element = <span class="keyword">new</span> Element(<span class="string">'key1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">cache.put(element);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line"></span><br><span class="line">Cache cache = manager.getCache(<span class="string">'sampleCache1'</span>);</span><br><span class="line">cache.put(<span class="keyword">new</span> Element(<span class="string">'key1'</span>, <span class="string">'value1'</span>);</span><br><span class="line"><span class="comment">//This updates the entry for 'key1'</span></span><br><span class="line">cache.put(<span class="keyword">new</span> Element(<span class="string">'key1'</span>, <span class="string">'value2'</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// get Serializable</span></span><br><span class="line"></span><br><span class="line">Cache cache = manager.getCache(<span class="string">'sampleCache1'</span>);</span><br><span class="line">Element element = cache.get(<span class="string">'key1'</span>);</span><br><span class="line">Serializable value = element.getValue();   </span><br><span class="line"></span><br><span class="line"><span class="comment">// get non serializable</span></span><br><span class="line"></span><br><span class="line">Cache cache = manager.getCache(<span class="string">'sampleCache1'</span>);</span><br><span class="line">Element element = cache.get(<span class="string">'key1'</span>);</span><br><span class="line">Object value = element.getObjectValue();   </span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"></span><br><span class="line">Cache cache = manager.getCache(<span class="string">'sampleCache1'</span>);</span><br><span class="line">Element element = <span class="keyword">new</span> Element(<span class="string">'key1'</span>, <span class="string">'value1'</span></span><br><span class="line">cache.remove(<span class="string">'key1'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h4><p>一个典型的Ecache的配置文件应该如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span></span></span><br><span class="line"><span class="tag">                  /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"Test"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">                       </span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li><code>name</code>：元素名称</li>
<li><code>maxElementsInMemory</code>：设定内存中创建对象数量的最大值；</li>
<li><code>overflowToDisk</code>： 设置当内存中缓存达到 maxInMemory 限制时元素是否可写到磁盘上；</li>
<li><code>eternal</code>：设置元素（译注：内存中对象）是否永久驻留。如果是，将忽略超时限制且元素永不消亡；</li>
<li><code>timeToIdleSeconds</code>：设置某个元素消亡前的停顿时间。也就是在一个元素消亡之前，两次访问时间的最大时间间隔值。这只能在元素不是永久驻留时有效（译注：如果对象永恒不灭，则设置该属性也无用）。如果该值是 0 就意味着元素可以停顿无穷长的时间。</li>
<li><code>timeToLiveSeconds</code>：为元素设置消亡前的生存时间，也就是一个元素从构建到消亡的最大时间间隔值，N秒后消亡。这只能在元素不是永久驻留时有效。</li>
</ul>
]]></content>
      <tags>
        <tag>缓存管理</tag>
        <tag>Ehcache</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to Caffeine</title>
    <url>/2017/04/15/introduction-to-caffeine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>In this article, we’re going to take a look at <a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine</a> — a <strong>high-performance caching library for Java</strong>.</p>
<p>One fundamental difference between a cache and a <em>Map</em> is that a cache evicts stored items.</p>
<p>An <strong>eviction policy decides which objects should be deleted</strong> at any given time. This policy <strong>directly affects the cache’s hit rate</strong> — a crucial characteristic of caching libraries.</p>
<p>Caffeine uses the <em>Window TinyLfu</em> eviction policy, which provides a <strong>near-optimal hit rate</strong>.</p>
<a id="more"></a>
<h3 id="2-Dependency"><a href="#2-Dependency" class="headerlink" title="2 Dependency"></a>2 Dependency</h3><p>We need to add the <em>caffeine</em> dependency to our <em>pom.xml</em>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>You can find the latest version of <em>caffeine</em> <a href="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22com.github.ben-manes.caffeine%22%20AND%20a%3A%22caffeine%22" target="_blank" rel="noopener">on Maven Central</a>.</p>
<h3 id="3-Populating-Cache"><a href="#3-Populating-Cache" class="headerlink" title="3 Populating Cache"></a>3 Populating Cache</h3><p>Let’s focus on Caffeine’s <strong>three strategies for cache population</strong>: manual, synchronous loading, and asynchronous loading.</p>
<p>First, let’s write a class for the types of values that we’ll store in our cache:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> objectCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// standard constructors/getters</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataObject <span class="title">get</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        objectCounter++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataObject(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-Manual-Populating"><a href="#3-1-Manual-Populating" class="headerlink" title="3.1 Manual Populating"></a>3.1 Manual Populating</h4><p>In this strategy, we manually put values into the cache and retrieve them later.</p>
<p>Let’s initialize our cache:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure>
<p>Now, <strong>we can get some value from the cache using the getIfPresent method</strong>. This method will return <em>null</em> if the value is not present in the cache:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String key = <span class="string">"A"</span>;</span><br><span class="line">DataObject dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNull(dataObject);</span><br></pre></td></tr></table></figure>
<p>We can <strong>populate the cache</strong> manually using the <em>put</em> method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache.put(key, dataObject);</span><br><span class="line">dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br></pre></td></tr></table></figure>
<p><strong>We can also get the value using the get method</strong>, which takes a <em>Function</em> along with a key as an argument. This function will be used for providing the fallback value if the key is not present in the cache, which would be inserted in the cache after computation:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataObject = cache</span><br><span class="line">  .get(key, k -&gt; DataObject.get(<span class="string">"Data for A"</span>));</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br><span class="line">assertEquals(<span class="string">"Data for A"</span>, dataObject.getData());</span><br></pre></td></tr></table></figure>
<p>The <em>get</em> method performs the computation atomically. This means that the computation will be made only once — even if several threads ask for the value simultaneously. That’s why <strong>using get is preferable to getIfPresent</strong>.</p>
<p>Sometimes we need to <strong>invalidate some cached values</strong> manually:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache.invalidate(key);</span><br><span class="line">dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNull(dataObject);</span><br></pre></td></tr></table></figure>
<h4 id="3-2-Synchronous-Loading"><a href="#3-2-Synchronous-Loading" class="headerlink" title="3.2 Synchronous Loading"></a>3.2 Synchronous Loading</h4><p>This method of loading the cache takes a <em>Function,</em> which is used for initializing values, similar to the <em>get</em> method of the manual strategy. Let’s see how we can use that.</p>
<p>First of all, we need to initialize our cache:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure>
<p>Now we can retrieve the values using the <em>get</em> method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataObject dataObject = cache.get(key);</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br><span class="line">assertEquals(<span class="string">"Data for "</span> + key, dataObject.getData());</span><br></pre></td></tr></table></figure>
<p>We can also get a set of values using the <em>getAll</em> method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, DataObject&gt; dataObjectMap </span><br><span class="line">  = cache.getAll(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">3</span>, dataObjectMap.size());</span><br></pre></td></tr></table></figure>
<p>Values are retrieved from the underlying back-end initialization <em>Function</em> that was passed to the <em>build</em> method. <strong>This makes it possible to use the cache as the main facade for accessing values.</strong></p>
<h4 id="3-3-Asynchronous-Loading"><a href="#3-3-Asynchronous-Loading" class="headerlink" title="3.3 Asynchronous Loading"></a>3.3 Asynchronous Loading</h4><p>This strategy <strong>works the same as the previous but performs operations asynchronously and returns a CompletableFuture</strong> holding the actual value:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(100)</span><br><span class="line">  .expireAfterWrite(1, TimeUnit.MINUTES)</span><br><span class="line">  .buildAsync(k -&gt; DataObject.get(&quot;Data for &quot; + k));</span><br></pre></td></tr></table></figure>
<p>We can <strong>use the get and getAll methods</strong>, in the same manner, taking into account the fact that they return <em>CompletableFuture</em>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String key = <span class="string">"A"</span>;</span><br><span class="line"> </span><br><span class="line">cache.get(key).thenAccept(dataObject -&gt; &#123;</span><br><span class="line">    assertNotNull(dataObject);</span><br><span class="line">    assertEquals(<span class="string">"Data for "</span> + key, dataObject.getData());</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">cache.getAll(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>))</span><br><span class="line">  .thenAccept(dataObjectMap -&gt; assertEquals(<span class="number">3</span>, dataObjectMap.size()));</span><br></pre></td></tr></table></figure>
<p><em>CompletableFuture</em> has a rich and useful API, which you can read more about <a href="https://www.doleje.com/java-completablefuture" target="_blank" rel="noopener">in this article</a>.</p>
<h3 id="4-Eviction-of-Values"><a href="#4-Eviction-of-Values" class="headerlink" title="4 Eviction of Values"></a>4 Eviction of Values</h3><p>Caffeine has <strong>three strategies for value eviction</strong>: size-based, time-based, and reference-based.</p>
<h4 id="4-1-Size-Based-Eviction"><a href="#4-1-Size-Based-Eviction" class="headerlink" title="4.1 Size-Based Eviction"></a>4.1 Size-Based Eviction</h4><p>This type of eviction assumes that <strong>eviction occurs when the configured size limit of the cache is exceeded</strong>. There are <strong>two ways of getting the size</strong> — counting objects in the cache, or getting their weights.</p>
<p>Let’s see how we could <strong>count objects in the cache</strong>. When the cache is initialized, its size is equal to zero:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">1</span>)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">0</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure>
<p>When we add a value, the size obviously increases:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure>
<p>We can add the second value to the cache, which leads to the removal of the first value:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache.get(<span class="string">"B"</span>);</span><br><span class="line">cache.cleanUp();</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure>
<p>It is worth mention that we <strong>call the cleanUp method before getting the cache size</strong>. This is because the cache eviction is executed asynchronously, and this method <strong>helps to await the completion of the eviction</strong>.</p>
<p>We can also <strong>pass a weigher</strong> <strong><em>Function</em></strong> to get the size of the cache:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumWeight(<span class="number">10</span>)</span><br><span class="line">  .weigher((k,v) -&gt; <span class="number">5</span>)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">0</span>, cache.estimatedSize());</span><br><span class="line"> </span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br><span class="line"> </span><br><span class="line">cache.get(<span class="string">"B"</span>);</span><br><span class="line">assertEquals(<span class="number">2</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure>
<p>The values are removed from the cache when the weight is over 10:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache.get(<span class="string">"C"</span>);</span><br><span class="line">cache.cleanUp();</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">2</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure>
<h4 id="4-2-Time-Based-Eviction"><a href="#4-2-Time-Based-Eviction" class="headerlink" title="4.2 Time-Based Eviction"></a>4.2 Time-Based Eviction</h4><p>This eviction strategy is <strong>based on the expiration time of the entry</strong> and has three types:</p>
<ul>
<li><strong>Expire after access</strong> — entry is expired after period is passed since the last read or write occurs</li>
<li><strong>Expire after write</strong> — entry is expired after period is passed since the last write occurs</li>
<li><strong>Custom policy</strong> — an expiration time is calculated for each entry individually by the <em>Expiry</em> implementation</li>
</ul>
<p>Let’s configure the expire-after-access strategy using the <em>expireAfterAccess</em> method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure>
<p>To configure expire-after-write strategy, we use the <em>expireAfterWrite</em> method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .weakKeys()</span><br><span class="line">  .weakValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure>
<p>To initialize a custom policy, we need to implement the <em>Expiry</em> interface:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache = Caffeine.newBuilder().expireAfter(<span class="keyword">new</span> Expiry&lt;String, DataObject&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getData().length() * <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDuration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterRead</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure>
<h4 id="4-3-Reference-Based-Eviction"><a href="#4-3-Reference-Based-Eviction" class="headerlink" title="4.3 Reference-Based Eviction"></a>4.3 Reference-Based Eviction</h4><p>We can configure our cache to allow <strong>garbage-collection of cache keys and/or values</strong>. To do this, we’d configure usage of the <em>WeakRefence</em> for both keys and values, and we can configure the <em>SoftReference</em> for garbage-collection of values only.</p>
<p>The <em>WeakRefence</em> usage allows garbage-collection of objects when there are not any strong references to the object. <em>SoftReference</em> allows objects to be garbage-collected based on the global Least-Recently-Used strategy of the JVM. More details about references in Java can be found <a href="https://www.doleje.com/java-weakhashmap" target="_blank" rel="noopener">here</a>.</p>
<p>We should use <em>Caffeine.weakKeys()</em>, <em>Caffeine.weakValues(),</em> and <em>Caffeine.softValues()</em> to enable each option:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .weakKeys()</span><br><span class="line">  .weakValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .softValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure>
<h3 id="5-Refreshing"><a href="#5-Refreshing" class="headerlink" title="5 Refreshing"></a>5 Refreshing</h3><p>It’s possible to configure the cache to refresh entries after a defined period automatically. Let’s see how to do this using the <em>refreshAfterWrite</em> method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caffeine.newBuilder()</span><br><span class="line">  .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure>
<p>Here we should understand a <strong>difference between expireAfter and refreshAfter</strong>. When the expired entry is requested, an execution blocks until the new value would have been calculated by the build <em>Function</em>.</p>
<p>But if the entry is eligible for the refreshing, then the cache would return an old value and <strong>asynchronously reload the value</strong>.</p>
<h3 id="6-Statistics"><a href="#6-Statistics" class="headerlink" title="6 Statistics"></a>6 Statistics</h3><p>Caffeine has a means of <strong>recording statistics about cache usage</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .recordStats()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.stats().hitCount());</span><br><span class="line">assertEquals(<span class="number">1</span>, cache.stats().missCount());</span><br></pre></td></tr></table></figure>
<p>We may also pass into <em>recordStats</em> supplier, which creates an implementation of the <em>StatsCounter.</em> This object will be pushed with every statistics-related change.</p>
<h3 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h3><p>In this article, we got acquainted with the Caffeine caching library for Java. We saw how to configure and populate a cache, as well as how to choose an appropriate expiration or refresh policy according to our needs.</p>
]]></content>
      <tags>
        <tag>缓存</tag>
        <tag>Caffine</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]How to choose the number of topics/partitions in a Kafka cluster?</title>
    <url>/2015/03/15/how-to-choose-the-number-of-topics-partitions-in-a-kafka-cluster/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Note: The blog post Apache Kafka Supports 200K Partitions Per Cluster contains important updates that have happened in Kafka as of version 2.0.</p>
<p>This is a common question asked by many Kafka users. The goal of this post is to explain a few important determining factors and provide a few simple formulas.</p>
<p>More Partitions Lead to Higher Throughput<br>The first thing to understand is that a topic partition is the unit of parallelism in Kafka. On both the producer and the broker side, writes to different partitions can be done fully in parallel. So expensive operations such as compression can utilize more hardware resources. On the consumer side, Kafka always gives a single partition’s data to one consumer thread. Thus, the degree of parallelism in the consumer (within a consumer group) is bounded by the number of partitions being consumed. Therefore, in general, the more partitions there are in a Kafka cluster, the higher the throughput one can achieve.<br><a id="more"></a></p>
<p>A rough formula for picking the number of partitions is based on throughput. You measure the throughout that you can achieve on a single partition for production (call it p) and consumption (call it c). Let’s say your target throughput is t. Then you need to have at least max(t/p, t/c) partitions. The per-partition throughput that one can achieve on the producer depends on configurations such as the batching size, compression codec, type of acknowledgement, replication factor, etc. However, in general, one can produce at 10s of MB/sec on just a single partition as shown in this benchmark. The consumer throughput is often application dependent since it corresponds to how fast the consumer logic can process each message. So, you really need to measure it.</p>
<p>Although it’s possible to increase the number of partitions over time, one has to be careful if messages are produced with keys. When publishing a keyed message, Kafka deterministically maps the message to a partition based on the hash of the key. This provides a guarantee that messages with the same key are always routed to the same partition. This guarantee can be important for certain applications since messages within a partition are always delivered in order to the consumer. If the number of partitions changes, such a guarantee may no longer hold. To avoid this situation, a common practice is to over-partition a bit. Basically, you determine the number of partitions based on a future target throughput, say for one or two years later. Initially, you can just have a small Kafka cluster based on your current throughput. Over time, you can add more brokers to the cluster and proportionally move a subset of the existing partitions to the new brokers (which can be done online). This way, you can keep up with the throughput growth without breaking the semantics in the application when keys are used.</p>
<p>In addition to throughput, there are a few other factors that are worth considering when choosing the number of partitions. As you will see, in some cases, having too many partitions may also have negative impact.</p>
<p>More Partitions Requires More Open File Handles<br>Each partition maps to a directory in the file system in the broker. Within that log directory, there will be two files (one for the index and another for the actual data) per log segment. Currently, in Kafka, each broker opens a file handle of both the index and the data file of every log segment. So, the more partitions, the higher that one needs to configure the open file handle limit in the underlying operating system. This is mostly just a configuration issue. We have seen production Kafka clusters running with more than 30 thousand open file handles per broker.</p>
<p>More Partitions May Increase Unavailability<br>Kafka supports intra-cluster replication, which provides higher availability and durability. A partition can have multiple replicas, each stored on a different broker. One of the replicas is designated as the leader and the rest of the replicas are followers. Internally, Kafka manages all those replicas automatically and makes sure that they are kept in sync. Both the producer and the consumer requests to a partition are served on the leader replica. When a broker fails, partitions with a leader on that broker become temporarily unavailable. Kafka will automatically move the leader of those unavailable partitions to some other replicas to continue serving the client requests. This process is done by one of the Kafka brokers designated as the controller. It involves reading and writing some metadata for each affected partition in ZooKeeper. Currently, operations to ZooKeeper are done serially in the controller.</p>
<p>In the common case when a broker is shut down cleanly, the controller will proactively move the leaders off the shutting down broker one at a time. The moving of a single leader takes only a few milliseconds. So, from the clients perspective, there is only a small window of unavailability during a clean broker shutdown.</p>
<p>However, when a broker is shut down uncleanly (e.g., kill -9), the observed unavailability could be proportional to the number of partitions. Suppose that a broker has a total of 2000 partitions, each with 2 replicas. Roughly, this broker will be the leader for about 1000 partitions. When this broker fails uncleanly, all those 1000 partitions become unavailable at exactly the same time. Suppose that it takes 5 ms to elect a new leader for a single partition. It will take up to 5 seconds to elect the new leader for all 1000 partitions. So, for some partitions, their observed unavailability can be 5 seconds plus the time taken to detect the failure.</p>
<p>If one is unlucky, the failed broker may be the controller. In this case, the process of electing the new leaders won’t start until the controller fails over to a new broker. The controller failover happens automatically, but requires the new controller to read some metadata for every partition from ZooKeeper during initialization. For example, if there are 10,000 partitions in the Kafka cluster and initializing the metadata from ZooKeeper takes 2 ms per partition, this can add 20 more seconds to the unavailability window.</p>
<p>In general, unclean failures are rare. However, if one cares about availability in those rare cases, it’s probably better to limit the number of partitions per broker to two to four thousand and the total number of partitions in the cluster to low tens of thousand.</p>
<p>More Partitions May Increase End-to-end Latency<br>The end-to-end latency in Kafka is defined by the time from when a message is published by the producer to when the message is read by the consumer. Kafka only exposes a message to a consumer after it has been committed, i.e., when the message is replicated to all the in-sync replicas. So, the time to commit a message can be a significant portion of the end-to-end latency. By default, a Kafka broker only uses a single thread to replicate data from another broker, for all partitions that share replicas between the two brokers. Our experiments show that replicating 1000 partitions from one broker to another can add about 20 ms latency, which implies that the end-to-end latency is at least 20 ms. This can be too high for some real-time applications.</p>
<p>Note that this issue is alleviated on a larger cluster. For example, suppose that there are 1000 partition leaders on a broker and there are 10 other brokers in the same Kafka cluster. Each of the remaining 10 brokers only needs to fetch 100 partitions from the first broker on average. Therefore, the added latency due to committing a message will be just a few ms, instead of tens of ms.</p>
<p>As a rule of thumb, if you care about latency, it’s probably a good idea to limit the number of partitions per broker to 100 x b x r, where b is the number of brokers in a Kafka cluster and r is the replication factor.</p>
<p>More Partitions May Require More Memory In the Client<br>In the most recent 0.8.2 release which we ship with the Confluent Platform 1.0, we have developed a more efficient Java producer. One of the nice features of the new producer is that it allows users to set an upper bound on the amount of memory used for buffering incoming messages. Internally, the producer buffers messages per partition. After enough data has been accumulated or enough time has passed, the accumulated messages are removed from the buffer and sent to the broker.</p>
<p>If one increases the number of partitions, message will be accumulated in more partitions in the producer. The aggregate amount of memory used may now exceed the configured memory limit. When this happens, the producer has to either block or drop any new message, neither of which is ideal. To prevent this from happening, one will need to reconfigure the producer with a larger memory size.</p>
<p>As a rule of thumb, to achieve good throughput, one should allocate at least a few tens of KB per partition being produced in the producer and adjust the total amount of memory if the number of partitions increases significantly.</p>
<p>A similar issue exists in the consumer as well. The consumer fetches a batch of messages per partition. The more partitions that a consumer consumes, the more memory it needs. However, this is typically only an issue for consumers that are not real time.</p>
<p>Summary<br>In general, more partitions in a Kafka cluster leads to higher throughput. However, one does have to be aware of the potential impact of having too many partitions in total or per broker on things like availability and latency. In the future, we do plan to improve some of those limitations to make Kafka more scalable in terms of the number of partitions.</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK/bin下工具列表说明</title>
    <url>/2017/04/17/jdk-gong-ju-shuo-ming/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>appletviewer.exe</strong></p>
<blockquote>
<p>一种执行HTML文件上的Java小程序类的Java浏览器</p>
</blockquote>
<p><strong>apt.exe</strong></p>
<blockquote>
<p>注解处理工具(Annotation Processing Tool), SolarisTM 操作系统和 Linux上用于处理注释的工具</p>
</blockquote>
<p><strong>extcheck.exe</strong></p>
<blockquote>
<p>扩展检测工具，检测目标 jar 文件与当前安装方式扩展jar 文件间的版本冲突</p>
</blockquote>
<a id="more"></a>
<p><strong>HtmlConverter.exe</strong></p>
<blockquote>
<p>Java(TM) 插件 HTML 转换器是一种实用程序，可用于将任一包含小程序的 HTML 页面,转换为使用 Java(TM)插件的格式</p>
</blockquote>
<p><strong>idlj.exe</strong></p>
<blockquote>
<p>IDL转Java编译器(IDL-to-Java Compiler)，用于为指定的IDL文件生成Java绑定，IDL意即接口定义语言(Interface Definition Language)</p>
</blockquote>
<p><strong>jabswitch.exe</strong></p>
<blockquote>
<p>Java访问桥开关(JavaAccess Bridge switch)，用于启用/禁用Java访问桥。Java访问桥内置于Java 7 Update 6及以上版本，主要为Windows系统平台提供一套访问Java应用的API</p>
</blockquote>
<p><strong>jar.exe</strong></p>
<blockquote>
<p>文件管理工具，是个java应用程序，可将多个文件合并为单个JAR归档文件</p>
</blockquote>
<p><strong>jarsigner.exe</strong></p>
<blockquote>
<p>密钥签名工具，为 Java 归档 (JAR) 文件产生签名，并校验已签名的 JAR文件的签名</p>
</blockquote>
<p><strong>java.exe</strong></p>
<blockquote>
<p>运行工具，Java解释器，直接从类文件执行Java应用程序代码</p>
</blockquote>
<p><strong>javac.exe</strong></p>
<blockquote>
<p>编译工具，Java编译器，将Java源代码换成字节代</p>
</blockquote>
<p><strong>javadoc.exe</strong></p>
<blockquote>
<p>文档工具，根据Java源代码及其说明语句生成的HTML文档</p>
</blockquote>
<p><strong>javafxpackager.exe</strong></p>
<blockquote>
<p>JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务</p>
</blockquote>
<p><strong>javah.exe</strong></p>
<blockquote>
<p>头文件工具，用于根据Java类生成C/C++头文件和源文件(主要用于JNI开发领域)</p>
</blockquote>
<p><strong>javap.exe</strong></p>
<blockquote>
<p>Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件</p>
</blockquote>
<p><strong>javapackager.exe</strong></p>
<blockquote>
<p>Java包装器，执行与包装并签署Java和JavaFX应用程序的任务</p>
</blockquote>
<p><strong>java-rmi.exe</strong></p>
<blockquote>
<p>Java远程方法调用(JavaRemote Method Invocation)工具，主要用于在客户机上调用远程服务器上的对象</p>
</blockquote>
<p><strong>javaw.exe</strong></p>
<blockquote>
<p>Java运行工具，用于运行.class字节码文件或.jar文件，但不会显示控制台输出信息，适用于运行图形化程序</p>
</blockquote>
<p><strong>Javaws.exe</strong></p>
<blockquote>
<p>用于启动和控制Web上的java程序。Java Web Start，可从Web下载和运行Java应用程序，下载、安装、运行、更新Java应用程序都非常简单方便</p>
</blockquote>
<p><strong>jcmd.exe</strong></p>
<blockquote>
<p>Java 命令行(JavaCommand)，用于向正在运行的JVM发送诊断命令请求</p>
</blockquote>
<p><strong>jconsole.exe</strong></p>
<blockquote>
<p>图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息</p>
</blockquote>
<p><strong>Jdb.exe</strong></p>
<blockquote>
<p>Java调试工具(Java Debugger)，主要用于对Java应用进行断点调试</p>
</blockquote>
<p><strong>jdeps.exe</strong></p>
<blockquote>
<p>类依赖分析器，显示Java类的包级别或类级别的依赖，接受一个.class文件，一个目录，或者一个jar文件作为输入，默认把结果输出到系统输出（控制台）上 (Java8新特性)</p>
</blockquote>
<p><strong>jhat.exe</strong></p>
<blockquote>
<p>java堆分析工具(Java Heap Analysis Tool)，用于分析Java堆内存中的对象信息</p>
</blockquote>
<p><strong>jinfo.exe</strong></p>
<blockquote>
<p>Java配置信息工具(Java Configuration Information)，打印指定Java进程、核心文件或远程调试服务器的配置信息</p>
</blockquote>
<p><strong>jjs.exe</strong></p>
<blockquote>
<p>Nashorn引擎，接受一些JavaScript源代码为参数，并且执行这些源代码  (Java8新特性)</p>
</blockquote>
<p><strong>jmap.exe</strong></p>
<blockquote>
<p>Java内存映射工具(Java Memory Map)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节</p>
</blockquote>
<p><strong>jmc.exe</strong></p>
<blockquote>
<p>Java任务控制工具(Java Mission Control)，主要用于HotSpot JVM的生产时间监测、分析、诊断</p>
</blockquote>
<p><strong>jps.exe</strong></p>
<blockquote>
<p>JVM进程状态工具(JVM Process Status Tool)，用于显示目标系统上的HotSpotJVM的Java进程信息</p>
</blockquote>
<p><strong>jrunscript.exe</strong></p>
<blockquote>
<p>Java命令行脚本外壳工具(commandline script shell)，用于解释执行javascript、groovy、ruby等脚本语言</p>
</blockquote>
<p><strong>jsadebugd.exe</strong></p>
<blockquote>
<p>Java可用性代理调试守护进程(JavaServiceability Agent Debug Daemon)，主要用于附加到指定的Java进程、核心文件，或充当一个调试服务器</p>
</blockquote>
<p><strong>jstack.exe</strong></p>
<blockquote>
<p>Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息</p>
</blockquote>
<p><strong>jstat.exe</strong></p>
<blockquote>
<p>JVM统计监测工具(JVM Statistics Monitoring Tool)，主要用于监测并显示JVM的性能统计信息</p>
</blockquote>
<p><strong>jstatd.exe</strong></p>
<blockquote>
<p>jstatd(VM jstatd Daemon)工具是一个RMI服务器应用，用于监测HotSpotJVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上</p>
</blockquote>
<p><strong>jvisualvm.exe</strong></p>
<blockquote>
<p>JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息</p>
</blockquote>
<p><strong>keytool.exe</strong></p>
<blockquote>
<p>密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等</p>
</blockquote>
<p><strong>kinit.exe</strong></p>
<blockquote>
<p>主要用于获取或缓存Kerberos协议的票据授权票据</p>
</blockquote>
<p><strong>klist.exe</strong></p>
<blockquote>
<p>允许用户查看本地凭据缓存和密钥表中的条目(用于Kerberos协议)</p>
</blockquote>
<p><strong>ktab.exe</strong></p>
<blockquote>
<p>Kerberos密钥表管理工具，允许用户管理存储于本地密钥表中的主要名称和服务密钥</p>
</blockquote>
<p><strong>native2ascii.exe</strong></p>
<blockquote>
<p>本地编码到ASCII编码的转换器(Native-to-ASCIIConverter)，用于”任意受支持的字符编码”和与之对应的”ASCII编码和(或)Unicode转义”之间的相互转换</p>
</blockquote>
<p><strong>orbd.exe</strong></p>
<blockquote>
<p>对象请求代理守护进程(Object Request Broker Daemon)，它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象</p>
</blockquote>
<p><strong>pack200.exe</strong></p>
<blockquote>
<p>AR文件打包压缩工具，它可以利用Java类特有的结构，对普通JAR文件进行高效压缩，以便于能够更快地进行网络传输</p>
</blockquote>
<p><strong>packager.exe</strong></p>
<blockquote>
<p>这是微软提供的对象包装程序，用于对象安装包</p>
</blockquote>
<p><strong>policytool.exe</strong></p>
<blockquote>
<p>策略工具，用于管理用户策略文件(.java.policy)</p>
</blockquote>
<p><strong>rmic.exe</strong></p>
<blockquote>
<p>Java RMI 编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMG IDL</p>
</blockquote>
<p><strong>rmid.exe</strong></p>
<blockquote>
<p>Java RMI 激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象</p>
</blockquote>
<p><strong>rmiregistry.exe</strong></p>
<blockquote>
<p>Java 远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表</p>
</blockquote>
<p><strong>schemagen.exe</strong></p>
<blockquote>
<p>XML schema生成器，用于生成XMLschema文件</p>
</blockquote>
<p><strong>serialver.exe</strong></p>
<blockquote>
<p>序列版本命令，用于生成并返回serialVersionUID</p>
</blockquote>
<p><strong>servertool.exe</strong></p>
<blockquote>
<p>Java IDL 服务器工具，用于注册、取消注册、启动和终止持久化的服务器</p>
</blockquote>
<p><strong>tnameserv.exe</strong></p>
<blockquote>
<p>Java IDL瞬时命名服务</p>
</blockquote>
<p><strong>unpack200.exe</strong></p>
<blockquote>
<p>JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件</p>
</blockquote>
<p><strong>wsgen.exe</strong></p>
<blockquote>
<p>XML Web Service 2.0的Java API，生成用于JAX-WS Web Service的JAX-WS便携式产物</p>
</blockquote>
<p><strong>wsimport.exe</strong></p>
<blockquote>
<p>XML Web Service 2.0的Java API，主要用于根据服务端发布的wsdl文件生成客户端存根及框架</p>
</blockquote>
<p><strong>xjc.exe</strong></p>
<blockquote>
<p>主要用于根据XML schema文件生成对应的Java类</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix简介</title>
    <url>/2016/03/25/hystrix-jian-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>典型的分布式系统由许多协作在一起的服务组成。</p>
<p>这些服务容易出现故障或延迟响应。如果服务失败，它可能会影响影响性能的其他服务，并可能使应用程序的其他部分无法访问，或者在最坏的情况下会导致整个应用程序崩溃。</p>
<p><strong>当然，有一些解决方案可以帮助提高应用程序的弹性和容错能力 - 其中一个框架就是Hystrix。</strong></p>
<p>Hystrix框架库通过提供容错和延迟容忍来帮助控制服务之间的交互。它通过隔离故障服务和停止故障的级联效应来提高系统的整体弹性。</p>
<p>在本系列文章中，我们将首先了解Hystrix在服务或系统出现故障时如何解决问题以及Hystrix在这些情况下可以完成的任务。<br><a id="more"></a></p>
<h2 id="2-简单的例子"><a href="#2-简单的例子" class="headerlink" title="2. 简单的例子"></a>2. 简单的例子</h2><p>Hystrix提供故障和延迟容忍的方式是隔离和包装对远程服务的调用。</p>
<p>在这个简单的例子中，我们在<em>HystrixCommand</em>的<em>run()</em>方法中包装一个调用<em>：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandHelloWorld</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    CommandHelloWorld(String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们按如下方式执行调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenInputBobAndDefaultSettings_whenCommandExecuted_thenReturnHelloBob</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assertThat(<span class="keyword">new</span> CommandHelloWorld(<span class="string">"Bob"</span>).execute(), equalTo(<span class="string">"Hello Bob!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Maven设置"><a href="#3-Maven设置" class="headerlink" title="3. Maven设置"></a>3. Maven设置</h2><p>要在Maven项目中使用Hystrix，我们需要在项目<em>pom.xml中使用</em> Netflix的<em>hystrix-core</em>和<em>rxjava-core</em>依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最新版本总是可以在<a href="https://search.maven.org/classic/#search%7Cga%7C1%7Ca%3A%22hystrix-core%22" target="_blank" rel="noopener">这里</a>找到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.rxjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rxjava-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.20.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在<a href="https://search.maven.org/classic/#search%7Cga%7C1%7Ca%3A%22rxjava-core%22" target="_blank" rel="noopener">此处</a>找到此库的最新版本。</p>
<h2 id="4-设置远程服务"><a href="#4-设置远程服务" class="headerlink" title="4. 设置远程服务"></a>4. 设置远程服务</h2><p>让我们从模拟现实世界的例子开始。</p>
<p><strong>在下面的示例中</strong>，<em>RemoteServiceTestSimulator</em>类表示远程服务器上的服务。它有一种方法，在给定的时间段后响应消息。我们可以想象，这种等待模拟了远程系统中耗时的过程，导致对呼叫服务的响应延迟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteServiceTestSimulator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> wait;</span><br><span class="line"> </span><br><span class="line">    RemoteServiceTestSimulator(<span class="keyword">long</span> wait) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait = wait;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(wait);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这是我们</strong>调用<em>RemoteServiceTestSimulator的**</em>示例客户端**。</p>
<p>对服务的调用是隔离的，并包装在<em>HystrixCommand</em>的<em>run()</em>方法中<em>。</em>它的这种包装提供了我们上面提到的弹性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteServiceTestCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> RemoteServiceTestSimulator remoteService;</span><br><span class="line"> </span><br><span class="line">    RemoteServiceTestCommand(Setter config, RemoteServiceTestSimulator remoteService) &#123;</span><br><span class="line">        <span class="keyword">super</span>(config);</span><br><span class="line">        <span class="keyword">this</span>.remoteService = remoteService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remoteService.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在<em>RemoteServiceTestCommand</em>对象的实例上调用<em>execute()</em>方法来执行调用。</p>
<p>以下测试演示了如何完成此操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenSvcTimeoutOf100AndDefaultSettings_whenRemoteSvcExecuted_thenReturnSuccess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    HystrixCommand.Setter config = HystrixCommand</span><br><span class="line">      .Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RemoteServiceGroup2"</span>));</span><br><span class="line">     </span><br><span class="line">    assertThat(<span class="keyword">new</span> RemoteServiceTestCommand(config, <span class="keyword">new</span> RemoteServiceTestSimulator(<span class="number">100</span>)).execute(),</span><br><span class="line">      equalTo(<span class="string">"Success"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们已经了解了如何在<em>HystrixCommand</em>对象中包装远程服务调用。在下面的部分中，我们将看看如何处理远程服务开始恶化的情况。</p>
<h2 id="5-使用远程服务和防御性编程"><a href="#5-使用远程服务和防御性编程" class="headerlink" title="5. 使用远程服务和防御性编程"></a>5. 使用远程服务和防御性编程</h2><h3 id="5-1-具有超时的防御性编程"><a href="#5-1-具有超时的防御性编程" class="headerlink" title="5.1 具有超时的防御性编程"></a>5.1 具有超时的防御性编程</h3><p>通常的编程习惯是为远程服务的呼叫设置超时。</p>
<p>让我们首先看看如何在<em>HystrixCommand</em>上设置超时以及它如何通过短路来帮助：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenSvcTimeoutOf5000AndExecTimeoutOf10000_whenRemoteSvcExecuted_thenReturnSuccess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    HystrixCommand.Setter config = HystrixCommand</span><br><span class="line">      .Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RemoteServiceGroupTest4"</span>));</span><br><span class="line"> </span><br><span class="line">    HystrixCommandProperties.Setter commandProperties = HystrixCommandProperties.Setter();</span><br><span class="line">    commandProperties.withExecutionTimeoutInMilliseconds(<span class="number">10_000</span>);</span><br><span class="line">    config.andCommandPropertiesDefaults(commandProperties);</span><br><span class="line"> </span><br><span class="line">    assertThat(<span class="keyword">new</span> RemoteServiceTestCommand(config, <span class="keyword">new</span> RemoteServiceTestSimulator(<span class="number">500</span>)).execute(),</span><br><span class="line">      equalTo(<span class="string">"Success"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的测试中，我们通过将超时设置为500毫秒来延迟服务的响应。我们还将<em>HystrixCommand</em>的执行超时设置为10,000 ms，从而为远程服务提供足够的响应时间。</p>
<p>现在让我们看看当执行超时小于服务超时调用时会发生什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = HystrixRuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">givenSvcTimeoutOf15000AndExecTimeoutOf5000_whenRemoteSvcExecuted_thenExpectHre</span>()</span></span><br><span class="line"><span class="class">  <span class="title">throws</span> <span class="title">InterruptedException</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    HystrixCommand.Setter config = HystrixCommand</span><br><span class="line">      .Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RemoteServiceGroupTest5"</span>));</span><br><span class="line"> </span><br><span class="line">    HystrixCommandProperties.Setter commandProperties = HystrixCommandProperties.Setter();</span><br><span class="line">    commandProperties.withExecutionTimeoutInMilliseconds(<span class="number">5_000</span>);</span><br><span class="line">    config.andCommandPropertiesDefaults(commandProperties);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> RemoteServiceTestCommand(config, <span class="keyword">new</span> RemoteServiceTestSimulator(<span class="number">15_000</span>)).execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意我们如何降低条形并将执行超时设置为5,000毫秒。</p>
<p>我们期望服务在5,000毫秒内响应，而我们已将服务设置为在15,000毫秒后响应。如果您在执行测试时发现，测试将在5,000毫秒后退出，而不是等待15,000毫秒，并将抛出<em>HystrixRuntimeException</em>。</p>
<p><strong>这演示了Hystrix如何等待超过响应的配置超时。这有助于使受Hystrix保护的系统更具响应性。</strong></p>
<p>在下面的部分中，我们将研究设置线程池大小，以防止线程耗尽，我们将讨论它的好处。</p>
<h3 id="5-2-有限线程池的防御性编程"><a href="#5-2-有限线程池的防御性编程" class="headerlink" title="**5.2 有限线程池的防御性编程"></a>**5.2 有限线程池的防御性编程</h3><p>设置服务调用的超时并不能解决与远程服务相关的所有问题。</p>
<p><strong>当远程服务开始响应缓慢时，典型应用程序将继续调用该远程服务。</strong></p>
<p>应用程序不知道远程服务是否健康，并且每次请求进入时都会生成新线程。这将导致已经在使用的服务器上的线程被使用。</p>
<p>我们不希望这种情况发生，因为我们需要这些线程用于在我们的服务器上运行的其他远程调用或进程，并且我们还希望避免CPU利用率飙升。</p>
<p>让我们看看如何在<em>HystrixCommand中</em>设置线程池大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> givenSvcTimeoutOf500AndExecTimeoutOf10000AndThreadPool_whenRemoteSvcExecuted</span><br><span class="line">  _thenReturnSuccess() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> </span><br><span class="line">    HystrixCommand.Setter config = HystrixCommand</span><br><span class="line">      .Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RemoteServiceGroupThreadPool"</span>));</span><br><span class="line"> </span><br><span class="line">    HystrixCommandProperties.Setter commandProperties = HystrixCommandProperties.Setter();</span><br><span class="line">    commandProperties.withExecutionTimeoutInMilliseconds(<span class="number">10_000</span>);</span><br><span class="line">    config.andCommandPropertiesDefaults(commandProperties);</span><br><span class="line">    config.andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">      .withMaxQueueSize(<span class="number">10</span>)</span><br><span class="line">      .withCoreSize(<span class="number">3</span>)</span><br><span class="line">      .withQueueSizeRejectionThreshold(<span class="number">10</span>));</span><br><span class="line"> </span><br><span class="line">    assertThat(<span class="keyword">new</span> RemoteServiceTestCommand(config, <span class="keyword">new</span> RemoteServiceTestSimulator(<span class="number">500</span>)).execute(),</span><br><span class="line">      equalTo(<span class="string">"Success"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的测试中，我们设置了最大队列大小，核心队列大小和队列拒绝大小。当最大线程数达到10且任务队列大小达到10时，<em>Hystrix</em>将开始拒绝请求。</p>
<p>核心大小是始终在线程池中保持活动状态的线程数。</p>
<h3 id="5-3-短路断路器模式的防御性编程"><a href="#5-3-短路断路器模式的防御性编程" class="headerlink" title="5.3 短路断路器模式的防御性编程"></a>5.3 短路断路器模式的防御性编程</h3><p>但是，我们可以对远程服务调用进行改进。</p>
<p><strong>让我们考虑一下远程服务已经开始失败的情况。</strong></p>
<p>我们不想继续向它发出请求并浪费资源。理想情况下，我们希望停止在一定时间内发出请求，以便在恢复请求之前提供恢复服务的时间。这就是所谓的<em>短路断路器</em>模式。</p>
<p>让我们看看Hystrix如何实现这种模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenCircuitBreakerSetup_whenRemoteSvcCmdExecuted_thenReturnSuccess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    HystrixCommand.Setter config = HystrixCommand</span><br><span class="line">      .Setter</span><br><span class="line">      .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"RemoteServiceGroupCircuitBreaker"</span>));</span><br><span class="line"> </span><br><span class="line">    HystrixCommandProperties.Setter properties = HystrixCommandProperties.Setter();</span><br><span class="line">    properties.withExecutionTimeoutInMilliseconds(<span class="number">1000</span>);</span><br><span class="line">    properties.withCircuitBreakerSleepWindowInMilliseconds(<span class="number">4000</span>);</span><br><span class="line">    properties.withExecutionIsolationStrategy</span><br><span class="line">     (HystrixCommandProperties.ExecutionIsolationStrategy.THREAD);</span><br><span class="line">    properties.withCircuitBreakerEnabled(<span class="keyword">true</span>);</span><br><span class="line">    properties.withCircuitBreakerRequestVolumeThreshold(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    config.andCommandPropertiesDefaults(properties);</span><br><span class="line">    config.andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">      .withMaxQueueSize(<span class="number">1</span>)</span><br><span class="line">      .withCoreSize(<span class="number">1</span>)</span><br><span class="line">      .withQueueSizeRejectionThreshold(<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">    assertThat(<span class="keyword">this</span>.invokeRemoteService(config, <span class="number">10_000</span>), equalTo(<span class="keyword">null</span>));</span><br><span class="line">    assertThat(<span class="keyword">this</span>.invokeRemoteService(config, <span class="number">10_000</span>), equalTo(<span class="keyword">null</span>));</span><br><span class="line">    assertThat(<span class="keyword">this</span>.invokeRemoteService(config, <span class="number">10_000</span>), equalTo(<span class="keyword">null</span>));</span><br><span class="line"> </span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">    assertThat(<span class="keyword">new</span> RemoteServiceTestCommand(config, <span class="keyword">new</span> RemoteServiceTestSimulator(<span class="number">500</span>)).execute(),</span><br><span class="line">      equalTo(<span class="string">"Success"</span>));</span><br><span class="line"> </span><br><span class="line">    assertThat(<span class="keyword">new</span> RemoteServiceTestCommand(config, <span class="keyword">new</span> RemoteServiceTestSimulator(<span class="number">500</span>)).execute(),</span><br><span class="line">      equalTo(<span class="string">"Success"</span>));</span><br><span class="line"> </span><br><span class="line">    assertThat(<span class="keyword">new</span> RemoteServiceTestCommand(config, <span class="keyword">new</span> RemoteServiceTestSimulator(<span class="number">500</span>)).execute(),</span><br><span class="line">      equalTo(<span class="string">"Success"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">invokeRemoteService</span><span class="params">(HystrixCommand.Setter config, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String response = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = <span class="keyword">new</span> RemoteServiceTestCommand(config,</span><br><span class="line">          <span class="keyword">new</span> RemoteServiceTestSimulator(timeout)).execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HystrixRuntimeException ex) &#123;</span><br><span class="line">        System.out.println(<span class="string">"ex = "</span> + ex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述测试中，我们设置了不同的断路器属性。最重要的是：</p>
<ul>
<li>该<em>CircuitBreakerSleepWindow</em>被设置为4000毫秒。这将配置断路器窗口并定义将恢复对远程服务的请求的时间间隔</li>
<li>所述<em>CircuitBreakerRequestVolumeThreshold</em>其被设置为1，定义了故障率将被认为之前所需的请求的最小数目</li>
</ul>
<p>在上述设置到位后，我们的<em>HystrixCommand</em>将在两次失败请求后立即打开。即使我们将服务延迟设置为500毫秒，第三个请求甚至不会命中远程服务，<em>Hystrix</em>会短路，我们的方法将返回<em>null</em>作为响应。</p>
<p>我们随后将添加一个<em>Thread.sleep(5000)</em>以跨越我们设置的睡眠窗口的限制。这将导致<em>Hystrix</em>关闭环路，后续请求将成功流过。</p>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a>6 结论</h2><p>总之，Hystrix旨在：</p>
<ol>
<li>提供对通常通过网络访问的服务的故障和延迟的保护和控制</li>
<li>停止因某些服务中断而导致的故障级联</li>
<li>快速失败并迅速恢复</li>
<li>尽可能优雅地降级</li>
<li>对故障进行实时监控和指挥中心警报</li>
</ol>
]]></content>
      <tags>
        <tag>Hystrix</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA,Hibernate及SpringDataJPA 的审计</title>
    <url>/2016/01/23/jpa-hibernate-ji-springdatajpa-de-shen-ji/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在ORM的框架中，数据库审计一般是指跟踪和记录与持久化实体相关的事件，或者仅仅是实体版本跟踪。受SQL触发器的启发，事件是对实体的插入，更新和删除操作，类似于源码版本控制。</p>
<p>我们将演示三种不同的审计方法。首先，我们将使用标准JPA实现它，接下来，我们将看两个提供自己的审计功能的JPA扩展：一个由Hibernate提供，另一个由Spring Data提供。</p>
<p>以下是将在此示例中使用的示例相关实体<em>Bar</em>和<em>Foo</em>：</p>
<p><img src="/images/pasted-107.png" alt="upload successful"></p>
<a id="more"></a>
<h2 id="2-使用JPA进行审计"><a href="#2-使用JPA进行审计" class="headerlink" title="2. 使用JPA进行审计"></a>2. 使用JPA进行审计</h2><p>JPA没有明确包含审计API，但可以使用实体生命周期事件来实现功能。</p>
<h3 id="2-1-PrePersist，-PreUpdate-和-PreRemove"><a href="#2-1-PrePersist，-PreUpdate-和-PreRemove" class="headerlink" title="2.1 @PrePersist， @PreUpdate 和 @PreRemove"></a>2.1 <em>@PrePersist</em>， <em>@PreUpdate</em> 和 <em>@PreRemove</em></h3><p>在JPA <em>Entity</em>类中，实体对象生命周期在发生变化时会有相应的事件回调，比如相应的DML操作之前执行的回调，有<em>@PrePersist</em>，<em>@PreUpdate</em>和<em>@PreRemove</em> 分别对于 <strong>持久化前</strong>，<strong>更新前</strong>以及<strong>删除前</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrePersist</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="meta">@PreUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreUpdate</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="meta">@PreRemove</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreRemove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些内部回调方法没有返回值，且没有参数，它们可以具有任何名称和任何访问级别，但不应该是静态的。</p>
<blockquote>
<p>请注意，JPA 中的 <em>@Version</em> 注解与我们的主题不一样 - 它与乐观锁定相关，而不是与审计数据相关。</p>
</blockquote>
<h3 id="2-2-实现回调方法"><a href="#2-2-实现回调方法" class="headerlink" title="2.2 实现回调方法"></a>2.2 实现回调方法</h3><p>上一节提到的方法有一个限制，JPA 2 specification (JSR 317) 的相关描述如下：</p>
<blockquote>
<p>In general, the lifecycle method of a portable application should not invoke EntityManager or Query operations, access other entity instances, or modify relationships within the same persistence context. A lifecycle callback method may modify the non-relationship state of the entity on which it is invoked.</p>
</blockquote>
<p>意思就是生命周期回调方法不应该调用 <em>EntityManager</em> 或者 <em>Query</em> 的操作去修改其它的实例或者实例的关联关系。</p>
<p>在没有审计框架的情况下，我们必须手动维护数据库架构和域模型。对于我们的简单用例，让我们向实体添加两个新属性，因为我们只能管理“实体的非关系状态”。<em>operation</em> 属性将存储执行的操作的名称，<em>timestamp</em>属性是操作的时间戳：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"operation"</span>)</span><br><span class="line">    <span class="keyword">private</span> String operation;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"timestamp"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// standard setters and getters for the new properties</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrePersist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audit(<span class="string">"INSERT"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@PreUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audit(<span class="string">"UPDATE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@PreRemove</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audit(<span class="string">"DELETE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        setOperation(operation);</span><br><span class="line">        setTimestamp((<span class="keyword">new</span> Date()).getTime());</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要将此类审计添加到多个类，则可以使用 <em>@EntityListeners</em> 来集中代码。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EntityListeners</span>(AuditListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Entity</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Bar</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditListener</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforePersist</span><span class="params">(Object object)</span> </span>&#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Hibernate-Envers"><a href="#3-Hibernate-Envers" class="headerlink" title="3. Hibernate Envers"></a>3. Hibernate Envers</h2><p>如果使用 Hibernate 框架，我们可以使用<em>Interceptor</em> 和 <em>EventListeners</em> 以及数据库触发器来完成审计。但是ORM框架提供了Envers，这是一个实现持久化类的审计和版本控制的模块。</p>
<h3 id="3-1-Envers入门"><a href="#3-1-Envers入门" class="headerlink" title="3.1 Envers入门"></a>3.1 Envers入门</h3><p>要启用Envers，需要添加<em>hibernate-envers</em> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-envers<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<em>@Entity</em>或特定的<em>@Column</em>上添加<em>@Audited</em>注释（如果您只需要审计特定属性）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Audited</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<em>Bar</em>与<em>Foo有</em>一对多的关系。在这种情况下，我们要么通过在<em>Foo</em>上添加<em>@Audited</em>或在<em>Bar</em>的关系属性上设置<em>@NotAudited</em>来审计<em>Foo</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(mappedBy = <span class="string">"bar"</span>)</span><br><span class="line"><span class="meta">@NotAudited</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Foo&gt; fooSet;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-创建审计日志表"><a href="#3-2-创建审计日志表" class="headerlink" title="3.2 创建审计日志表"></a>3.2 创建审计日志表</h3><p>有几种方法可以创建审计表：</p>
<ul>
<li>设置<em>hibernate.hbm2ddl.auto=create, create-drop or update</em>，这样Envers就可以自动创建它们</li>
<li>使用o <em>rg.hibernate.tool.EnversSchemaGenerator</em>以编程方式导出完整的数据库Schema</li>
<li>使用Ant任务生成适当的DDL语句</li>
<li>使用Maven插件从映射（例如Juplo）生成数据库模式以导出Envers模式（与Hibernate 4及更高版本一起使用）</li>
</ul>
<blockquote>
<p>注意使用<em>hibernate.hbm2ddl.auto</em>在生产中是不安全的。</p>
</blockquote>
<p>在我们的例子中，<em>bar_AUD</em>和<em>foo_AUD</em>（如果你将<em>Foo</em>设置为<em>@Audited</em>）表应该自动生成。审计表从实体表中复制所有审计字段，其中包含两个字段<em>REVTYPE</em>（值为：“0”表示添加，“1”表示更新，“2”表示删除实体）和<em>REV</em>。</p>
<p>除此之外，默认会生成一个名为<em>REVINFO</em>的表，它包括两个重要的字段<em>REV</em>和<em>REVTSTMP</em>，记录每次修改的时间戳。正如你猜测的那样，<em>bar_AUD.REV</em>和<em>foo_AUD.REV</em>实际上是<em>REVINFO.REV</em>的外键。</p>
<h3 id="3-3-配置Envers"><a href="#3-3-配置Envers" class="headerlink" title="3.3 配置Envers"></a>3.3 配置Envers</h3><p>您可以像任何其他Hibernate属性一样配置Envers属性。例如，让我们将审计表后缀（默认为“ <em>_AUD</em> ”）更改为“ <em>_AUDIT_LOG</em> ”。比如设置相应属性<em>org.hibernate.envers.audit_table_suffix</em>的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties hibernateProperties = <span class="keyword">new</span> Properties(); </span><br><span class="line">hibernateProperties.setProperty(</span><br><span class="line">  <span class="string">"org.hibernate.envers.audit_table_suffix"</span>, <span class="string">"_AUDIT_LOG"</span>); </span><br><span class="line">sessionFactory.setHibernateProperties(hibernateProperties);</span><br></pre></td></tr></table></figure>
<p>在<a href="http://docs.jboss.org/envers/docs/#configuration" target="_blank" rel="noopener">Envers文档中</a>找到可用属性的完整列表。</p>
<h3 id="3-4-访问实体历史记录"><a href="#3-4-访问实体历史记录" class="headerlink" title="3.4 访问实体历史记录"></a>3.4 访问实体历史记录</h3><p>您可以通过类似于通过Hibernate条件API查询数据的方式查询历史数据。实体的审计历史记录可以使用<em>AuditReader</em> 接口访问，这个接口可以通过 <em>的EntityManager</em> 或<em>Session</em> 获取，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AuditReader reader = AuditReaderFactory.get(session);</span><br></pre></td></tr></table></figure>
<p>Envers提供<em>AuditQueryCreator</em>（由<em>AuditReader.createQuery()</em>返回）创建特定于审计的查询，如以所示将返回在修订版＃2中修改的所有<em>Bar</em>实例（其中<em>bar_AUDIT_LOG.REV = 2</em>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AuditQuery query = reader.createQuery().forEntitiesAtRevision(Bar<span class="class">.<span class="keyword">class</span>, 2)</span></span><br></pre></td></tr></table></figure>
<p>以下是如何查询<em>Bar</em>的修订版，即它将导致获取所有审计状态中所有<em>Bar</em>实例的列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">AuditQuery query = reader.createQuery().forRevisionsOfEntity(Bar<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">true</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果第二个参数为false，则结果还会 join <em>REVINFO</em>表，否则，仅返回实体实例。最后一个参数指定是否返回已删除的<em>Bar</em>实例。</p>
<p>还可以使用 <em>AuditEntity</em> 工厂类指定约束：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query.addOrder(AuditEntity.revisionNumber().desc());</span><br></pre></td></tr></table></figure></p>
<h2 id="4-Spring-Data-JPA"><a href="#4-Spring-Data-JPA" class="headerlink" title="4. Spring Data JPA"></a>4. Spring Data JPA</h2><p>Spring Data JPA 是一个通过在JPA提供程序的顶部添加额外的抽象层来扩展JPA的框架。我们可以扩展<em>CrudRepository &lt;T，ID extends Serializable&gt;</em>，用于通用CRUD操作的接口。一旦您创建了 Repository 并将其注入另一个组件，Spring Data就会自动提供实现，您就可以添加审计功能了。</p>
<h3 id="4-1-启用JPA审计"><a href="#4-1-启用JPA审计" class="headerlink" title="4.1 启用JPA审计"></a>4.1 启用JPA审计</h3><p>只需在 <em>@Configuration</em> 类上添加 <em>@EnableJpaAuditing</em> 即可启用 JPA 审计，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceConfig</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-添加Spring的实体回调监听器"><a href="#4-2-添加Spring的实体回调监听器" class="headerlink" title="4.2 添加Spring的实体回调监听器"></a>4.2 添加Spring的实体回调监听器</h3><p>我们已经知道，JPA提供<em>@EntityListeners</em> 注释来指定回调监听类。Spring Data 也提供了自己的JPA实体监听器类：<em>AuditingEntityListener</em>。所以让我们为<em>Bar</em> 实体指定监听器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@EntityListeners</span>(AuditingEntityListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Bar</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在，监听器将在持久化和更新<em>Bar</em>实体时捕获审计信息。</p>
<h3 id="4-3-跟踪创建的和上次修改的日期"><a href="#4-3-跟踪创建的和上次修改的日期" class="headerlink" title="4.3 跟踪创建的和上次修改的日期"></a>4.3 跟踪创建的和上次修改的日期</h3><p>接下来，我们将添加两个新属性，用于将创建和最后修改日期存储到<em>Bar</em>实体。这些属性由<em>@CreatedDate</em>和<em>@LastModifiedDate</em> 进行注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@EntityListeners</span>(AuditingEntityListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"created_date"</span>, nullable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> createdDate;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"modified_date"</span>)</span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> modifiedDate;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，可以将这几个属性移动到基类（由<em>@MappedSuperClass</em>注释），该基类将由所有审计实体继承。在我们的示例中，为简单起见，我们将它们直接添加到<em>Bar</em>。</p>
<h3 id="4-4-审计更改的作者"><a href="#4-4-审计更改的作者" class="headerlink" title="4.4 审计更改的作者"></a>4.4 审计更改的作者</h3><p>您不仅可以跟踪何时进行更改，还可以跟踪谁进行了修改，同样的，添加两个属性，并由 <em>@CreatedBy</em> 和 <em>@LastModifiedBy</em> 进行注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"created_by"</span>)</span><br><span class="line">  <span class="meta">@CreatedBy</span></span><br><span class="line">  <span class="keyword">private</span> String createdBy;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"modified_by"</span>)</span><br><span class="line">  <span class="meta">@LastModifiedBy</span></span><br><span class="line">  <span class="keyword">private</span> String modifiedBy;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>使用<em>@CreatedBy</em>和<em>@LastModifiedBy</em>注释的列将自动填充创建或上次修改实体的作者。当然，该作者信息需要开发者自己提供。实际上框架是会查找 Spring 上下文中的 <em>AuditorAware <t></t></em>接口实现才，并调用其 <em>getCurrentAuditor()</em> 方法，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditorAwareImpl</span> <span class="keyword">implements</span> <span class="title">AuditorAware</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCurrentAuditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// your custom logic</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据不同的情况，可以从 Session 或者 <em>SpringSecurity</em> 框架的 Principal 中获取当前登录用户信息</p>
</blockquote>
<p>为了配置该应用使用<em>AuditorAwareImpl</em>查找当前主体，<em>@EnableJpaAuditing</em> 中可以设置 <em>auditorAwareRef</em>属性为我们前面提到的 <em>AuditorAware</em> 实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaAuditing</span>(auditorAwareRef=<span class="string">"auditorProvider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceConfig</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">AuditorAware&lt;String&gt; <span class="title">auditorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AuditorAwareImpl();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JPA</tag>
        <tag>数据审计</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA的Criteria查询</title>
    <url>/2016/03/29/jpa-de-criteria-cha-xun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在本教程中，我们将讨论一个非常有用的JPA功能 - Criteria Queries。</p>
<p>它不仅使我们能够在不执行原始SQL的情况下编写查询，而且还为我们提供了一些对查询的面向对象控制，这是Hibernate的主要特性之一。Criteria API允许我们以编程方式构建条件查询对象，我们可以在其中应用不同类型的过滤规则和逻辑条件。</p>
<p><strong>从Hibernate 5.2开始，不推荐使用Hibernate Criteria API，新开发的重点是JPA Criteria API。</strong>我们将探索如何使用Hibernate和JPA来构建Criteria Queries。</p>
<h2 id="2-Maven依赖"><a href="#2-Maven依赖" class="headerlink" title="2. Maven依赖"></a>2. Maven依赖</h2><p>为了说明API，我们将使用参考JPA实现 - Hibernate。</p>
<p>要使用Hibernate，请确保将最新版本添加到<em>pom.xml</em>文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在<a href="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.hibernate%22%20AND%20a%3A%22hibernate-core%22" target="_blank" rel="noopener">这里</a>找到最新版本的Hibernate。</p>
<h2 id="3-使用-Criteria-的简单示例"><a href="#3-使用-Criteria-的简单示例" class="headerlink" title="3. 使用 Criteria 的简单示例"></a>3. 使用 Criteria 的简单示例</h2><p>让我们首先看一下如何使用Criteria查询检索数据。我们将看看如何从数据库中获取特定类的所有实例。</p>
<p>我们有一个<em>Item</em>类，它表示数据库中的元组<em>“ITEM”</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer itemId;</span><br><span class="line">    <span class="keyword">private</span> String itemName;</span><br><span class="line">    <span class="keyword">private</span> String itemDescription;</span><br><span class="line">    <span class="keyword">private</span> Integer itemPrice;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// standard setters and getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看一个简单的条件查询，它将从数据库中检索“ <em>ITEM”的</em>所有行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Session session = HibernateUtil.getHibernateSession();</span><br><span class="line">CriteriaBuilder cb = session.getCriteriaBuilder();</span><br><span class="line">CriteriaQuery&lt;Item&gt; cr = cb.createQuery(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Root&lt;Item&gt; root = cr.from(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">cr.select(root);</span><br><span class="line"> </span><br><span class="line">Query&lt;Item&gt; query = session.createQuery(cr);</span><br><span class="line">List&lt;Item&gt; results = query.getResultList();</span><br></pre></td></tr></table></figure>
<p>以上查询是如何获取所有项目的简单演示。让我们一步一步看看做了些什么：</p>
<ol>
<li>从<em>SessionFactory</em>对象创建<em>Session</em>实例</li>
<li>通过调用<em>getCriteriaBuilder()</em>方法创建C <em>riteriaBuilder</em>的实例</li>
<li>通过调用  <em>CriteriaBuilder</em> <em>createQuery()方法</em>创建<em>CriteriaQuery</em>实例 </li>
<li>通过调用  <em>Session</em> <em>createQuery()</em>方法创建<em>Query</em>实例 </li>
<li>调用<em>查询</em>对象的<em>getResultList()</em>方法，该方法为我们提供结果</li>
</ol>
<p>现在我们已经介绍了基础知识，让我们继续讨论条件查询的一些功能。</p>
<h3 id="3-1-使用表达式"><a href="#3-1-使用表达式" class="headerlink" title="3.1 使用表达式"></a>3.1 使用表达式</h3><p><strong>CriteriaBuilder可用于限制基于特定条件的查询结果。</strong> 通过使用  <em>CriteriaQuery where()</em>方法并提供<em>CriteriaBuilder</em> 创建的 <em>表达式</em>。</p>
<p>以下是常用<em>表达式的</em>一些示例：</p>
<p>要获得价格超过1000的商品：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.gt(root.get(<span class="string">"itemPrice"</span>), <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>接下来，获取<em>itemPrice</em>小于1000的项目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.lt(root.get(<span class="string">"itemPrice"</span>), <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>有项目<em>itemNames中</em>含有  <em>chair</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.like(root.get(<span class="string">"itemName"</span>), <span class="string">"%chair%"</span>));</span><br></pre></td></tr></table></figure>
<p>记录<em>itemPrice</em>在100到200之间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.between(root.get(<span class="string">"itemPrice"</span>), <span class="number">100</span>, <span class="number">200</span>));</span><br></pre></td></tr></table></figure>
<p>要检查给定属性是否为null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.isNull(root.get(<span class="string">"itemDescription"</span>)));</span><br></pre></td></tr></table></figure>
<p>要检查给定属性是否为null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.isNotNull(root.get(<span class="string">"itemDescription"</span>)));</span><br></pre></td></tr></table></figure>
<p>您还可以使用方法<em>isEmpty()</em>和<em>isNotEmpty()</em>来测试类中的<em>List</em>是否为空。</p>
<p>现在问题不可避免地出现了，我们是否可以将上述两种或两种以上的比较结合起来。答案当然是肯定的 - <strong>Criteria API允许我们轻松地链接表达式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate[] predicates = <span class="keyword">new</span> Predicate[<span class="number">2</span>];</span><br><span class="line">predicates[<span class="number">0</span>] = cb.isNull(root.get(<span class="string">"itemDescription"</span>));</span><br><span class="line">predicates[<span class="number">1</span>] = cb.like(root.get(<span class="string">"itemName"</span>), <span class="string">"chair%"</span>);</span><br><span class="line">cr.select(root).where(predicates);</span><br></pre></td></tr></table></figure>
<p>要使用逻辑运算添加两个表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate greaterThanPrice = cb.gt(root.get(<span class="string">"itemPrice"</span>), <span class="number">1000</span>);</span><br><span class="line">Predicate chairItems = cb.like(root.get(<span class="string">"itemName"</span>), <span class="string">"Chair%"</span>);</span><br></pre></td></tr></table></figure>
<p>具有上述定义条件的项目与<em>Logical OR连接</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.or(greaterThanPrice, chairItems));</span><br></pre></td></tr></table></figure>
<p>要获取与使用<em>Logical AND</em>连接的上述条件匹配的项目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.select(root).where(cb.and(greaterThanPrice, chairItems));</span><br></pre></td></tr></table></figure>
<h3 id="3-2-排序"><a href="#3-2-排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h3><p>现在我们已经了解了<em>Criteria</em>的基本用法，让我们来看看<em>Criteria</em>的排序功能。</p>
<p>在下面的示例中，我们按名称的升序排列列表，然后按价格的降序排列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cr.orderBy(</span><br><span class="line">  cb.asc(root.get(<span class="string">"itemName"</span>)), </span><br><span class="line">  cb.desc(root.get(<span class="string">"itemPrice"</span>)));</span><br></pre></td></tr></table></figure>
<p>在下一节中，我们将了解如何进行聚合函数。</p>
<h3 id="3-3-投影、聚合和分组功能"><a href="#3-3-投影、聚合和分组功能" class="headerlink" title="3.3 投影、聚合和分组功能"></a>3.3 投影、聚合和分组功能</h3><p>到目前为止，我们已经涵盖了大部分基本主题。现在让我们看看不同的聚合函数：</p>
<p>行数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CriteriaQuery&lt;Long&gt; cr = cb.createQuery(Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Root&lt;Item&gt; root = cr.from(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">cr.select(cb.count(root));</span><br><span class="line">Query&lt;Long&gt; query = session.createQuery(cr);</span><br><span class="line">List&lt;Long&gt; itemProjected = query.getResultList();</span><br></pre></td></tr></table></figure>
<p>以下是聚合函数的示例：</p>
<p>求 <em>平均</em> 的聚合函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CriteriaQuery&lt;Double&gt; cr = cb.createQuery(Double<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Root&lt;Item&gt; root = cr.from(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">cr.select(cb.avg(root.get(<span class="string">"itemPrice"</span>)));</span><br><span class="line">Query&lt;Double&gt; query = session.createQuery(cr);</span><br><span class="line">List avgItemPriceList = query.getResultList();</span><br></pre></td></tr></table></figure>
<p>其他有用的聚合方法是<em>sum()</em>，<em>max()</em>，<em>min()</em> ，<em>count()</em> 等。</p>
<h3 id="3-4-CriteriaUpdate"><a href="#3-4-CriteriaUpdate" class="headerlink" title="3.4 CriteriaUpdate"></a>3.4 CriteriaUpdate</h3><p><strong>从JPA 2.1开始，支持使用Criteria API 执行数据库更新。</strong></p>
<p><em>CriteriaUpdate</em>有一个<em>set()</em>方法，可用于为数据库记录提供新值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CriteriaUpdate&lt;Item&gt; criteriaUpdate = cb.createCriteriaUpdate(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Root&lt;Item&gt; root = criteriaUpdate.from(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">criteriaUpdate.set(<span class="string">"itemPrice"</span>, newPrice);</span><br><span class="line">criteriaUpdate.where(cb.equal(root.get(<span class="string">"itemPrice"</span>), oldPrice));</span><br><span class="line"> </span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line">session.createQuery(criteriaUpdate).executeUpdate();</span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，我们从  <em>CriteriaBuilder</em>创建了<em>CriteriaUpdate <item></item></em> 的实例，  并使用其<em>set()</em>  方法为<em>itemPrice</em>提供新值  <em>。</em>要更新多个属性，我们只需要多次调用  <em>set()</em>  方法。</p>
<h3 id="3-5-CriteriaDelete"><a href="#3-5-CriteriaDelete" class="headerlink" title="3.5 CriteriaDelete"></a>3.5 CriteriaDelete</h3><p><em>CriteriaDelete，</em>顾名思义，使用<em>Criteria</em> API 启用删除操作。我们所需要的只是创建一个<em>CriteriaDelete</em>实例  并使用  <em>where()</em>  方法来应用限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CriteriaDelete&lt;Item&gt; criteriaDelete = cb.createCriteriaDelete(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Root&lt;Item&gt; root = criteriaDelete.from(Item<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">criteriaDelete.where(cb.greaterThan(root.get(<span class="string">"itemPrice"</span>), targetPrice));</span><br><span class="line"> </span><br><span class="line">Transaction transaction = session.beginTransaction();</span><br><span class="line">session.createQuery(criteriaDelete).executeUpdate();</span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure>
<h2 id="4-相比HQL的优势"><a href="#4-相比HQL的优势" class="headerlink" title="4. 相比HQL的优势"></a>4. 相比HQL的优势</h2><p>在前面的部分中，我们介绍了如何使用Criteria Queries。</p>
<p>显然，<strong>Criteria查询优于HQL的主要和最强硬的优势是漂亮，干净，面向对象的API。</strong></p>
<p>与普通的HQL相比，我们可以简单地编写更灵活的动态查询。逻辑可以通过IDE重构，并具有Java语言本身的所有类型安全优势。</p>
<p>当然也存在一些缺点，特别是在更复杂的连接处。</p>
<p>因此，一般来说，我们将不得不使用最好的工具 - 在大多数情况下可以使用Criteria API，但肯定有一些情况我们必须降低水平。</p>
]]></content>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>JUnit5概览</title>
    <url>/2016/04/23/junit5-gai-lan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>JUnit是最流行的Java单元测试框架之一，因此当新的主要版本出现时，它在开发人员社区中是一个大问题。JUnit 5的alpha版本于2月初发布，它包含了许多令人兴奋的创新。</p>
<p>本文将探讨此版本的新功能，以及与以前版本的主要区别。<br><a id="more"></a></p>
<h2 id="2-依赖关系和设置"><a href="#2-依赖关系和设置" class="headerlink" title="2. 依赖关系和设置"></a>2. 依赖关系和设置</h2><p>安装JUnit 5非常简单。只需将以下依赖项添加到您的<em>pom.xml</em>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，目前还没有IDE支持JUnit 5，因此您还必须指定构建脚本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-surefire-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，此版本<strong>需要Java 8才能运行</strong>。</p>
<p>创建测试时，请确保导入<em>org.junit.jupiter.api.Test</em> ，而不是<em>org.junit.Test</em>。此外，测试方法不再需要 <em>public</em>, <em>package</em> 级别的也可以。</p>
<h2 id="3-What’s-New"><a href="#3-What’s-New" class="headerlink" title="3. What’s New"></a>3. What’s New</h2><p>JUnit 5试图充分利用Java 8的新特性，特别是lambda表达式。</p>
<h3 id="3-1-断言"><a href="#3-1-断言" class="headerlink" title="3.1 断言"></a>3.1 断言</h3><p>断言已移至<em>org.junit.jupiter.api.Assertions</em>并已得到显着改进。如前所述，您现在可以在断言中使用lambdas：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambdaExpressions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertTrue(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">      .stream()</span><br><span class="line">      .mapToInt(i -&gt; i)</span><br><span class="line">      .sum() &gt; <span class="number">5</span>, () -&gt; <span class="string">"Sum should be greater than 5"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上面的例子非常简单，但是对断言消息使用lambda表达式的一个优点是它被 lazy evaluate，如果消息构造很昂贵，这可以节省时间和资源。</p>
<p>现在还可以使用<em>assertAll()</em>对断言进行分组，该断言将使用<em>MultipleFailuresError</em>报告组内任何失败的断言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void groupAssertions() &#123;</span><br><span class="line">    int[] numbers = &#123;0, 1, 2, 3, 4&#125;;</span><br><span class="line">    assertAll(&quot;numbers&quot;,</span><br><span class="line">        () -&gt; assertEquals(numbers[0], 1),</span><br><span class="line">        () -&gt; assertEquals(numbers[3], 3),</span><br><span class="line">        () -&gt; assertEquals(numbers[4], 1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着现在制作更复杂的断言更安全，因为您将能够确定任何故障的确切位置。</p>
<h3 id="3-2-断言"><a href="#3-2-断言" class="headerlink" title="3.2 断言"></a>3.2 断言</h3><p>假设仅在满足某些条件时用于运行测试。这通常用于测试正常运行所需的外部条件，但这些条件与正在测试的内容无直接关系。</p>
<p>您可以使用<em>assumeTrue()</em>，<em>assumeFalse()</em>和<em>assumeThat()</em>声明一个假设<em>。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trueAssumption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assumeTrue(<span class="number">5</span> &gt; <span class="number">1</span>);</span><br><span class="line">    assertEquals(<span class="number">5</span> + <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">falseAssumption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assumeFalse(<span class="number">5</span> &lt; <span class="number">1</span>);</span><br><span class="line">    assertEquals(<span class="number">5</span> + <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assumptionThat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String someString = <span class="string">"Just a string"</span>;</span><br><span class="line">    assumingThat(</span><br><span class="line">        someString.equals(<span class="string">"Just a string"</span>),</span><br><span class="line">        () -&gt; assertEquals(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果假设失败，则抛出<em>TestAbortedException</em>并简单地跳过测试，假设也支持lambda表达式。</p>
<h3 id="3-3-异常"><a href="#3-3-异常" class="headerlink" title="3.3 异常"></a>3.3 异常</h3><p>JUnit 5改进了对异常的支持。添加了一个<em>assertThrows()</em>方法，用于验证表达式是否抛出给定类型的表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shouldThrowException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable exception = assertThrows(UnsupportedOperationException<span class="class">.<span class="keyword">class</span>, () -&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not supported"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    assertEquals(exception.getMessage(), <span class="string">"Not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如示例所示，与JUnit 4相比，JUnit 5提供了对抛出异常的更多控制。最明显的含义是，现在可以轻松获取有关异常的任何信息，就像我们在示例中通过检查异常消息所做的那样。</p>
<h3 id="3-4-嵌套测试"><a href="#3-4-嵌套测试" class="headerlink" title="3.4 嵌套测试"></a>3.4 嵌套测试</h3><p>添加了嵌套测试，以允许开发人员表达不同测试组之间的复杂关系。语法非常简单 - 您只需要使用<em>@Nested</em>注释内部类。</p>
<p>JUnit文档提供了非常完成的<a href="http://junit.org/junit5/docs/current/user-guide/#nested-tests" target="_blank" rel="noopener">示例</a>，其中说明了可能的用途之一。</p>
<h3 id="3-5-禁用测试"><a href="#3-5-禁用测试" class="headerlink" title="3.5 禁用测试"></a>3.5 禁用测试</h3><p>现在可以使用<em>@Disabled</em>注释禁用测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disabledTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertTrue(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此测试不会运行。所述<em>@Disabled</em>注释可以应用于任一个测试用例或测试方法，相当于 JUnit4 中的<em>@Ignore</em>。</p>
<h3 id="3-6-标记"><a href="#3-6-标记" class="headerlink" title="3.6 标记"></a>3.6 标记</h3><p>标签是JUnit 4中<em>Categories</em>的替代。标签可以与<em>@Tag</em>注释一起应用。这些允许开发人员分组和过滤测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tag</span>(<span class="string">"Test case"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaggedTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"Method"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">2</span>+<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>这篇文章快速概述了JUnit 5带来的变化。</p>
<p>值得注意的是，在编写本文时，只有Alpha版本可用，因此有些内容可能会在发布之前发生变化。</p>
]]></content>
      <tags>
        <tag>JUnit</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson中的 null 处理</title>
    <url>/2015/10/27/jackson-zhong-de-null-chu-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Jackson 是JSON序列化框架的一种，也是 Spring/SpringBoot 中内置推荐的基础框架，对于 JSON 的序列化有着非常好的性能以及易用的 API。</p>
<p>我们在开发过程中经常会碰到在序列化过程中的 <em>null</em> 问题，为了减少序列化后的数据大小，我们通常希望在序列化的过程中去掉那些 <em>null</em> 的数据，本文将介绍如何设置<strong>Jackson在序列化 java类时忽略空字段</strong>。<br><a id="more"></a></p>
<h2 id="2-忽略类上的空字段"><a href="#2-忽略类上的空字段" class="headerlink" title="2. 忽略类上的空字段"></a>2. 忽略类上的空字段</h2><p><strong>Jackson 框架支持通过在类上添加 <em>@JsonInclude</em> 注解来忽略为 <em>null</em> 的字段</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonInclude</span>(Include.NON_NULL)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDto</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>也可以更细粒度的在要忽略的字段上添加 <em>@JsonInclude</em>  注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDto</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JsonInclude</span>(Include.NON_NULL)</span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> intValue;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是相应的单元测试，可以看到 <em>null</em> 确实没有包含在最终的序列化输出中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullsIgnoredOnClass_whenWritingObjectWithNullField_thenIgnored</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    MyDto dtoObject = <span class="keyword">new</span> MyDto();</span><br><span class="line"> </span><br><span class="line">    String dtoAsString = mapper.writeValueAsString(dtoObject);</span><br><span class="line"> </span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"intValue"</span>));</span><br><span class="line">    assertThat(dtoAsString, not(containsString(<span class="string">"stringValue"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-全局忽略空字段"><a href="#3-全局忽略空字段" class="headerlink" title="3. 全局忽略空字段"></a>3. 全局忽略空字段</h2><p>Jackson还允许<strong>在ObjectMapper上全局配置忽略空字段</strong>，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapper.setSerializationInclusion(Include.NON_NULL);</span><br></pre></td></tr></table></figure>
<p>设置后，就不需要在各个类或者字段上设置 <em>@JsonInclude</em> 注解了，所有的序列化都将统一忽略任何类中的任何<em>空</em>字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNullsIgnoredGlobally_whenWritingObjectWithNullField_thenIgnored</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    mapper.setSerializationInclusion(Include.NON_NULL);</span><br><span class="line">    MyDto dtoObject = <span class="keyword">new</span> MyDto();</span><br><span class="line"> </span><br><span class="line">    String dtoAsString = mapper.writeValueAsString(dtoObject);</span><br><span class="line"> </span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"intValue"</span>));</span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"booleanValue"</span>));</span><br><span class="line">    assertThat(dtoAsString, not(containsString(<span class="string">"stringValue"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Map-的处理"><a href="#4-Map-的处理" class="headerlink" title="4 Map 的处理"></a>4 <em>Map</em> 的处理</h2><p><em>Map</em> 比较特殊，包括了两个部分：Key - Value，要分别对待。</p>
<h3 id="4-1-忽略Map-中-value-为-null-的数据"><a href="#4-1-忽略Map-中-value-为-null-的数据" class="headerlink" title="4.1 忽略Map 中 value  为 null  的数据"></a>4.1 忽略<em>Map</em> 中 value  为 <em>null</em>  的数据</h3><p>如果想要忽略 <em>Map</em> 中 value 为 <em>null</em> 的数据，那么需要用到前一节提到的 <em>ObjectMapper</em> 全局配置：<code>mapper.setSerializationInclusion(Include.NON_NULL);</code>，单元测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenIgnoringNullValuesInMap_whenWritingMapObjectWithNullValue_thenIgnored</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    mapper.setSerializationInclusion(Include.NON_NULL);</span><br><span class="line"> </span><br><span class="line">    MyDto dtoObject1 = <span class="keyword">new</span> MyDto();</span><br><span class="line"> </span><br><span class="line">    Map&lt;String, MyDto&gt; dtoMap = <span class="keyword">new</span> HashMap&lt;String, MyDto&gt;();</span><br><span class="line">    dtoMap.put(<span class="string">"dtoObject1"</span>, dtoObject1);</span><br><span class="line">    dtoMap.put(<span class="string">"dtoObject2"</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    String dtoMapAsString = mapper.writeValueAsString(dtoMap);</span><br><span class="line"> </span><br><span class="line">    assertThat(dtoMapAsString, containsString(<span class="string">"dtoObject1"</span>));</span><br><span class="line">    assertThat(dtoMapAsString, not(containsString(<span class="string">"dtoObject2"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-忽略Map-中-key-为-null-的数据"><a href="#4-2-忽略Map-中-key-为-null-的数据" class="headerlink" title="4.2 忽略Map 中 key  为 null  的数据"></a>4.2 忽略<em>Map</em> 中 key  为 <em>null</em>  的数据</h3><p>这种情况有点特殊，默认情况下，Jackson 是不支持有 <em>null</em> key 的 <em>Map</em> 的，如果你尝试序列化一个有 null key 的 <em>Map</em> 是会报错，抛出如下的异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.f.j.c.JsonGenerationException: </span><br><span class="line">  Null key for a Map not allowed in JSON (use a converting NullKeySerializer?)</span><br><span class="line">    at c.f.j.d.s.i.FailingSerializer.serialize(FailingSerializer.java:36)</span><br></pre></td></tr></table></figure>
<p>不过 Jackson 框架提供了很好的自定义序列化机制，我们可以扩展一个 <em>StdSerializer</em> 来实现对于 <em>null</em> key 的支持，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDtoNullKeySerializer</span> <span class="keyword">extends</span> <span class="title">StdSerializer</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDtoNullKeySerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDtoNullKeySerializer</span><span class="params">(Class&lt;Object&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object nullKey, JsonGenerator jsonGenerator, SerializerProvider unused)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重写了 <em>serialize()</em> 方法，当 key 为空时，我们通过 <code>jsonGenerator.writeFieldName(&quot;&quot;)</code> 指定了<strong>空字符串</strong>作为 key 来完成序列化工作。我们可以简单的测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAllowingMapObjectWithNullKey_whenWriting_thenCorrect</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    mapper.getSerializerProvider().setNullKeySerializer(<span class="keyword">new</span> MyDtoNullKeySerializer());</span><br><span class="line"> </span><br><span class="line">    MyDto dtoObject = <span class="keyword">new</span> MyDto();</span><br><span class="line">    dtoObject.setStringValue(<span class="string">"dtoObjectString"</span>);</span><br><span class="line">  </span><br><span class="line">    Map&lt;String, MyDto&gt; dtoMap = <span class="keyword">new</span> HashMap&lt;String, MyDto&gt;();</span><br><span class="line">    dtoMap.put(<span class="keyword">null</span>, dtoObject);</span><br><span class="line"> </span><br><span class="line">    String dtoMapAsString = mapper.writeValueAsString(dtoMap);</span><br><span class="line"> </span><br><span class="line">    assertThat(dtoMapAsString, containsString(<span class="string">"\"\""</span>));</span><br><span class="line">    assertThat(dtoMapAsString, containsString(<span class="string">"dtoObjectString"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h3><p>序列化Map对象很常见，<em>null</em> 在我们的数据模型中也非常的重要且常见，Jackson提供了一些方便的自定义选项，可帮助您很好地自定义此序列化过程的输出。</p>
]]></content>
      <tags>
        <tag>Jackson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson 部分序列化</title>
    <url>/2015/10/28/jackson-bu-fen-xu-lie-hua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>有时候，在序列化/反序列化某个对象时，我们只想要序列化/反序列化部分的字段，而不是全部。在本文中，我们将探讨 <strong>如何控制Jackson序列化/反序列化范围的各种方法</strong>。<br><a id="more"></a></p>
<h2 id="2-public-Field"><a href="#2-public-Field" class="headerlink" title="2. public Field"></a>2. public Field</h2><p>确保字段可序列化和可反序列化的最简单方法是将其可见属性设置为 <strong>public</strong>，如下所示，我们声明一个带有 <em>public</em>，<em>package</em> 和 <em>private</em> 的简单类（不需要 getter/setter 的支持）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDtoAccessLevel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line">    <span class="keyword">int</span> intValue;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">float</span> floatValue;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> booleanValue;</span><br><span class="line">    <span class="comment">// NO setters or getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该类的四个字段中，默认情况下公共 <em>booleanValue</em> 将被序列化为JSON：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDifferentAccessLevels_whenPublic_thenSerializable</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"> </span><br><span class="line">    MyDtoAccessLevel dtoObject = <span class="keyword">new</span> MyDtoAccessLevel();</span><br><span class="line"> </span><br><span class="line">    String dtoAsString = mapper.writeValueAsString(dtoObject);</span><br><span class="line">    assertThat(dtoAsString, not(containsString(<span class="string">"stringValue"</span>)));</span><br><span class="line">    assertThat(dtoAsString, not(containsString(<span class="string">"intValue"</span>)));</span><br><span class="line">    assertThat(dtoAsString, not(containsString(<span class="string">"floatValue"</span>)));</span><br><span class="line"> </span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"booleanValue"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Getter-使-非-public-字段可序列化和可反序列化"><a href="#3-Getter-使-非-public-字段可序列化和可反序列化" class="headerlink" title="3. Getter 使 非 public 字段可序列化和可反序列化"></a>3. <strong>Getter</strong> 使 <strong>非 public</strong> 字段可序列化和可反序列化</h2><p>如果一个字段是 <strong>非 public</strong> 的，又想其支持序列化和反序列化，那么最简单的方法是给其添加一个 <strong>Getter</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDtoWithGetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> intValue;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStringValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中我们给 <em>stringValue</em> 添加了一个 <em>Getter</em> 方法，而 <em>intValue</em> 没有，我们看看序列化的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDifferentAccessLevels_whenGetterAdded_thenSerializable</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"> </span><br><span class="line">    MyDtoGetter dtoObject = <span class="keyword">new</span> MyDtoGetter();</span><br><span class="line"> </span><br><span class="line">    String dtoAsString = mapper.writeValueAsString(dtoObject);</span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"stringValue"</span>));</span><br><span class="line">    assertThat(dtoAsString, not(containsString(<span class="string">"intValue"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到序列化后的数据中包含了 <em>stringValue</em> 而没有  <em>intValue</em> ，我们再看看反序列化的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDifferentAccessLevels_whenGetterAdded_thenDeserializable</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException, JsonMappingException, IOException </span>&#123;</span><br><span class="line">    String jsonAsString = <span class="string">"&#123;\"stringValue\":\"dtoString\"&#125;"</span>;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    MyDtoWithGetter dtoObject = mapper.readValue(jsonAsString, MyDtoWithGetter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    assertThat(dtoObject.getStringValue(), equalTo(<span class="string">"dtoString"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果证明，添加了 <em>Getter</em> 的字段同时具备的了序列化和反序列化的能力。</p>
<h2 id="4-Setter-只使-非-public-字段支持反序列化"><a href="#4-Setter-只使-非-public-字段支持反序列化" class="headerlink" title="4. Setter 只使 非 public 字段支持反序列化"></a>4. Setter 只使 <strong>非 public 字段支持反序列化</strong></h2><p>在上一节展示了 <em>Getter</em> 如何使私有字段既可序列化又可反序列化，这一节讨论一下 <em>Setter</em> 对于序列化/反序列化的影响：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDtoWithSetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> intValue;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValue</span><span class="params">(<span class="keyword">int</span> intValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intValue = intValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accessIntValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<em>intValue</em> 字段此次只有一个 setter，我们测试一下序列化和反序列化操作后的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDifferentAccessLevels_whenSetterAdded_thenDeserializable</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException, JsonMappingException, IOException </span>&#123;</span><br><span class="line">    String jsonAsString = <span class="string">"&#123;\"intValue\":1&#125;"</span>;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"> </span><br><span class="line">    MyDtoSetter dtoObject = mapper.readValue(jsonAsString, MyDtoSetter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    assertThat(dtoObject.anotherGetIntValue(), equalTo(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDifferentAccessLevels_whenSetterAdded_thenStillNotSerializable</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"> </span><br><span class="line">    MyDtoSetter dtoObject = <span class="keyword">new</span> MyDtoSetter();</span><br><span class="line"> </span><br><span class="line">    String dtoAsString = mapper.writeValueAsString(dtoObject);</span><br><span class="line">    assertThat(dtoAsString, not(containsString(<span class="string">"intValue"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的单元测试也表明：<em>setter</em> 只使得字段可反序列化，但不能序列化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 5. 使所有字段全局可序列化</span><br><span class="line"></span><br><span class="line">有些时候，JavaBean并不是我们自己编码的，而是来自第三方，我们无法控制其源码（无法修改其字段的可见性，也无法添加 *Getter/Setter*），这个时候该如何控制字段的序列化策略呢。</span><br><span class="line"></span><br><span class="line">答案是在 *ObjectMapper* 上进行全局配置，如下所示：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">mapper.setVisibility(PropertyAccessor.ALL, Visibility.NONE);</span><br><span class="line">mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);</span><br></pre></td></tr></table></figure></p>
<p>测试用例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDifferentAccessLevels_whenSetVisibility_thenSerializable</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);</span><br><span class="line"> </span><br><span class="line">    MyDtoAccessLevel dtoObject = <span class="keyword">new</span> MyDtoAccessLevel();</span><br><span class="line"> </span><br><span class="line">    String dtoAsString = mapper.writeValueAsString(dtoObject);</span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"stringValue"</span>));</span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"intValue"</span>));</span><br><span class="line">    assertThat(dtoAsString, containsString(<span class="string">"booleanValue"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-序列化-反序列化时忽略某些字段"><a href="#6-序列化-反序列化时忽略某些字段" class="headerlink" title="6.序列化/反序列化时忽略某些字段"></a>6.序列化/反序列化时忽略某些字段</h2><p>有时我们只需要在序列化/反序列化时忽略一些字段，这个时候就可以使用 <em>@JsonIgnore</em> 注解，它用于标记在序列化/反序列化时，忽略掉该字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonProperty</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的测试用例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenFieldTypeIsIgnoredOnlyAtSerialization_whenUserIsSerialized_thenIgnored</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"> </span><br><span class="line">    User userObject = <span class="keyword">new</span> User();</span><br><span class="line">    userObject.setPassword(<span class="string">"thePassword"</span>);</span><br><span class="line"> </span><br><span class="line">    String userAsString = mapper.writeValueAsString(userObject);</span><br><span class="line">    assertThat(userAsString, not(containsString(<span class="string">"password"</span>)));</span><br><span class="line">    assertThat(userAsString, not(containsString(<span class="string">"thePassword"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenFieldTypeIsIgnoredOnlyAtSerialization_whenUserIsDeserialized_thenCorrect</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException </span>&#123;</span><br><span class="line">    String jsonAsString = <span class="string">"&#123;\"password\":\"thePassword\"&#125;"</span>;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"> </span><br><span class="line">    User userObject = mapper.readValue(jsonAsString, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    assertThat(userObject.getPassword(), equalTo(<span class="string">"thePassword"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<em>password</em> 字段并没有被序列化，而由于 <em>@JsonProperty</em> 注解的存在，在反序列化时，仍然会将数据设置到 <em>password</em> 字段中去。</p>
]]></content>
      <tags>
        <tag>Jackson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Bean Validation</title>
    <url>/2015/11/17/java-bean-validation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本文主要介绍标准验证框架<em>JSR 380</em>（也称为<em>Bean Validation 2.0</em>）对于JavaBean的验证功能。</p>
<p>在应用程序中验证用户输入是一个非常常见的要求，Java Bean Validation框架已经成为处理这种逻辑的事实上的标准。<br><a id="more"></a></p>
<h2 id="2-JSR-380"><a href="#2-JSR-380" class="headerlink" title="2. JSR 380"></a>2. JSR 380</h2><p>JSR 380是用于 JavaBean 验证的规范，也是JavaEE的和的JavaSE的一部分，它通过一系列的注解来确保 Bean 符合某些规则，比如 <em>@NotNull</em>，<em>@Min</em>，和<em>@Max</em>。</p>
<p>JSR380 需要Java 8或更高版本，并利用Java 8中添加的新功能（如 type annotation），并支持<em>Optional</em>和<em>LocalDate</em>等新类型，有关规范的完整信息，可以查阅<a href="https://jcp.org/en/jsr/detail?id=380" target="_blank" rel="noopener">JSR 380</a>。</p>
<h2 id="3-依赖"><a href="#3-依赖" class="headerlink" title="3. 依赖"></a>3. 依赖</h2><p>我们可以采用使用Maven或者 Gradle 来配置相应的依赖，本文示例中都采用 Maven。</p>
<h3 id="3-1-Validation-API"><a href="#3-1-Validation-API" class="headerlink" title="3.1 Validation API"></a>3.1 Validation API</h3><p>根据JSR 380规范，<em>validation-api</em>依赖于标准验证API，如下配置所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-Validation-API-参考实现"><a href="#3-2-Validation-API-参考实现" class="headerlink" title="3.2 Validation API 参考实现"></a>3.2 Validation API 参考实现</h3><p><strong>Hibernate Validator是Validation API的参考实现</strong>，要使用它，我们必须添加以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<strong>hibernate-validator完全独立于Hibernate的 ORM </strong>，<em>hibernate-validator</em> 并不会将 ORM 相关的依赖添加到项目中，可以放心的使用。</p>
</blockquote>
<h3 id="3-3-表达式语言依赖关系"><a href="#3-3-表达式语言依赖关系" class="headerlink" title="3.3 表达式语言依赖关系"></a>3.3 表达式语言依赖关系</h3><p>JSR 380为变量插值提供支持，允许在不符合规则的错误消息中使用表达式。要解析这些表达式，我们必须在表达式语言API和该API的实现上添加依赖项。GlassFish提供参考实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.web<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果未添加这些JAR，您将在运行时收到错误消息，如下所示：</p>
<blockquote>
<p><em>HV000183：无法加载’javax.el.ExpressionFactory’。检查您是否在类路径上具有EL依赖项，或使用ParameterMessageInterpolator</em></p>
</blockquote>
<h2 id="4-使用-Validation-Annotations"><a href="#4-使用-Validation-Annotations" class="headerlink" title="4. 使用 Validation Annotations"></a>4. 使用 Validation Annotations</h2><p>我们将使用<em>User</em> bean作为主要示例，并为其添加一些简单的验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.AssertTrue;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Max;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Email;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"Name cannot be null"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@AssertTrue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> working;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">10</span>, max = <span class="number">200</span>, message </span><br><span class="line">      = <span class="string">"About Me must be between 10 and 200 characters"</span>)</span><br><span class="line">    <span class="keyword">private</span> String aboutMe;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">18</span>, message = <span class="string">"Age should not be less than 18"</span>)</span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">150</span>, message = <span class="string">"Age should not be greater than 150"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"Email should be valid"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard setters and getters</span></span><br></pre></td></tr></table></figure>
<p>示例中使用的所有注释都是标准的JSR注释：</p>
<ul>
<li><strong>@NotNull</strong> - 验证属性值不为 <em>null</em></li>
<li><strong>@AssertTrue</strong> - 验证属性值是否为 <em>true</em></li>
<li><strong>@Size</strong> - 验证带注属性长度/大小是否在 <em>min</em>和 <em>max</em>之间，可以应用于 <em>String</em>， <em>Collection</em>， <em>Map</em>和数组属性</li>
<li><strong>@Min</strong> - 验证属性的值是否小于 <em>value</em>属性</li>
<li><strong>@Max</strong> - 验证属性的值是否大于 <em>value</em>属性</li>
<li><strong><em>@Email</em></strong> - 验证属性是否为有效的电子邮件地址</li>
</ul>
<p>某些注释接受其他属性，但<em>message </em>属性对所有属性都是通用的。这是当相应属性的值未通过验证时通常会提示的信息。</p>
<p>您还可以在JSR中找到的一些其他注解，如：</p>
<ul>
<li><strong><em>@NotEmpty</em></strong> - 验证属性不为null或为空; 可以应用于 <em>String</em>， <em>Collection</em>， <em>Map</em>或 <em>Array</em>值</li>
<li><strong><em>@NotBlank</em></strong> - 只能应用于文本值，验证该属性不是null或空格</li>
<li><strong><em>@Positive</em></strong>和 <strong><em>@PositiveOrZero</em></strong> - 适用于数值，验证它们是严格正数（包括0）</li>
<li><strong><em>@Negative</em></strong>和 <strong><em>@NegativeOrZero</em></strong> - 适用于数值，验证它们是严格为负数（包括0）</li>
<li><strong><em>@Past</em></strong>和 <strong><em>@PastOrPresent</em></strong> - 适用于日期值（包括Java 8中添加的日期类型），验证它们是过去（包括现在）; </li>
<li><strong>*@Future</strong>和<strong>@FutureOrPresent*</strong> - 适用于日期值（包括Java 8中添加的日期类型），验证它们是将来（包括现在）; </li>
</ul>
<p><strong>验证注解也可以应用于集合的元素</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="meta">@NotBlank</span> String&gt; preferences;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，所有添加到 <em>preferences</em> 中的值都将进行 <em>@NotBlank</em> 的校验。</p>
<p>同时，该规范<strong>还支持</strong> Java 8中的新<strong><em>Optional</em></strong>类型，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rivate LocalDate dateOfBirth;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Optional&lt;<span class="meta">@Past</span> LocalDate&gt; getDateOfBirth() &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(dateOfBirth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，验证框架将自动解包<em>LocalDate</em>值并对其进行验证。</p>
<h2 id="5-程序验证"><a href="#5-程序验证" class="headerlink" title="5. 程序验证"></a>5. 程序验证</h2><p>一些框架（ 例如Spring）只需使用注释就可以通过简单的方法触发验证过程。同时，我们也可以手动以以编程方式进行设置与交互：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">Validator validator = factory.getValidator();</span><br></pre></td></tr></table></figure>
<p>要验证bean，我们必须首先拥有<em>Validator</em>对象，该对象使用<em>ValidatorFactory</em>构造。</p>
<h3 id="5-1-定义Bean"><a href="#5-1-定义Bean" class="headerlink" title="5.1 定义Bean"></a>5.1 定义Bean</h3><p>我们现在要设置这个无效用户——<em>name = null</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setWorking(<span class="keyword">true</span>);</span><br><span class="line">user.setAboutMe(<span class="string">"Its all about me!"</span>);</span><br><span class="line">user.setAge(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-验证Bean"><a href="#5-2-验证Bean" class="headerlink" title="5.2 验证Bean"></a>5.2 验证Bean</h3><p>现在我们有了一个<em>Validator</em>，我们可以通过将它传递给<em>validate</em>方法来验证我们的bean 。任何违反<em>User</em>对象中定义的约束的行为都将作为<em>Set</em>返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;ConstraintViolation&lt;User&gt;&gt; violations = validator.validate(user);</span><br></pre></td></tr></table></figure>
<p>通过迭代 <em>ConstraintViolation</em>，我们可以使用<em>getMessage</em>方法获取所有违反规则的提示信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ConstraintViolation&lt;User&gt; violation : violations) &#123;</span><br><span class="line">    log.error(violation.getMessage()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的示例中（<em>ifNameIsNull_nameValidationFails</em>），该集合将包含一个<em>ConstraintViolation</em>，消息” <em>Name not not null</em>  “。</p>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>本文重点介绍了标准 JSR380 的相关规约，并通过注解演示了如何设置 JavaBean 的校验规则，以及通过编程的方式获取所有违反规则的错误提示信息。</p>
]]></content>
      <tags>
        <tag>JSR380</tag>
        <tag>JavaBean Validation</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaConfig</title>
    <url>/2018/06/17/javaconfig-jie-shao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JavaConfig的历史"><a href="#JavaConfig的历史" class="headerlink" title="JavaConfig的历史"></a>JavaConfig的历史</h3><p>　　Spring在最初的时候，一直是采用XML作为容器配置的手段，但随着现代项目的复杂性越来越高，Spring项目大量的烂用XML反而变成一个灾难，遭受了非常严励的一个批评。由于Spring会把几乎所有的业务类都以Bean的形式配置在XML文件中，造成了大量的XML文件。使用XML来配置Bean失去了编译时的类型安全检查。大量的XML配置使得整个项目变得更加复杂。Rod  Johnson也注意到了这个非常严重的问题。当随着JAVA EE  5.0的发布，其中引入了一个非常重要的特性——<strong>Annotations(注解)</strong>。注解是源代码的标签，这些标签可以在源代码层进行处理或通过编译器把它融入到class文件中。在JAVA  EE  5以后的版本中，注解成为了一个主要的配置选项。</p>
<a id="more"></a>
<p>　　相对于传统的XML配置方式，<strong>JavaConfig</strong>有如下的优势：</p>
<ol>
<li>它是纯Java的配置方式，这意味着你可以利用所有面向对象的优势，重用、继承、多态以及类型检查等。</li>
<li>拥有对于实例及其依赖更完全的控制权。</li>
<li>拥有更好的IDE支持。</li>
<li>配置与业务逻辑是在<strong>一起</strong>的，而不是分散成代码和配置。</li>
<li>当然，它仍然是和 XML 兼容的，你可以同时在项目中使用 XML 和 <strong>JavaConfig</strong> 进行配置。</li>
</ol>
<h3 id="常见的JavaConfig用法"><a href="#常见的JavaConfig用法" class="headerlink" title="常见的JavaConfig用法"></a>常见的JavaConfig用法</h3><p>​    我想大部分同学都已经使用<strong>JavaConfig</strong>来注解我们的SpringBean了，比如我们常用的：</p>
<table>
<thead>
<tr>
<th>@Component</th>
<th>通用组件，可以标注在任意的SprinbBean上</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Repository</td>
<td>通常作为存储层的Bean定义，派生自 @Component</td>
</tr>
<tr>
<td>@Service</td>
<td>通常作为服务层的Bean定义，派生自 @Component</td>
</tr>
<tr>
<td>@Controller</td>
<td>通常作为控制层的Bean定义，派生自 @Component</td>
</tr>
</tbody>
</table>
<p>​    当然，以上所有的注解都必须配合<code>ComponentScan</code>才能生效，比如我们会在XML配置中配置如下的节点：<code>&lt;component-scan base-package=&quot;packages.to.scan&quot;</code>或者更加 <strong>JavaConfig</strong> 的做法是通过Java代码来声明，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"packages.to.scan"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Configuration-的用法"><a href="#Configuration-的用法" class="headerlink" title="@Configuration 的用法"></a>@Configuration 的用法</h3><p>​    <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>等这些注解就不讲解了，实在太过于简单和常见，我们主要讲解一下<code>@Configuration</code>的用法，习惯于用XML配置的同学可能对这个注解了解得比较少，也很少会使用。</p>
<p>​    在上面的代码中我们看到一个注解<code>@Configuration</code>，这个注解是Spring基于<strong>JavaConfig</strong>配置的核心，这个注解的说明如下：</p>
<blockquote>
<p>Indicates that a class declares one or more {@link Bean @Bean} methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime</p>
</blockquote>
<p>​    Spring会去解析标注这个注解的类，将它作为Spring容器的配置入口，它将会通过一系列的方法定义SpringBean。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ExternalObjectA <span class="title">externalObjectA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ExternalObjectA();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ExternalObjectB <span class="title">externalObjectB1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ExternalObjectB(externalObjectA());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ExternalObjectB <span class="title">externalObjectB2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ExternalObjectB(externalObjectA());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这段代码就是通过<strong>JavaConfig</strong>定义了三个SpringBean，需要注意的是：</p>
<ol>
<li><p><code>ExternalObjectB</code>类型的Bean注册了<strong><em>2</em></strong>个，分别来自于<code>externalObjectB1()</code>方法的调用和<code>externalObjectB2()</code>方法的调用，它们的名字分别来自于<code>@Bean</code>对应的方法名。</p>
</li>
<li><p><code>ExternalObjectA</code>被<code>externalObjectB1</code>和<code>externalObjectB2</code>以参数的方式依赖。</p>
</li>
<li><p>由于<code>ExternalObjectA</code>也被注解为<code>@Bean</code>，同时，默认的SpringBean的<strong>Scope是Singleton</strong>，所以虽然被<strong><em>2</em></strong>个Bean依赖以参数方式调用了<strong><em>2</em></strong>次，但实际上<code>externalObjectA()</code>只会执行一次。</p>
</li>
</ol>
<p>通过以下的代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Import的用法"><a href="#Import的用法" class="headerlink" title="@Import的用法"></a>@Import的用法</h3><p>​    在现实的编码过程中，我们通常会将所需要的SpringBean分门别类的在不同的<code>@Configuration</code>类中进行声明配置，而不是写一个超级大的配置类来管理所有的SpringBean，有点类似于我们在XML配置时写好几个文件比如<code>application-context-dao.xml</code>，<code>application-context-service.xml</code>之类的。</p>
<p>​    在这种情况下，我们就需要在不同的场景组合不同的配置类，这个组合的注解就是<code>@Import</code>，该注解可以将其它的<code>@Configuration</code>导入到当前的配置中。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; SpringConfig1<span class="class">.<span class="keyword">class</span>, <span class="title">SpringConfig2</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JavaConfigImport</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    同时，如果其它的配置是在XML文件中，也可以通过<code>@ImportResource</code>来导入，也是非常方便的，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classptah: /application-context-*.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfigImportResource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>JavaConfig</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8的流式 API</title>
    <url>/2016/05/02/java8-de-liu-shi-api/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本文主要介绍Java8中流的创建和使用，该<em>Stream</em> 并不是指 IO 中的输入输出（虽然在某些场景和概念上有些类似），而是Java8中带来的关于集合操作相关的新 API 。</p>
<h2 id="2-流创建"><a href="#2-流创建" class="headerlink" title="2. 流创建"></a>2. 流创建</h2><p>有许多方法可以创建不同源的流实例。一旦创建，实例<strong>将不会修改其源</strong>，因此允许从单个源创建多个实例。</p>
<h3 id="2-1-空流"><a href="#2-1-空流" class="headerlink" title="2.1 空流"></a>2.1 空流</h3><p>如果创建空流，则应使用<strong>empty()</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamEmpty = Stream.empty();</span><br></pre></td></tr></table></figure>
<p>通常情况下，在创建时使用<em>empty()</em>方法以避免为没有元素的流返回<em>null</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stream&lt;String&gt; <span class="title">streamOf</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list == <span class="keyword">null</span> || list.isEmpty() ? Stream.empty() : list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-收集流"><a href="#2-2-收集流" class="headerlink" title="2.2 收集流"></a>2.2 收集流</h3><p>Stream也可以创建任何类型的<em>Collection</em>（<em>Collection，List，Set</em>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">Stream&lt;String&gt; streamOfCollection = collection.stream();</span><br></pre></td></tr></table></figure>
<h3 id="2-3-数组流"><a href="#2-3-数组流" class="headerlink" title="2.3 数组流"></a>2.3 数组流</h3><p>Array也可以是Stream的源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamOfArray = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>
<p>它们也可以从现有数组或数组的一部分创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; streamOfArrayFull = Arrays.stream(arr);</span><br><span class="line">Stream&lt;String&gt; streamOfArrayPart = Arrays.stream(arr, <span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Stream-builder"><a href="#2-4-Stream-builder" class="headerlink" title="2.4 Stream.builder()"></a>2.4 Stream.builder()</h3><p><strong>使用构建器时，应在语句的右侧部分另外指定所需类型</strong>，否则<em>build()</em>方法将创建<em>Stream <object></object></em> 的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamBuilder = Stream.&lt;String&gt;builder().add(<span class="string">"a"</span>).add(<span class="string">"b"</span>).add(<span class="string">"c"</span>).build();</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Stream-generate"><a href="#2-5-Stream-generate" class="headerlink" title="2.5 Stream.generate()"></a>2.5 Stream.generate()</h3><p>的<strong>generate()</strong>方法接受 <em>Supplier<t></t></em> 为元素生成。由于结果流是无限的，开发人员应指定所需的大小，否则<em>generate()</em>方法将一直有效，直到达到内存限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamGenerated = Stream.generate(() -&gt; <span class="string">"element"</span>).limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个包含 10 个字符串的序列，其值为<em>“element”</em>。</p>
<h3 id="2-6-Stream-iterate"><a href="#2-6-Stream-iterate" class="headerlink" title="2.6 Stream.iterate()"></a>2.6 Stream.iterate()</h3><p>创建无限流的另一种方法是使用<strong>iterate()</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; streamIterated = Stream.iterate(<span class="number">40</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>结果流的第一个元素是<em>iterate()</em>方法的第一个参数。为了创建每个后续元素，指定的函数将应用于前一个元素。在上面的示例中，第二个元素将是42。</p>
<h3 id="2-7-原始流"><a href="#2-7-原始流" class="headerlink" title="2.7 原始流"></a>2.7 原始流</h3><p>Java 8提供了从三种基本类型创建流的可能性：<em>int</em>，<em>long</em>和<em>double</em>。由于<em>Stream <t></t></em>是一个通用接口，并且无法使用基元作为泛型的类型参数，因此创建了三个新的特殊接口：<em>IntStream</em>，<em>LongStream，</em>DoubleStream*。</p>
<p>使用新的接口减少了不必要的自动装箱，从而提高效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStream = IntStream.range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">LongStream longStream = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><strong><em> range(int startInclusive, int endExclusive)</em></strong>方法创建从所述第一参数与第二参数的有序流。它增加后续元素的值，步长等于1。结果不包括最后一个参数，它只是序列的上限。</p>
<p>所述<strong><em> rangeClosed(int startInclusive, int endInclusive) </em></strong> 方法做同样的只有一个差别-所述第二元素被包括。这两种方法可用于生成三种类型的基元流中的任何一种。</p>
<p>从Java 8开始，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html" target="_blank" rel="noopener"><em>Random</em></a>类为生成基元流提供了方法。例如，以下代码创建一个<em>DoubleStream</em>，它有三个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">DoubleStream doubleStream = random.doubles(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-8-字符串流"><a href="#2-8-字符串流" class="headerlink" title="2.8 字符串流"></a>2.8 字符串流</h3><p><em>String</em>也可以用作创建流的源。</p>
<p>借助<em>String</em>类的<em>chars()</em>方法。由于没有接口，<em>CharStream</em>在JDK中用<em>IntStream</em>表示字符流代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntStream streamOfChars = &quot;abc&quot;.chars();</span><br></pre></td></tr></table></figure>
<p>以下示例根据指定的<em>RegEx</em>将<em>String</em>拆分为子字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamOfString = Pattern.compile(<span class="string">", "</span>).splitAsStream(<span class="string">"a, b, c"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-9-文件流"><a href="#2-9-文件流" class="headerlink" title="2.9 文件流"></a>2.9 文件流</h3><p>Java NIO类<em>Files</em>允许通过<em>lines()</em>方法生成文本文件的<em>Stream <string></string></em>。文本的每一行都成为流的一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"C:\\file.txt"</span>);</span><br><span class="line">Stream&lt;String&gt; streamOfStrings = Files.lines(path);</span><br><span class="line">Stream&lt;String&gt; streamWithCharset = Files.lines(path, Charset.forName(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>
<p>该<em>Charset </em>可以被指定为所述的自变量<em>line()</em>方法。</p>
<h2 id="3-引用Stream"><a href="#3-引用Stream" class="headerlink" title="3. 引用Stream"></a>3. 引用<strong>Stream</strong></h2><p>流的特点是顺序的不可逆访问，意思就是当你执行了某些方法（终结操作）导致流的遍历到了最后一个元素时，后续的流将不可用了。如以下的代码所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).filter(element -&gt; element.contains(<span class="string">"b"</span>));</span><br><span class="line">Optional&lt;String&gt; anyElement = stream.findAny();</span><br></pre></td></tr></table></figure>
<p><em>findAny()</em>将遍历整个流（直至<strong>最后一个元素</strong>），之后操作后尝试重用相同的引用将触发<em>IllegalStateException</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; firstElement = stream.findFirst();</span><br></pre></td></tr></table></figure>
<p>由于<em>IllegalStateException</em>是<em>RuntimeException</em>，编译器不会发出有关问题的信号。因此，记住<strong>Java 8 不能重用</strong>是非常重要的。</p>
<p>这种行为是合乎逻辑的，因为流被设计为提供将有限的操作序列应用于功能样式中的元素源但不存储元素的能力。</p>
<p>因此，为了使以前的代码正常工作，应该进行一些更改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; elements = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).filter(element -&gt; element.contains(<span class="string">"b"</span>)).collect(Collectors.toList());</span><br><span class="line">Optional&lt;String&gt; anyElement = elements.stream().findAny();</span><br><span class="line">Optional&lt;String&gt; firstElement = elements.stream().findFirst();</span><br></pre></td></tr></table></figure>
<h2 id="4-流管道"><a href="#4-流管道" class="headerlink" title="4. 流管道"></a>4. 流管道</h2><p>要对数据源的元素执行一系列操作并聚合它们的结果，需要三个部分 - <strong>源</strong>，<strong>中间操作</strong>和<strong>终结操作。</strong></p>
<p>中间操作返回新的修改流。例如，要创建一个缺少部分元素的新流，应使用<em>skip()</em>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; onceModifiedStream = Stream.of(<span class="string">"abcd"</span>, <span class="string">"bbcd"</span>, <span class="string">"cbcd"</span>).skip(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>如果需要多个修改，则可以链接中间操作。假设我们还需要用前几个字符的子字符串替换当前<em>Stream <string></string></em>的每个元素。这将通过链接<em>skip()</em>和<em>map()</em>方法来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; twiceModifiedStream = stream.skip(<span class="number">1</span>).map(element -&gt; element.substring(<span class="number">0</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>如您所见，<em>map()</em>方法将lambda表达式作为参数。</p>
<p>流本身是没有价值的，用户感兴趣的真实事物是终结操作的结果，它可以是某种类型的值或应用于流的每个元素的动作。<strong>每个流只能使用一个终结操作</strong>。</p>
<p>使用流的正确和最方便的方式是<strong>流管道，它是流源，中间操作和终端操作的链</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"abc1"</span>, <span class="string">"abc2"</span>, <span class="string">"abc3"</span>);</span><br><span class="line"><span class="keyword">long</span> size = list.stream().skip(<span class="number">1</span>).map(element -&gt; element.substring(<span class="number">0</span>, <span class="number">3</span>)).sorted().count();</span><br></pre></td></tr></table></figure>
<h2 id="5-懒调用"><a href="#5-懒调用" class="headerlink" title="5. 懒调用"></a>5. 懒调用</h2><p><strong>中间操作是懒惰的</strong>，这意味着<strong>只有在终结操作执行需要时才会调用它们</strong>。</p>
<p>为了证明这一点，假设我们有方法<em>wasCalled()</em>，它在每次调用时递增一个内部计数器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> counter;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wasCalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<em>filter()</em>方法中调用<em>wasCalled()</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(“abc1”, “abc2”, “abc3”);</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line">Stream&lt;String&gt; stream = list.stream().filter(element -&gt; &#123;</span><br><span class="line">    wasCalled();</span><br><span class="line">    <span class="keyword">return</span> element.contains(<span class="string">"2"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于我们有三个元素的来源，我们预期方法<em>filter()</em>将被调用三次，<em>counter</em>变量的值将是3。但实际上运行此代码根本不会改变<em>counter</em>，它仍然是零，所以，<em>filter()</em>方法甚至没有被调用过一次。原因 - 缺少终结操作。</p>
<p>让我们通过添加<em>map()</em>操作和终端操作 - <em>findFirst()来</em>重写这段代码。我们还将添加一种能够通过记录来跟踪方法调用顺序的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; stream = list.stream().filter(element -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"filter() was called"</span>);</span><br><span class="line">    <span class="keyword">return</span> element.contains(<span class="string">"2"</span>);</span><br><span class="line">&#125;).map(element -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"map() was called"</span>);</span><br><span class="line">    <span class="keyword">return</span> element.toUpperCase();</span><br><span class="line">&#125;).findFirst();</span><br></pre></td></tr></table></figure>
<p>结果日志显示<em>filter()</em>方法被调用两次而<em>map()</em>方法只调用一次。这是因为管道垂直执行。在我们的示例中，流的第一个元素不满足filter的 predicate ，第二次调用<em>filter()</em>方法时满足条件，我们通过管道进入<em>map()</em>方法，同时仅仅只需要一个元素满足<em>findFirst()</em>，所以后缀后续的调用都将中止。在这个特定的例子中，懒调用避免了 <em>filter()</em>，<em>map()</em> 两个方法调用 。</p>
<h2 id="6-执行顺序"><a href="#6-执行顺序" class="headerlink" title="6. 执行顺序"></a>6. 执行顺序</h2><p>从性能的角度来看，<strong>正确的执行顺序是流管道操作中非常重要的一环</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> size = list.stream().map(element -&gt; &#123;</span><br><span class="line">    wasCalled();</span><br><span class="line">    <span class="keyword">return</span> element.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">&#125;).skip(<span class="number">2</span>).count();</span><br></pre></td></tr></table></figure>
<p>执行此代码会将计数器的值增加三。这意味着流的<em>map()</em>方法被调用了三次。但是最终我们<em>skip(2)</em>，只需要的结果流只有一个元素，我们无故地执行了两次昂贵的<em>map()</em>操作。</p>
<p>如果我们改变了<em>skip() </em>和<em>map()</em>方法的顺序，<em>计数器</em>将只会增加一次，因此，方法<em>map()</em>将只调用一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> size = list.stream().skip(<span class="number">2</span>).map(element -&gt; &#123;</span><br><span class="line">    wasCalled();</span><br><span class="line">    <span class="keyword">return</span> element.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">&#125;).count();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优化规则：<strong>减少流大小的中间操作应该放在应用于每个元素的操作之前</strong>。因此，在流管道的顶部保留<em>skip()</em>，<em>filter()</em>，<em>distinct()</em>等方法。</p>
</blockquote>
<h2 id="7-Stream-Reducation"><a href="#7-Stream-Reducation" class="headerlink" title="7. Stream Reducation"></a>7. Stream Reducation</h2><p>API有许多终结操作，它们将流聚合到类型或基元，例如<em>count()</em>，<em>max()，</em>min()，<em>sum()</em>，<em>但这些操作依赖于预先定义好的</em>reduce()<em>实现机制。我们开发过程中如何实现这一点呢，答案是使用：- </em>reduce()*<em>和</em>collect()*方法。</p>
<h3 id="7-1-reduce"><a href="#7-1-reduce" class="headerlink" title="7.1 reduce()"></a>7.1 <em>reduce()</em></h3><p>这种方法有三种变体，它们的签名和返回类型不同。它们可以具有以下参数：</p>
<ul>
<li><p><strong>identity</strong>：累加器的初始值或者如果流为空且没有任何可累积的默认值;</p>
</li>
<li><p><strong>accumulator</strong>：一个指定元素聚合逻辑的函数。当累加器为每个减少步骤创建一个新值时，新值的数量等于流的大小，只有最后一个值是有用的。这对性能不是很好。</p>
</li>
<li><p><strong>combiner</strong>：聚合累加器结果的函数。仅在并行模式下调用组合器以减少来自不同线程的累加器的结果。</p>
</li>
</ul>
<p>那么，让我们看看这三种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OptionalInt reduced = IntStream.range(<span class="number">1</span>, <span class="number">4</span>).reduce((a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>
<p><em>reduced</em> = 6（1 + 2 + 3）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> reducedTwoParams = IntStream.range(<span class="number">1</span>, <span class="number">4</span>).reduce(<span class="number">10</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>
<p><em>reducedTwoParams</em> = 16（10 + 1 + 2 + 3）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> reducedParams = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .reduce(<span class="number">10</span>, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">"combiner was called"</span>);</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果与前面的例子（16）中的结果相同，这意味着没有调用该<em>combiner</em>。要使<em>combiner</em>工作，流应该是并行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> reducedParallel = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).parallelStream()</span><br><span class="line">    .reduce(<span class="number">10</span>, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">       log.info(<span class="string">"combiner was called"</span>);</span><br><span class="line">       <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的结果是不同的（36），并且<em>combiner</em>被调用两次。在这里，还原的工作方式如下算法：<em>accumulator</em>由流的每一个元素加入到跑了三次<em>identity </em>到流的每一个元素。这些动作都在并行进行。结果，他们有（10 + 1 = 11; 10 + 2 = 12; 10 + 3 = 13;）。现在<em>combiner</em>可以合并这三个结果。它需要两次迭代（12 + 13 = 25; 25 + 11 = 36）。</p>
<h3 id="7-2-collect"><a href="#7-2-collect" class="headerlink" title="7.2 collect()"></a>7.2 <em>collect()</em></h3><p>还可以通过另一个终结操作<em>collection()</em>方法来执行流的 reduce。它接受<em>Collector</em>类型的参数，该参数指定reduce的机制。已经为大多数常见操作创建了预定义的收集器。</p>
<p>在本节中，我们将使用以下<em>List</em>作为所有流的源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Product&gt; productList = Arrays.asList(<span class="keyword">new</span> Product(<span class="number">23</span>, <span class="string">"potatoes"</span>),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">14</span>, <span class="string">"orange"</span>), <span class="keyword">new</span> Product(<span class="number">13</span>, <span class="string">"lemon"</span>),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">23</span>, <span class="string">"bread"</span>), <span class="keyword">new</span> Product(<span class="number">13</span>, <span class="string">"sugar"</span>));</span><br></pre></td></tr></table></figure>
<p><strong>将流转换为集合（Collection, List or Set）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; collectorCollection =  productList.stream().map(Product::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><strong>Reduce 成字符串：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String listToString = productList.stream().map(Product::getName).collect(Collectors.joining(<span class="string">", "</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br></pre></td></tr></table></figure>
<p><em>joiner()</em>方法可以有一至三个参数（delimiter, prefix, suffix）。使用<em>joiner()</em>的最方便的地方在于 开发人员不需要检查流是否到达它的末尾以应用后缀而不是应用分隔符。<em>Collector </em>将负责这一点。</p>
<p><strong>求 Stream 所有数字元素的平均值：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> averagePrice = productList.stream().collect(Collectors.averagingInt(Product::getPrice));</span><br></pre></td></tr></table></figure>
<p><strong>求 Stream 所有数字元素的平均值：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> summingPrice = productList.stream().collect(Collectors.summingInt(Product::getPrice));</span><br></pre></td></tr></table></figure>
<p>方法<em>averagingXX()，summingXX()</em>和<em>summarizingXX()</em>可以使用原始类型（<em>int</em>，<em>long，</em>double<em>）也可以使用它们的包装类（</em>Integer<em>，</em>Long，<em>Double</em>）。这些方法的另一个强大功能是提供映射。因此，开发人员不需要在<em>collect()</em>方法之前使用额外的<em>map()</em>操作。</p>
<p><strong>收集有关流元素的统计信息：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntSummaryStatistics statistics = productList.stream().collect(Collectors.summarizingInt(Product::getPrice));</span><br></pre></td></tr></table></figure>
<p>通过使用<em>IntSummaryStatistics</em>类型的结果实例，开发人员可以通过应用<em>toString()</em>方法创建统计报告。结果是：*”IntSummaryStatistics {count = 5，sum = 86，min = 13，average = 17,200000，max = 23}”。</p>
<p>通过应用方法<em>getCount()</em>，<em>getSum()</em>，<em>getMin()</em>，<em>getAverage()</em>，<em>getMax()</em>，从这个对象中提取<em>count，sum，min，average</em>的单独值也很容易*，所有这些值都可以从单个管道中提取。</p>
<p><strong>根据指定的函数对流的元素进行分组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Product&gt;&gt; collectorMapOfLists = productList.stream().collect(Collectors.groupingBy(Product::getPrice));</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，流被 reduce 为<em>Map</em>，按价格对所有产品进行分组。</p>
<p><strong>根据某些 Predicatre 将流的元素分成组：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Product&gt;&gt; mapPartioned = productList.stream().collect(Collectors.partitioningBy(element -&gt; element.getPrice() &gt; <span class="number">15</span>));</span><br></pre></td></tr></table></figure>
<p><strong>让 <em>Collector</em> 执行额外的转换：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Product&gt; unmodifiableSet = productList.stream()</span><br><span class="line">	.collect(Collectors.collectingAndThen(Collectors.toSet(), Collections::unmodifiableSet));</span><br></pre></td></tr></table></figure>
<p>在这种特殊情况下，<em>Collector</em>已将流转换为<em>Set</em>，然后从中创建不可修改的<em>Set</em>。</p>
<p><strong>定制 Collector ：</strong></p>
<p>如果出于某种原因，应该创建自定义Collector，最简单且的方法是使用<em>Collector.of)</em>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Product, ?, LinkedList&lt;Product&gt;&gt; toLinkedList =</span><br><span class="line">  Collector.of(LinkedList::<span class="keyword">new</span>, LinkedList::add, </span><br><span class="line">    (first, second) -&gt; &#123; </span><br><span class="line">       first.addAll(second); </span><br><span class="line">       <span class="keyword">return</span> first; </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">LinkedList&lt;Product&gt; linkedListOfPersons = productList.stream().collect(toLinkedList);</span><br></pre></td></tr></table></figure>
<p>在此示例中，<em>Collector</em>的实例已 reduce 为 <em>LinkedList <persone></persone></em>。</p>
<h2 id="Parallel-Streams"><a href="#Parallel-Streams" class="headerlink" title="Parallel Streams"></a>Parallel Streams</h2><p>在Java 8之前，并行化很复杂。新兴的 <em>ExecutorService</em>和<em>ForkJoin</em> 简化了一点点，但他们仍然应该牢记如何创建一个具体的 Executor。Java 8引入了一种在功能风格中实现并行性的方法。</p>
<p>API允许创建并行流，以并行模式执行操作。当流的源是<em>Collection</em>或<em>array </em>时，可以在<strong>parallelStream()</strong>方法的帮助下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Product&gt; streamOfCollection = productList.parallelStream();</span><br><span class="line"><span class="keyword">boolean</span> isParallel = streamOfCollection.isParallel();</span><br><span class="line"><span class="keyword">boolean</span> bigPrice = streamOfCollection</span><br><span class="line">  .map(product -&gt; product.getPrice() * <span class="number">12</span>)</span><br><span class="line">  .anyMatch(price -&gt; price &gt; <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>如果流的源不是<em>Collection</em>或<em>array</em>，则应使用<strong>parallel()</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStreamParallel = IntStream.range(<span class="number">1</span>, <span class="number">150</span>).parallel();</span><br><span class="line"><span class="keyword">boolean</span> isParallel = intStreamParallel.isParallel();</span><br></pre></td></tr></table></figure>
<p>Stream API自动使用<em>ForkJoin</em>框架并行执行操作。默认情况下，将使用公共线程池，并且无法（至少现在）为其分配一些自定义线程池。<a href="https://github.com/pivovarit/parallel-collectors" target="_blank" rel="noopener">这可以通过使用一组自定义的并行收集器来克服。</a></p>
<p>在并行模式下使用流时，避免阻塞操作并在任务需要相同的执行时间时使用并行模式（如果一个任务比另一个任务持续时间长，则可能会减慢整个应用程序的工作流程）。</p>
<p>可以使用<em>sequential()</em>方法将并行模式的流转换回顺序模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStreamSequential = intStreamParallel.sequential();</span><br><span class="line"><span class="keyword">boolean</span> isParallel = intStreamSequential.isParallel();s</span><br></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Stream API是一个功能强大但易于理解的工具集，用于处理元素序列。它允许我们减少大量的模板代码，创建更易读的程序，并在正确使用时提高应用程序的工作效率。</p>
<blockquote>
<p>在本文中显示的大多数代码示例中，流是未被消费的（我们没有应用<em>close()</em>方法或终结操作）。在真实的应用程序中，<strong>不要留下未被消费的流，因为这将导致内存泄漏。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>Java8</tag>
        <tag>Strem API</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程程序设计详细解析</title>
    <url>/2008/01/17/java-duo-xian-cheng-cheng-xu-she-ji-xiang-xi-jie-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一、理解多线程"><a href="#一、理解多线程" class="headerlink" title="一、理解多线程"></a>一、理解多线程</h4><p>多线程是这样一种机制，它允许在程序中并发执行多个指令流，每个指令流都称为一个线程，彼此间互相独立。 </p>
<p>线程又称为轻量级进程，它和进程一样拥有独立的执行控制，由操作系统负责调度，区别在于线程没有独立的存储空间，而是和所属进程中的其它线程共享一个存储空间，这使得线程间的通信远较进程简单。 </p>
<p>多个线程的执行是并发的，也就是在逻辑上“同时”，而不管是否是物理上的“同时”。如果系统只有一个CPU，那么真正的“同时”是不可能的，但是由于CPU的速度非常快，用户感觉不到其中的区别，因此我们也不用关心它，只需要设想各个线程是同时执行即可。 </p>
<p>多线程和传统的单线程在程序设计上最大的区别在于，由于各个线程的控制流彼此独立，使得各个线程之间的代码是乱序执行的，由此带来的线程调度，同步等问题，将在以后探讨。 </p>
<h4 id="二、在Java中实现多线程"><a href="#二、在Java中实现多线程" class="headerlink" title="二、在Java中实现多线程"></a>二、在Java中实现多线程</h4><p>我们不妨设想，为了创建一个新的线程，我们需要做些什么？很显然，我们必须指明这个线程所要执行的代码，而这就是在Java中实现多线程我们所需要做的一切！ </p>
<p>真是神奇！Java是如何做到这一点的？通过类！作为一个完全面向对象的语言，Java提供了类java.lang.Thread来方便多线程编程，这个类提供了大量的方法来方便我们控制自己的各个线程，我们以后的讨论都将围绕这个类进行。 </p>
<p>那么如何提供给 Java 我们要线程执行的代码呢？让我们来看一看 Thread 类。Thread 类最重要的方法是run()，它为Thread类的方法start()所调用，提供我们的线程所要执行的代码。为了指定我们自己的代码，只需要覆盖它！ </p>
<ul>
<li><p>方法一：继承 Thread 类。覆盖方法 run()，我们在创建的 Thread 类的子类中重写 run() ,加入线程所要执行的代码即可。下面是一个例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>, number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        number = num;</span><br><span class="line">        System.out.println</span><br><span class="line">                (<span class="string">"创建线程 "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println</span><br><span class="line">                    (<span class="string">"线程 "</span> + number + <span class="string">":计数 "</span> + count);</span><br><span class="line">            <span class="keyword">if</span> (++count == <span class="number">6</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> MyThread(i + <span class="number">1</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法简单明了，符合大家的习惯，但是，它也有一个很大的缺点，那就是如果我们的类已经从一个类继承（如小程序必须继承自 Applet 类），则无法再继承 Thread 类，这时如果我们又不想建立一个新的类，应该怎么办呢？ </p>
<p>我们不妨来探索一种新的方法：我们不创建Thread类的子类，而是直接使用它，那么我们只能将我们的方法作为参数传递给 Thread 类的实例，有点类似回调函数。但是 Java 没有指针，我们只能传递一个包含这个方法的类的实例。 </p>
<p>那么如何限制这个类必须包含这一方法呢？当然是使用接口！（虽然抽象类也可满足，但是需要继承，而我们之所以要采用这种新方法，不就是为了避免继承带来的限制吗？） </p>
<p>Java 提供了接口 java.lang.Runnable 来支持这种方法。 </p>
</li>
<li><p>方法二：实现 Runnable 接口。Runnable接口只有一个方法run()，我们声明自己的类实现Runnable接口并提供这一方法，将我们的线程代码写入其中，就完成了这一部分的任务。但是Runnable接口并没有任何对线程的支持，我们还必须创建Thread类的实例，这一点通过Thread类的构造函数 public Thread(Runnable target);来实现。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>, number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        number = num;</span><br><span class="line">        System.out.println(<span class="string">"创建线程 "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println</span><br><span class="line">                    (<span class="string">"线程 "</span> + number + <span class="string">":计数 "</span> + count);</span><br><span class="line">            <span class="keyword">if</span> (++count == <span class="number">6</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i + <span class="number">1</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>严格地说，创建Thread子类的实例也是可行的，但是必须注意的是，该子类必须没有覆盖 Thread 类的 run 方法，否则该线程执行的将是子类的 run 方法，而不是我们用以实现Runnable 接口的类的 run 方法，对此大家不妨试验一下。 </p>
<p>使用 Runnable 接口来实现多线程使得我们能够在一个类中包容所有的代码，有利于封装，它的缺点在于，我们只能使用一套代码，若想创建多个线程并使各个线程执行不同的代码，则仍必须额外创建类，如果这样的话，在大多数情况下也许还不如直接用多个类分别继承 Thread 来得紧凑。 </p>
<p>综上所述，两种方法各有千秋，大家可以灵活运用。 </p>
<p>下面让我们一起来研究一下多线程使用中的一些问题。 </p>
<h4 id="三、线程的四种状态"><a href="#三、线程的四种状态" class="headerlink" title="三、线程的四种状态"></a>三、线程的四种状态</h4><ol>
<li>新状态：线程已被创建但尚未执行（start() 尚未被调用）。 </li>
<li>可执行状态：线程可以执行，虽然不一定正在执行。CPU 时间随时可能被分配给该线程，从而使得它执行。 </li>
<li>死亡状态：正常情况下 run() 返回使得线程死亡。调用 stop()或 destroy() 亦有同样效果，但是不被推荐，前者会产生异常，后者是强制终止，不会释放锁。 </li>
<li>阻塞状态：线程不会被分配 CPU 时间，无法执行。 </li>
</ol>
<h4 id="四、线程的优先级"><a href="#四、线程的优先级" class="headerlink" title="四、线程的优先级"></a>四、线程的优先级</h4><p>线程的优先级代表该线程的重要程度，当有多个线程同时处于可执行状态并等待获得 CPU 时间时，线程调度系统根据各个线程的优先级来决定给谁分配 CPU 时间，优先级高的线程有更大的机会获得 CPU 时间，优先级低的线程也不是没有机会，只是机会要小一些罢了。 </p>
<p>你可以调用 Thread 类的方法 <code>getPriority()</code> 和 <code>setPriority()</code>来存取线程的优先级，线程的优先级界于<strong>1(MIN_PRIORITY)</strong>和<strong>10(MAX_PRIORITY)</strong>之间，缺省是<strong>5(NORM_PRIORITY)</strong>。 </p>
<h4 id="五、线程的同步"><a href="#五、线程的同步" class="headerlink" title="五、线程的同步"></a>五、线程的同步</h4><p>由于同一进程的多个线程共享同一片存储空间，在带来方便的同时，也带来了访问冲突这个严重的问题。Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问。 </p>
<p>由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，这套机制就是 synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。 </p>
<ol>
<li><p>synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">accessVal</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br></pre></td></tr></table></figure>
<p>synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。 </p>
<p>这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。 </p>
<p>在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。 </p>
<p>synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。</p>
</li>
<li><p>synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) &#123;  </span><br><span class="line">　<span class="comment">//允许访问控制的代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。</p>
</li>
</ol>
<h4 id="六、线程的阻塞"><a href="#六、线程的阻塞" class="headerlink" title="六、线程的阻塞"></a>六、线程的阻塞</h4><p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持。 </p>
<p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 </p>
<ol>
<li><code>sleep()</code>方法：sleep() 允许指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。 </li>
<li><code>suspend()</code>和 <code>resume()</code>方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 </li>
<li><code>yield()</code> 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。 </li>
<li><code>wait()</code>和<code>notify()</code>方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。 </li>
</ol>
<p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p>
<p>上述的核心区别导致了一系列的细节上的区别。 </p>
<ul>
<li>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。 而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。 </li>
<li>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。 </li>
</ul>
<p>同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现 IllegalMonitorStateException 异常。 </p>
<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。 </p>
<p>它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。关于 wait() 和 notify() 方法最后再说明两点： </p>
<ul>
<li>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 </li>
<li>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 </li>
</ul>
<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。 </p>
<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify()方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。 </p>
<h4 id="七、守护线程"><a href="#七、守护线程" class="headerlink" title="七、守护线程"></a>七、守护线程</h4><p>守护线程是一类特殊的线程，它和普通线程的区别在于它并不是应用程序的核心部分，当一个应用程序的所有非守护线程终止运行时，即使仍然有守护线程在运行，应用程序也将终止，反之，只要有一个非守护线程在运行，应用程序就不会终止。守护线程一般被用于在后台为其它线程提供服务。 </p>
<p>可以通过调用方法 isDaemon() 来判断一个线程是否是守护线程，也可以调用方法 setDaemon() 来将一个线程设为守护线程。 </p>
<h4 id="八、线程组"><a href="#八、线程组" class="headerlink" title="八、线程组"></a>八、线程组</h4><p>线程组是一个 Java 特有的概念，在 Java 中，线程组是类ThreadGroup 的对象，每个线程都隶属于唯一一个线程组，这个线程组在线程创建时指定并在线程的整个生命期内都不能更改。 </p>
<p>你可以通过调用包含 ThreadGroup 类型参数的 Thread 类构造函数来指定线程属的线程组，若没有指定，则线程缺省地隶属于名为 system 的系统线程组。 </p>
<p>在 Java 中，除了预建的系统线程组外，所有线程组都必须显式创建。在 Java 中，除系统线程组外的每个线程组又隶属于另一个线程组，你可以在创建线程组时指定其所隶属的线程组，若没有指定，则缺省地隶属于系统线程组。这样，所有线程组组成了一棵以系统线程组为根的树。 </p>
<p>Java 允许我们对一个线程组中的所有线程同时进行操作，比如我们可以通过调用线程组的相应方法来设置其中所有线程的优先级，也可以启动或阻塞其中的所有线程。 </p>
<p>Java 的线程组机制的另一个重要作用是线程安全。线程组机制允许我们通过分组来区分有不同安全特性的线程，对不同组的线程进行不同的处理，还可以通过线程组的分层结构来支持不对等安全措施的采用。</p>
<p>Java 的 ThreadGroup 类提供了大量的方法来方便我们对线程组树中的每一个线程组以及线程组中的每一个线程进行操作。 </p>
<h4 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h4><p>在本文中，我们讲述了 Java 多线程编程的方方面面，包括创建线程，以及对多个线程进行调度、管理。我们深刻认识到了多线程编程的复杂性，以及线程切换开销带来的多线程程序的低效性，这也促使我们认真地思考一个问题：我们是否需要多线程？何时需要多线程？ </p>
<p>多线程的核心在于多个代码块并发执行，本质特点在于各代码块之间的代码是乱序执行的。我们的程序是否需要多线程，就是要看这是否也是它的内在特点。 </p>
<p>假如我们的程序根本不要求多个代码块并发执行，那自然不需要使用多线程；假如我们的程序虽然要求多个代码块并发执行，但是却不要求乱序，则我们完全可以用一个循环来简单高效地实现，也不需要使用多线程；只有当它完全符合多线程的特点时，多线程机制对线程间通信和线程管理的强大支持才能有用武之地，这时使用多线程才是值得的。</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的注解处理器</title>
    <url>/2016/01/12/java-zhong-de-zhu-jie-chu-li-qi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>本文是<strong>Java源代码级别注解处理的简介，</strong>并提供了使用此技术在编译期间生成其他源文件的示例。<br><a id="more"></a></p>
<h2 id="2-注解处理的应用"><a href="#2-注解处理的应用" class="headerlink" title="2. 注解处理的应用"></a>2. 注解处理的应用</h2><p>源级注解处理首先出现在Java 5中。它是一种在编译阶段生成其他源文件的便捷技术。</p>
<p>源文件不必是Java文件 - 您可以根据源代码中的注解生成任何类型的描述，元数据，文档，资源或任何其他类型的文件。</p>
<p>注解处理在许多无处不在的Java库中被广泛使用，例如，在QueryDSL和JPA中生成元类，以使用Lombok库中的样板代码来扩充类。</p>
<p>需要注意的一件重要事情是<strong>注解处理API的局限性 - 它只能用于生成新文件，而不能用于更改现有文件</strong>。</p>
<p>值得注意的例外是<a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a>库，它使用注解处理作为引导机制，将自身包含在编译过程中，并通过一些内部编译器API修改AST。这种hacky技术与注解处理的预期目的无关，因此本文不讨论。</p>
<h2 id="3-注解处理API"><a href="#3-注解处理API" class="headerlink" title="3. 注解处理API"></a>3. 注解处理API</h2><p>注解处理在多轮中完成。每一轮都从编译器搜索源文件中的注解并选择适合这些注解的注解处理器开始。反过来，每个注解处理器在相应的源上被调用。</p>
<p>如果在此过程中生成了任何文件，则会以生成的文件作为输入启动另一轮。此过程将继续，直到在处理阶段没有生成新文件。</p>
<p>反过来，每个注解处理器在相应的源上被调用。如果在此过程中生成了任何文件，则会以生成的文件作为输入启动另一轮。此过程将继续，直到在处理阶段没有生成新文件。</p>
<p>注解处理API位于<em>javax.annotation.processing</em>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<em>AbstractProcessor</em>类形式的部分实现。这个类是我们要扩展的类，以创建我们自己的注解处理器。</p>
<h2 id="4-设置项目"><a href="#4-设置项目" class="headerlink" title="4. 设置项目"></a>4. 设置项目</h2><p>为了演示注解处理的可能性，我们将开发一个简单的处理器，用于为带注解的类生成流畅的对象构建器。</p>
<p>我们将把项目分成两个Maven模块。其中一个<em>注解处理器</em>模块将包含处理器本身和注解，另一个<em>注解用户</em>模块将包含注解类。这是注解处理的典型用例。</p>
<p><em>annotation-processor</em>模块的设置如下。我们将使用Google的<a href="https://github.com/google/auto/tree/master/service" target="_blank" rel="noopener">auto-service</a>库来生成稍后将讨论的处理器元数据文件，以及针对Java 8源代码调整的<em>maven-compiler-plugin</em>。这些依赖项的版本将提取到属性部分。</p>
<p>可以在Maven Central存储库中找到最新版本的<a href="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22com.google.auto.service%22%20AND%20a%3A%22auto-service%22" target="_blank" rel="noopener">auto-service</a>库和<a href="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.apache.maven.plugins%22%20AND%20a%3A%22maven-compiler-plugin%22" target="_blank" rel="noopener">maven-compiler-plugin</a>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auto-service.version</span>&gt;</span>1.0-rc2<span class="tag">&lt;/<span class="name">auto-service.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven-compiler-plugin.version</span>&gt;</span></span><br><span class="line">      3.5.1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">maven-compiler-plugin.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.auto.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>auto-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>带有注解源的<em>注解用户</em> 模型不需要任何特殊调整，除了在依赖项部分中添加对注解处理器模块的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.doleje<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotation-processing<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-定义注解"><a href="#5-定义注解" class="headerlink" title="5. 定义注解"></a>5. 定义注解</h2><p>假设我们的<em>注解用户</em>模块中有一个简单的POJO类，它包含几个字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// getters and setters …</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想要创建一个构建器帮助程序类，以更流畅地实例化<em>Person</em>类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person person = new PersonBuilder()</span><br><span class="line">  .setAge(25)</span><br><span class="line">  .setName(&quot;John&quot;)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure>
<p>这个<em>PersonBuilder</em>类 Person对象的构建器，因为它的结构完全由<em>Person</em> setter方法定义。</p>
<p>让我们在<em>注解处理器</em>模块中为setter方法创建一个<em>@BuilderProperty</em>注解。它将允许我们为每个具有其setter方法注解的类生成<em>Builder</em>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BuilderProperty &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有<em>ElementType.METHOD</em>参数的<em>@Target</em>注解确保此注解只能放在方法上。</p>
<p>在<em>SOURCE</em>保留策略意味着该注解只能用于源文件处理期间，而不是在运行时可用。</p>
<p>具有使用<em>@BuilderProperty</em>注解注解的属性的<em>Person</em>类将如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@BuilderProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@BuilderProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// getters …</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-实现-Processor"><a href="#6-实现-Processor" class="headerlink" title="6. 实现 Processor"></a>6. 实现 Processor</h2><h3 id="6-1-创建AbstractProcessor子类"><a href="#6-1-创建AbstractProcessor子类" class="headerlink" title="6.1 创建AbstractProcessor子类"></a>6.1 创建AbstractProcessor子类</h3><p>我们将首先在<em>注解处理器</em> Maven模块中扩展<em>AbstractProcessor</em>类。</p>
<p>首先，我们应该指定该处理器能够处理的注解，以及支持的源代码版本。这可以通过实施方法进行<em>getSupportedAnnotationTypes</em>和<em>getSupportedSourceVersion</em>的的<em>处理器</em>接口或通过注解你的类<em>@SupportedAnnotationTypes</em>和<em>@SupportedSourceVersion</em>注解。</p>
<p>所述<em>@AutoService</em>注解是的一部分<em>auto-service</em>库，并允许生成，这将在下面的章节进行说明处理器的元数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(</span><br><span class="line">  <span class="string">"com.doleje.annotation.processor.BuilderProperty"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="meta">@AutoService</span>(Processor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">BuilderProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, </span></span></span><br><span class="line"><span class="function"><span class="params">      RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您不仅可以指定具体的注解类名称，还可以指定通配符，例如<em>“com.doleje.annotation。\</em>”<em>来处理</em>com.doleje.annotation<em>包及其所有子包内的注解，甚至</em>“*”*来处理所有注解。</p>
<p>我们必须实现的单一方法是进行<em>process</em>方法。编译器会为包含匹配注解的每个源文件调用它。</p>
<p>注解作为第一个<em>Set &lt;? extends TypeElement&gt; annotations</em>参数，并将有关当前处理轮次的信息作为<em>RoundEnviroment roundEnv</em>参数传递。</p>
<p>如果注解处理器已处理了所有传递的注解，并且您不希望它们传递到列表中的其他注解处理器，则返回 <em>true</em>。</p>
<h3 id="6-2-收集数据"><a href="#6-2-收集数据" class="headerlink" title="6.2 收集数据"></a>6.2 收集数据</h3><p>我们的处理器还没有真正做任何有用的事情，所以让我们用代码完成它。</p>
<p>首先，我们需要遍历在类中找到的所有注解类型。 在我们的示例中，<em>annotation</em> 集将具有与<em>@BuilderProperty</em>注解相对应的单个元素，即使此注解在源文件中多次出现也是如此。</p>
<p>尽管如此，为了完整起见，最好将 <em>process</em> 方法实现为迭代循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, </span></span></span><br><span class="line"><span class="function"><span class="params">  RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; annotatedElements </span><br><span class="line">          = roundEnv.getElementsAnnotatedWith(annotation);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// …</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此代码中，我们使用<em>RoundEnvironment</em>实例接收使用<em>@BuilderProperty</em>批注注解的所有元素。对于<em>Person</em>类，这些元素对应于<em>setName</em>和<em>setAge</em>方法。</p>
<p><em>@BuilderProperty</em>注解的用户可能会错误地注解实际上不是setter的方法。setter方法名称应以<em>set</em>开头，方法应该接收一个参数。</p>
<p>在下面的代码中，我们使用<em>Collectors.partitioningBy()</em>收集器将带注解的方法拆分为两个集合：正确注解的 setter 和其他错误注解的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(</span><br><span class="line">  Collectors.partitioningBy(element -&gt;</span><br><span class="line">    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="number">1</span></span><br><span class="line">    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="string">"set"</span>)));</span><br><span class="line"> </span><br><span class="line">List&lt;Element&gt; setters = annotatedMethods.get(<span class="keyword">true</span>);</span><br><span class="line">List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用<em>Element.asType()</em>方法接收<em>TypeMirror</em>类的实例，这使我们能够探测类型，即使我们只处于源处理阶段。</p>
<p>另外，我们应该警告用户注解错误的方法，所以让我们使用可从<em>AbstractProcessor.processingEnv</em> protected字段访问的<em>Messager</em>实例。以下行将在源处理阶段为每个错误注解的元素输出错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">otherMethods.forEach(element -&gt;</span><br><span class="line">  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">    <span class="string">"@BuilderProperty must be applied to a setXxx method "</span></span><br><span class="line">      + <span class="string">"with a single argument"</span>, element));</span><br></pre></td></tr></table></figure>
<p>当然，如果正确的setter集合为空，则没有必要继续当前的类型元素集迭代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (setters.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果setter集合至少有一个元素，我们将使用它从封闭元素中获取完全限定的类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = ((TypeElement) setters.get(<span class="number">0</span>)</span><br><span class="line">  .getEnclosingElement()).getQualifiedName().toString();</span><br></pre></td></tr></table></figure>
<p>生成构建器类所需的最后一点信息是setter名称和参数类型名称之间的映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(</span><br><span class="line">    setter -&gt; setter.getSimpleName().toString(),</span><br><span class="line">    setter -&gt; ((ExecutableType) setter.asType())</span><br><span class="line">      .getParameterTypes().get(0).toString()</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<h3 id="6-3-生成输出文件"><a href="#6-3-生成输出文件" class="headerlink" title="6.3 生成输出文件"></a>6.3 生成输出文件</h3><p>现在我们拥有生成构建器类所需的所有信息：源类的名称，所有setter名称及其参数类型。</p>
<p>要生成输出文件，我们将使用<em>AbstractProcessor.processingEnv</em> protected属性中的对象再次提供的<em>Filer</em>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaFileObject builderFile = processingEnv.getFiler()</span><br><span class="line">  .createSourceFile(builderClassName);</span><br><span class="line"><span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;</span><br><span class="line">    <span class="comment">// writing generated file to out …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面提供了<em>writeBuilderFile</em>方法的完整代码。我们只需要为源类和构建器类计算包名，完全限定的构建器类名和简单类名。其余的代码非常简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBuilderFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String className, Map&lt;String, String&gt; setterMap)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String packageName = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lastDot = className.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (lastDot &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        packageName = className.substring(<span class="number">0</span>, lastDot);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String simpleClassName = className.substring(lastDot + <span class="number">1</span>);</span><br><span class="line">    String builderClassName = className + <span class="string">"Builder"</span>;</span><br><span class="line">    String builderSimpleClassName = builderClassName</span><br><span class="line">      .substring(lastDot + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    JavaFileObject builderFile = processingEnv.getFiler()</span><br><span class="line">      .createSourceFile(builderClassName);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            out.print(<span class="string">"package "</span>);</span><br><span class="line">            out.print(packageName);</span><br><span class="line">            out.println(<span class="string">";"</span>);</span><br><span class="line">            out.println();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        out.print(<span class="string">"public class "</span>);</span><br><span class="line">        out.print(builderSimpleClassName);</span><br><span class="line">        out.println(<span class="string">" &#123;"</span>);</span><br><span class="line">        out.println();</span><br><span class="line"> </span><br><span class="line">        out.print(<span class="string">"    private "</span>);</span><br><span class="line">        out.print(simpleClassName);</span><br><span class="line">        out.print(<span class="string">" object = new "</span>);</span><br><span class="line">        out.print(simpleClassName);</span><br><span class="line">        out.println(<span class="string">"();"</span>);</span><br><span class="line">        out.println();</span><br><span class="line"> </span><br><span class="line">        out.print(<span class="string">"    public "</span>);</span><br><span class="line">        out.print(simpleClassName);</span><br><span class="line">        out.println(<span class="string">" build() &#123;"</span>);</span><br><span class="line">        out.println(<span class="string">"        return object;"</span>);</span><br><span class="line">        out.println(<span class="string">"    &#125;"</span>);</span><br><span class="line">        out.println();</span><br><span class="line"> </span><br><span class="line">        setterMap.entrySet().forEach(setter -&gt; &#123;</span><br><span class="line">            String methodName = setter.getKey();</span><br><span class="line">            String argumentType = setter.getValue();</span><br><span class="line"> </span><br><span class="line">            out.print(<span class="string">"    public "</span>);</span><br><span class="line">            out.print(builderSimpleClassName);</span><br><span class="line">            out.print(<span class="string">" "</span>);</span><br><span class="line">            out.print(methodName);</span><br><span class="line"> </span><br><span class="line">            out.print(<span class="string">"("</span>);</span><br><span class="line"> </span><br><span class="line">            out.print(argumentType);</span><br><span class="line">            out.println(<span class="string">" value) &#123;"</span>);</span><br><span class="line">            out.print(<span class="string">"        object."</span>);</span><br><span class="line">            out.print(methodName);</span><br><span class="line">            out.println(<span class="string">"(value);"</span>);</span><br><span class="line">            out.println(<span class="string">"        return this;"</span>);</span><br><span class="line">            out.println(<span class="string">"    &#125;"</span>);</span><br><span class="line">            out.println();</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-运行示例"><a href="#7-运行示例" class="headerlink" title="7. 运行示例"></a>7. 运行示例</h2><p>要查看代码生成的实际操作，您应该从公共父根编译两个模块，或者首先编译<em>annotation-processor</em>模块，然后编译<em>annotation-user</em>模块。</p>
<p>生成的<em>PersonBuilder</em>类可以在<em>annotation-user / target / generated-sources / annotations / com / doleje / annotation / PersonBuilder.java</em>文件中找到，应该如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.doleje.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Person object = <span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">setName</span><span class="params">(java.lang.String value)</span> </span>&#123;</span><br><span class="line">        object.setName(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        object.setAge(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-注册处理器的其他方法"><a href="#8-注册处理器的其他方法" class="headerlink" title="8. 注册处理器的其他方法"></a>8. 注册处理器的其他方法</h2><p>要在编译阶段使用注解处理器，您还有其他几个选项，具体取决于您的使用案例和您使用的工具。</p>
<h3 id="8-1-使用注解处理器工具"><a href="#8-1-使用注解处理器工具" class="headerlink" title="8.1 使用注解处理器工具"></a>8.1 使用注解处理器工具</h3><p>该<em>apt</em>工具是用于处理源文件一个特殊的命令行实用程序。它是Java 5的一部分，但是从Java 7开始，它被弃用以支持其他选项并在Java 8中完全删除。本文不讨论它。</p>
<h3 id="8-2-使用编译器密钥"><a href="#8-2-使用编译器密钥" class="headerlink" title="8.2 使用编译器密钥"></a>8.2 使用编译器密钥</h3><p>该<em>-processor</em>编译器关键是一个标准的JDK设施，以增加编译器的源处理阶段，自己的注解处理器。</p>
<p>请注意，处理器本身和注解必须已在单独的编译中编译为类，并出现在类路径中，因此您应该做的第一件事是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac com/doleje/annotation/processor/BuilderProcessor</span><br><span class="line">javac com/doleje/annotation/processor/BuilderProperty</span><br></pre></td></tr></table></figure>
<p>然后使用<em>-processor</em>键指定您刚刚编译的注解处理器类，对源进行实际编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -processor com.doleje.annotation.processor.MyProcessor Person.java</span><br></pre></td></tr></table></figure>
<p>要一次指定多个注解处理器，可以用逗号分隔它们的类名，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -processor package1.Processor1,package2.Processor2 SourceFile.java</span><br></pre></td></tr></table></figure>
<h3 id="8-3-使用Maven"><a href="#8-3-使用Maven" class="headerlink" title="8.3 使用Maven"></a>8.3 使用Maven</h3><p>的<em>maven-compiler-plugin</em>允许指定注解处理器作为其配置的一部分。</p>
<p>这是为编译器插件添加注解处理器的示例。您还可以使用<em>generatedSourcesDirectory</em>配置参数指定要将生成的源放入的目录。</p>
<p>请注意，<em>BuilderProcessor</em>类应该已经编译，例如，从构建依赖项中的另一个jar导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                &lt;generatedSourcesDirectory&gt;$&#123;project.build.directory&#125;</span><br><span class="line">                  /generated-sources/&lt;/generatedSourcesDirectory&gt;</span><br><span class="line">                &lt;annotationProcessors&gt;</span><br><span class="line">                    &lt;annotationProcessor&gt;</span><br><span class="line">                        com.doleje.annotation.processor.BuilderProcessor</span><br><span class="line">                    &lt;/annotationProcessor&gt;</span><br><span class="line">                &lt;/annotationProcessors&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-将处理器Jar添加到Classpath"><a href="#8-4-将处理器Jar添加到Classpath" class="headerlink" title="8.4 将处理器Jar添加到Classpath"></a>8.4 将处理器Jar添加到Classpath</h3><p>您可以简单地将具有处理器类的特殊结构化jar添加到编译器的类路径中，而不是在编译器选项中指定注解处理器。</p>
<p>要自动获取它，编译器必须知道处理器类的名称。因此，您必须在<em>META-INF / services / javax.annotation.processing.Processor</em>文件中将其指定为处理器的完全限定类名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.doleje.annotation.processor.BuilderProcessor</span><br></pre></td></tr></table></figure>
<p>您还可以指定此jar中的多个处理器，通过用新行分隔它们来自动拾取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package1.Processor1``package2.Processor2``package3.Processor3</span><br></pre></td></tr></table></figure>
<p>如果您使用Maven构建此jar并尝试将此文件直接放入<em>src/main/resources/META-INF/services</em>目录中，您将遇到以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERROR] Bad service configuration file, or exception thrown while</span><br><span class="line">constructing Processor object: javax.annotation.processing.Processor: </span><br><span class="line">Provider com.doleje.annotation.processor.BuilderProcessor not found</span><br></pre></td></tr></table></figure>
<p>这是因为当尚未编译<em>BuilderProcessor</em>文件时，编译器尝试在模块本身的<em>source-processing</em>阶段使用此文件。该文件必须放在另一个资源目录中，并在Maven构建的资源复制阶段复制到<em>META-INF / services</em>目录，或者在构建期间生成（甚至更好）。</p>
<p>以下部分中讨论的Google <em>auto-service</em>库允许使用简单的注解生成此文件。</p>
<h3 id="8-5-使用Google-auto-service库"><a href="#8-5-使用Google-auto-service库" class="headerlink" title="8.5 使用Google auto-service库"></a>8.5 使用Google auto-service库</h3><p>要自动生成注册文件，您可以使用Google <em>auto-service</em>库中的<em>@AutoService</em>注解，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">public BuilderProcessor extends AbstractProcessor &#123;</span><br><span class="line">    // …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解本身由注解处理器从auto-service库处理。此处理器生成包含<em>BuilderProcessor</em>类名的<em>META-INF / services / javax.annotation.processing.Processor</em>文件。</p>
<h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a>9. 结论</h2><p>在本文中，我们使用为POJO生成Builder类的示例演示了源级注释处理。我们还提供了几种在项目中注册注释处理器的替代方法。</p>
]]></content>
      <tags>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>Java执行命令行</title>
    <url>/2016/02/11/java-zhi-xing-ming-ling-xing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在日常开发过程中，我们经常会需要调用系统的命令行，比如执行一些系统工具/库来压缩（变换）图片等。本文将介绍<strong>从Java代码</strong>中<strong>执行shell命令</strong>的两种方法。</p>
<p>第一种是使用<em>Runtime</em>类并调用其<em>exec</em>方法。</p>
<p>第二种更可定制的方法是创建和使用<em>ProcessBuilder</em>实例。<br><a id="more"></a></p>
<h2 id="2-操作系统依赖性"><a href="#2-操作系统依赖性" class="headerlink" title="2. 操作系统依赖性"></a>2. 操作系统依赖性</h2><p>在我们要创建执行shell命令的新<em>Process</em>之前，我们需要首先确定运行<em>JVM</em>的操作系统。</p>
<p>这是因为，在<em>Windows</em>上，我们需要将命令作为参数运行到<em>cmd.exe</em>  shell，在所有其他操作系统上我们可以发出一个名为<em>sh</em>的标准<em>shell </em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isWindows = System.getProperty(<span class="string">"os.name"</span>)</span><br><span class="line">  .toLowerCase().startsWith(<span class="string">"windows"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="3-输入和输出"><a href="#3-输入和输出" class="headerlink" title="3. 输入和输出"></a>3. 输入和输出</h2><p>此外， 我们需要一种方法来 Hook 住输入和输出流。</p>
<p>至少<strong>必须消费掉输出</strong> - 否则我们的进程不会成功返回，而是会挂起。</p>
<p>让我们实现一个名为<em>StreamGobbler</em>的常用类，它使用一个<em>InputStream</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class StreamGobbler implements Runnable &#123;</span><br><span class="line">    private InputStream inputStream;</span><br><span class="line">    private Consumer&lt;String&gt; consumer;</span><br><span class="line"> </span><br><span class="line">    public StreamGobbler(InputStream inputStream, Consumer&lt;String&gt; consumer) &#123;</span><br><span class="line">        this.inputStream = inputStream;</span><br><span class="line">        this.consumer = consumer;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        new BufferedReader(new InputStreamReader(inputStream)).lines()</span><br><span class="line">          .forEach(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>此类实现了<em>Runnable</em>接口，这意味着它可以由任何<em>Executor</em>执行。</p>
<h2 id="4-Runtime-exec"><a href="#4-Runtime-exec" class="headerlink" title="4. Runtime.exec()"></a>4. Runtime.exec()</h2><p>对<em>Runtime.exec()</em>的方法调用是一种简单的，尚未定制的生成新子进程的方法。</p>
<p>在下面的示例中，我们将请求用户主目录的目录列表并将其打印到控制台：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String homeDirectory = System.getProperty(<span class="string">"user.home"</span>);</span><br><span class="line">Process process;</span><br><span class="line"><span class="keyword">if</span> (isWindows) &#123;</span><br><span class="line">    process = Runtime.getRuntime()</span><br><span class="line">      .exec(String.format(<span class="string">"cmd.exe /c dir %s"</span>, homeDirectory));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime()</span><br><span class="line">      .exec(String.format(<span class="string">"sh -c ls %s"</span>, homeDirectory));</span><br><span class="line">&#125;</span><br><span class="line">StreamGobbler streamGobbler = </span><br><span class="line">  <span class="keyword">new</span> StreamGobbler(process.getInputStream(), System.out::println);</span><br><span class="line">Executors.newSingleThreadExecutor().submit(streamGobbler);</span><br><span class="line"><span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line"><span class="keyword">assert</span> exitCode == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-ProcessBuilder"><a href="#5-ProcessBuilder" class="headerlink" title="5. ProcessBuilder"></a>5. ProcessBuilder</h2><p>对于计算问题的第二个实现，我们将使用<em>ProcessBuilder</em>。这比<em>Runtime</em>方法更<em>受欢迎，</em>因为我们可以自定义一些细节。</p>
<p>例如，我们能够：</p>
<ul>
<li>使用<em>builder.directory()</em>更改我们的shell命令正在运行的工作目录</li>
<li>使用<em>builder.environment()</em>将自定义键值映射设置为环境</li>
<li>将自定义输入和输出流重定向</li>
<li>使用<em>builder.inheritIO()</em>将它们都继承到当前<em>JVM</em>进程的流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessBuilder builder = <span class="keyword">new</span> ProcessBuilder();</span><br><span class="line"><span class="keyword">if</span> (isWindows) &#123;</span><br><span class="line">    builder.command(<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, <span class="string">"dir"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    builder.command(<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"ls"</span>);</span><br><span class="line">&#125;</span><br><span class="line">builder.directory(<span class="keyword">new</span> File(System.getProperty(<span class="string">"user.home"</span>)));</span><br><span class="line">Process process = builder.start();</span><br><span class="line">StreamGobbler streamGobbler = </span><br><span class="line">  <span class="keyword">new</span> StreamGobbler(process.getInputStream(), System.out::println);</span><br><span class="line">Executors.newSingleThreadExecutor().submit(streamGobbler);</span><br><span class="line"><span class="keyword">int</span> exitCode = process.waitFor();</span><br><span class="line"><span class="keyword">assert</span> exitCode == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="六，结论"><a href="#六，结论" class="headerlink" title="六，结论"></a>六，结论</h2><p>正如我们在本快速教程中看到的，我们可以用两种不同的方式在<em>Java</em>中执行shell命令。</p>
<p>通常，如果您计划自定义生成进程的执行，例如更改其工作目录，则应考虑使用<em>ProcessBuilder</em>。</p>
]]></content>
      <tags>
        <tag>CMD</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Mockito的几种Mock方法</title>
    <url>/2016/05/22/mockito-de-ji-chong-mock-fang-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Mockito是一套简洁易用的 Mocking 框架，本文我们将介绍创建模拟对象的三种不同方式以及它们之间的区别 - 使用Mockito和Spring模拟支持。<br><a id="more"></a></p>
<h2 id="2-Mockito-mock"><a href="#2-Mockito-mock" class="headerlink" title="2. Mockito.mock()"></a>2. <em>Mockito.mock()</em></h2><p>所述<em>Mockito.mock()</em>方法允许我们创建一个类或一个接口的一个模拟对象。</p>
<p>然后，我们可以使用mock来存储其方法的返回值，并验证它们是否被调用。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenCountMethodMocked_WhenCountInvoked_ThenMockedValueReturned</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserRepository localMockRepository = Mockito.mock(UserRepository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Mockito.when(localMockRepository.count()).thenReturn(<span class="number">111L</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> userCount = localMockRepository.count();</span><br><span class="line"> </span><br><span class="line">    Assert.assertEquals(<span class="number">111L</span>, userCount);</span><br><span class="line">    Mockito.verify(localMockRepository).count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用之前，此方法不需要执行任何其他操作。我们可以使用它来创建 Mock 类字段以及方法。</p>
<h2 id="3-Mockito的-Mock-Annotation"><a href="#3-Mockito的-Mock-Annotation" class="headerlink" title="3. Mockito的@Mock Annotation"></a>3. Mockito的<em>@Mock</em> Annotation</h2><p>此注释是<em>Mockito.mock()</em>方法的简写。同样，我们应该只在测试类中使用它。与<em>mock()</em>方法不同，我们需要启用Mockito注释才能使用此注释。</p>
<p>我们可以通过使用  <em>MockitoJUnitRunner</em>来运行测试或 显式调用  <em>MockitoAnnotations.initMocks()</em>方法来实现。</p>
<p>让我们看一个使用<em>MockitoJUnitRunner</em>的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(MockitoJUnitRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MockAnnotationUnitTest</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    UserRepository mockRepository;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenCountMethodMocked_WhenCountInvoked_ThenMockValueReturned</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mockito.when(mockRepository.count()).thenReturn(<span class="number">123L</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> userCount = mockRepository.count();</span><br><span class="line"> </span><br><span class="line">        Assert.assertEquals(<span class="number">123L</span>, userCount);</span><br><span class="line">        Mockito.verify(mockRepository).count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使代码更易读，<strong>@Mock在发生故障的情况下，它更容易找到故障的问题所在，因为它会将出现问题的字段名称显示在异常信息中</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wanted but not invoked:</span><br><span class="line">mockRepository.count();</span><br><span class="line">-&gt; at com.doleje.MockAnnotationTest.testMockAnnotation(MockAnnotationTest.java:22)</span><br><span class="line">Actually, there were zero interactions with this mock.</span><br><span class="line"> </span><br><span class="line">  at com.doleje.MockAnnotationTest.testMockAnnotation(MockAnnotationTest.java:22)</span><br></pre></td></tr></table></figure>
<p>此外，当与<em>@InjectMocks</em>结合使用时，它可以显着减少设置代码的数量。</p>
<h2 id="4-Spring-Boot的-MockBean注释"><a href="#4-Spring-Boot的-MockBean注释" class="headerlink" title="4. Spring Boot的@MockBean注释"></a>4. Spring Boot的<em>@MockBean</em>注释</h2><p>我们可以使用<em>@MockBean</em>将模拟对象添加到Spring应用程序上下文中。mock将替换应用程序上下文中任何相同类型的现有bean。</p>
<p>如果没有定义相同类型的bean，则会添加一个新bean。此注释在集成测试中很有用，在集成测试中需要模拟特定的bean（例如，外部服务）。</p>
<p>要使用此注解，我们必须使用<em>SpringRunner</em>来运行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MockBeanAnnotationIntegrationTest</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    UserRepository mockRepository;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext context;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenCountMethodMocked_WhenCountInvoked_ThenMockValueReturned</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mockito.when(mockRepository.count()).thenReturn(<span class="number">123L</span>);</span><br><span class="line"> </span><br><span class="line">        UserRepository userRepoFromContext = context.getBean(UserRepository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">long</span> userCount = userRepoFromContext.count();</span><br><span class="line"> </span><br><span class="line">        Assert.assertEquals(<span class="number">123L</span>, userCount);</span><br><span class="line">        Mockito.verify(mockRepository).count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用 <em>@MockBean</em> 来 Mock 了一个 <em>UserRepository</em> 对象，并注入到 Spring 容器中，这样我们在后面的测试过程中就可以直接从 <em>context</em> 中获取这个 Mock Bean，同样也可以设置其 Mock 行为与返回数据。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h2><p>在本文中，我们看到了创建模拟对象的三种方法有何不同以及如何使用它们。</p>
]]></content>
      <tags>
        <tag>单元测试</tag>
        <tag>Mockito</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL分库分表的一些技巧</title>
    <url>/2017/04/17/mysql-fen-ku-fen-biao-de-yi-xie-ji-qiao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="纵向分表"><a href="#纵向分表" class="headerlink" title="纵向分表"></a>纵向分表</h4><p>​    将本来可以在同一个表的内容，人为划分为多个表。（所谓的本来，是指按照关系型数据库的第三范式要求，是应该在同一个表的。）<br>分表理由：根据数据的活跃度进行分离，（因为不同活跃的数据，处理方式是不同的） </p>
<p><strong>案例</strong><br>对于一个博客系统，文章标题，作者，分类，创建时间等，是变化频率慢，查询次数多，而且最好有很好的实时性的数据，我们把它叫做冷数据。而博客的浏览量，回复数等，类似的统计信息，或者别的变化频率比较高的数据，我们把它叫做活跃数据。</p>
<p>所以，在进行数据库结构设计的时候，就应该考虑分表，首先是纵向分表的处理。<br>这样纵向分表后： 首先存储引擎的使用不同，冷数据使用MyIsam 可以有更好的查询数据。活跃数据，可以使用Innodb ,可以有更好的更新速度。 </p>
<p>其次，对冷数据进行更多的从库配置，因为更多的操作时查询，这样来加快查询速度。对热数据，可以相对有更多的主库的横向分表处理。 </p>
<p>其实，对于一些特殊的活跃数据，也可以考虑使用memcache ,redis之类的缓存，等累计到一定量再去更新数据库。或者mongodb 一类的nosql 数据库，这里只是举例，就先不说这个。 </p>
<a id="more"></a>
<h3 id="横向分表"><a href="#横向分表" class="headerlink" title="横向分表"></a>横向分表</h3><p>​    字面意思，就可以看出来，是把大的表结构，横向切割为同样结构的不同表，如，用户信息表，user_1,user_2 等。表结构是完全一样，但是，根据某些特定的规则来划分的表，如根据用户ID来取模划分。<br>分表理由：根据数据量的规模来划分，保证单表的容量不会太大，从而来保证单表的查询等处理能力。<br>案例：同上面的例子，博客系统。当博客的量达到很大时候，就应该采取横向分割来降低每个单表的压力，来提升性能。例如博客的冷数据表，假如分为100个表，当同时有100万个用户在浏览时，如果是单表的话，会进行100万次请求，而现在分表后，就可能是每个表进行1万个数据的请求（因为，不可能绝对的平均，只是假设），这样压力就降低了很多很多。 </p>
<p>数据库的复制能解决访问问题，并不能解决大规模的并发写入问题，要解决这个问题就要考虑mysql数据切分了 </p>
<p>数据切分，顾名思义，就是数据分散，将一台主机上的数据分摊到多台，减轻单台主机的负载压力，有两种切分方式，一种是分库，即按照业务模块分多个库，每个库中的表不一样，还有一种就是分表，按照一定的业务规则或者逻辑将数据拆分到不同的主机上，每个主机上的表是一样的，这个有点类似于Oracle的表分区。 </p>
<p>分库又叫垂直分区，这种方式实现起来比较简单，重要的是对业务要细化，分库时候要想清楚各个模块业务之间的交互情况，避免将来写程序时出现过多的跨库操作。 </p>
<p>分表又叫水平分区，这种方式实现起来就比垂直分区复杂些，但是它能解决垂直分区所不能解决的问题，即单张表的访问及写入很频繁，这时候就可以根据一定的业务规则（PS:如互联网BBS论坛的会员等级概念：根据会员等级来分表）来分表，这样就能减轻单表压力，并且还能解决各个模块的之间的频繁交互问题。 </p>
<p>分库的优点是：实现简单，库与库之间界限分明，便于维护，缺点是不利于频繁跨库操作，单表数据量大的问题解决不了。</p>
<p>分表的优点是：能解决分库的不足点，但是缺点却恰恰是分库的优点，分表实现起来比较复杂，特别是分表规则的划分，程序的编写，以及后期的数据库拆分移植维护。 </p>
<p>实际应用中，一般互联网企业的路线都是先分库再分表，两者结合使用，取长补短，这样发挥了mysql扩展的最大优势，但是缺点是架构很大，很复杂，应用程序的编写也比较复杂。 </p>
<p>以上是mysql的数据切分的一些概念，数据切完了，现在要做的是怎么样在整合起来以便于外界访问，因为程序访问的入口永远只有一个，现在比较常用的解决方案是通过中间代理层来统一管控所有数据源。</p>
]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下安装Nginx</title>
    <url>/2017/03/02/linux-huan-jing-xia-an-zhuang-nginx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>Nginx</strong> 是一个高性能的HTTP和反向代理服务器，官方地址为<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a>，这里不多做介绍。本次介绍使用源码编译安装，安装Nginx前需要安装C++编译环境，可使用以下命令安装：</p>
<p>Centos</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc gcc-c++</span><br></pre></td></tr></table></figure>
<p>Ubuntu:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install libtool</span><br></pre></td></tr></table></figure>
<p>Nginx下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a><br><a id="more"></a></p>
<p><strong>安装Nginx需要3个依赖包：</strong></p>
<ul>
<li>gzip模块需要 zlib (<a href="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net/</a>)</li>
<li>rewrite模块需要 pcre(<a href="http://www.pcre.org/" target="_blank" rel="noopener">http://www.pcre.org/</a>)</li>
<li>ssl 需要 openssl (<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a>)</li>
</ul>
<h2 id="2-安装pcre"><a href="#2-安装pcre" class="headerlink" title="2. 安装pcre"></a>2. 安装pcre</h2><p><strong>pcre</strong> 的作用是让Nginx支持Rewrite功能。本次介绍使用pcre，非pcre2版本，我在使用pcre2安装Nginx时出现错误，后来改用pcre没有报错。</p>
<p>下载pcre，地址: <a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 下载</span><br><span class="line">sudo wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf pcre-8.38.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd pcre-8.38</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="3-安装zlib"><a href="#3-安装zlib" class="headerlink" title="3. 安装zlib"></a>3. 安装zlib</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 下载 </span><br><span class="line">sudo wget http://www.zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd zlib-1.2.11</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="4-安装openssl"><a href="#4-安装openssl" class="headerlink" title="4. 安装openssl"></a>4. 安装openssl</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 下载 </span><br><span class="line">sudo wget https://www.openssl.org/source/openssl-1.0.2n.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf openssl-1.0.2n.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd openssl-1.0.2n</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo ./config --prefix=/usr/local/openssl</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="5-安装Nginx"><a href="#5-安装Nginx" class="headerlink" title="5. 安装Nginx"></a>5. 安装Nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 下载 </span><br><span class="line">sudo wget http://nginx.org/download/nginx-1.8.1.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">sudo tar -zxvf nginx-1.8.1.tar.gz</span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd nginx-1.8.1</span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo ./configure --prefix=/usr/local/nginx --with-pcre=/home/user-01/download/pcre-8.38 --with-zlib=/home/user-01/download/zlib-1.2.11 --with-openssl=/usr/local/openssl</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 指定<code>pcre</code>和<code>zlib</code>的路径是源码路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--with-pcre=/home/user-01/download/pcre-8.38         # 指的是pcre-8.38 的源码路径。</span><br><span class="line">--with-zlib=/home/user-01/download/zlib-1.2.11       # 指的是zlib-1.2.11 的源码路径。</span><br></pre></td></tr></table></figure>
<h2 id="6-启动Nginx"><a href="#6-启动Nginx" class="headerlink" title="6. 启动Nginx"></a>6. 启动Nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
<p>浏览器访问，看到下图则说明Nginx安装并启动成功。</p>
<p><img src="/images/pasted-111.png" alt="upload successful"></p>
<h2 id="7-Nginx-常用命令"><a href="#7-Nginx-常用命令" class="headerlink" title="7. Nginx 常用命令"></a>7. Nginx 常用命令</h2><p>检查配置文件<code>nginx.conf</code>的正确性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure>
<p>停止Nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure>
<p>重新加载配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>MapStruct 介绍</title>
    <url>/2017/02/28/mapstruct-jie-shao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在一个成熟的工程中，尤其是现在的分布式系统中，应用与应用之间，还有单独的应用细分模块之后，DO 一般不会让外部依赖，这时候需要在提供对外接口的模块里放 DTO 用于对象传输，也即是 DO 对象对内，DTO对象对外，DTO 可以根据业务需要变更，并不需要映射 DO 的全部属性。</p>
<p>这种 对象与对象之间的互相转换，就需要有一个专门用来解决转换问题的工具，毕竟每一个字段都 get/set 会很麻烦。</p>
<p>MapStruct 就是这样的一个属性映射工具，只需要定义一个 Mapper 接口，MapStruct 就会自动实现这个映射接口，避免了复杂繁琐的映射实现。MapStruct官网地址： <a href="mapstruct.org">mapstruct.org</a>。<br><a id="more"></a></p>
<h2 id="2-Maven"><a href="#2-Maven" class="headerlink" title="2. Maven"></a>2. Maven</h2><p>让我们在Maven <em>pom.xml中</em>添加以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.Beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最新的<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.mapstruct&quot; AND a%3A&quot;mapstruct-jdk8&quot;" target="_blank" rel="noopener">Mapstruct</a>及其<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.mapstruct&quot; AND a%3A&quot;mapstruct-processor&quot;" target="_blank" rel="noopener">processor</a>稳定版本均可从Maven Central Repository获得。</p>
<p>我们还将<em>annotationProcessorPaths</em>部分添加到<em>maven-compiler-plugin</em>插件的配置部分，用于生成具体的映射器实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.Beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-基本映射"><a href="#3-基本映射" class="headerlink" title="3. 基本映射"></a>3. 基本映射</h2><h3 id="3-1-创建基本的-POJO"><a href="#3-1-创建基本的-POJO" class="headerlink" title="3.1 创建基本的 POJO"></a>3.1 创建基本的 POJO</h3><p>让我们首先创建一个简单的Java POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDestination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-映射器接口"><a href="#3-2-映射器接口" class="headerlink" title="3.2. 映射器接口"></a>3.2. 映射器接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span></span>;</span><br><span class="line">    <span class="function">SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，我们没有为<em>SimpleSourceDestinationMapper</em>创建实现类- 因为MapStruct将为我们创建它。</p>
<h3 id="3-3-映射器接口实现"><a href="#3-3-映射器接口实现" class="headerlink" title="3.3. 映射器接口实现"></a>3.3. 映射器接口实现</h3><p>我们可以通过执行<em>mvn clean install</em>来触发MapStruct处理，插件将在 <em>/target/generated-sources/annotations/</em>下生成具体的实现类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperImpl</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( source == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDestination simpleDestination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        simpleDestination.setName( source.getName() );</span><br><span class="line">        simpleDestination.setDescription( source.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleDestination;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( destination == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName( destination.getName() );</span><br><span class="line">        simpleSource.setDescription( destination.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-测试用例"><a href="#3-4-测试用例" class="headerlink" title="3.4 测试用例"></a>3.4 测试用例</h3><p>最后，通过生成所有内容，让我们编写一个测试用例，将显示<em>SimpleSource</em>中的值与<em>SimpleDestination</em>中的值匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SimpleSourceDestinationMapper mapper</span><br><span class="line">      = Mappers.getMapper(SimpleSourceDestinationMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenSourceToDestination_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName(<span class="string">"SourceName"</span>);</span><br><span class="line">        simpleSource.setDescription(<span class="string">"SourceDescription"</span>);</span><br><span class="line">        SimpleDestination destination = mapper.sourceToDestination(simpleSource);</span><br><span class="line">  </span><br><span class="line">        assertEquals(simpleSource.getName(), destination.getName());</span><br><span class="line">        assertEquals(simpleSource.getDescription(), </span><br><span class="line">          destination.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDestinationToSource_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDestination destination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        destination.setName(<span class="string">"DestinationName"</span>);</span><br><span class="line">        destination.setDescription(<span class="string">"DestinationDescription"</span>);</span><br><span class="line">        SimpleSource source = mapper.destinationToSource(destination);</span><br><span class="line">        assertEquals(destination.getName(), source.getName());</span><br><span class="line">        assertEquals(destination.getDescription(),</span><br><span class="line">          source.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-使用-Spring-依赖注入"><a href="#4-使用-Spring-依赖注入" class="headerlink" title="4. 使用 Spring 依赖注入"></a>4. 使用 Spring 依赖注入</h2><p>在上面的单元测试中，我们通过调用<em>Mappers.getMapper（YourClass.class）来</em>获取MapStruct中mapper的实例。当然，这是获取实例的一种非常手动的方式 - 更好的替代方法是将mapper直接注入我们需要的位置（如果我们的项目使用任何依赖注入解决方案）。</p>
<p><strong>幸运的是，MapStruct对Spring和CDI</strong>（<em>上下文和依赖注入</em>）<strong>都提供了很好的支持</strong>。</p>
<p>要在我们的映射器中使用Spring IoC，只需要给<em>@Mapper</em>注解添加 <em>componentModel=spring</em> 属性，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5-使用不同字段名称映射字段"><a href="#5-使用不同字段名称映射字段" class="headerlink" title="5. 使用不同字段名称映射字段"></a>5. 使用不同字段名称映射字段</h2><p>从前面的示例中，MapStruct能够自动映射我们的bean，因为它们具有相同的字段名称。那么如果我们要映射的bean有不同的字段名称呢？</p>
<p>对于我们的示例，我们将创建一个名为<em>Employee</em>和<em>EmployeeDTO</em>的新bean 。</p>
<h3 id="5-1-新的-POJO"><a href="#5-1-新的-POJO" class="headerlink" title="5.1 新的 POJO"></a>5.1 新的 POJO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Mapper"><a href="#5-2-Mapper" class="headerlink" title="5.2 Mapper"></a>5.2 Mapper</h3><p>在映射不同的字段名称时，我们需要将其源字段配置为其目标字段，为此，我们需要添加<em>@Mappings</em>注释。此批注接受一个<em>@Mapping</em>批注数组，我们将使用它来添加目标和源属性。</p>
<p>在MapStruct中，我们还可以使用点表示法来定义bean的成员：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-测试用例"><a href="#5-3-测试用例" class="headerlink" title="5.3 测试用例"></a>5.3 测试用例</h3><p>我们再次需要测试源和目标对象值是否匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-嵌套映射"><a href="#6-嵌套映射" class="headerlink" title="6. 嵌套映射"></a>6. 嵌套映射</h2><p>接下来，我们将展示如何使用对其他bean的引用来映射bean。</p>
<h3 id="6-1-修改-POJO"><a href="#6-1-修改-POJO" class="headerlink" title="6.1 修改 POJO"></a>6.1 修改 POJO</h3><p>让我们为<em>Employee</em>对象添加一个新的bean引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="keyword">private</span> DivisionDTO division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Division division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Division</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// default constructor, getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-修改Mapper"><a href="#6-2-修改Mapper" class="headerlink" title="6.2 修改Mapper"></a>6.2 修改Mapper</h3><p>这里我们需要添加一个方法将<em>Division</em>转换为<em>DivisionDTO</em>，反之亦然; 如果MapStruct检测到需要转换对象类型并且转换方法存在于同一个类中，那么它将自动使用它。</p>
<p>让我们将它添加到映射器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">DivisionDTO <span class="title">divisionToDivisionDTO</span><span class="params">(Division entity)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Division <span class="title">divisionDTOtoDivision</span><span class="params">(DivisionDTO dto)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-修改测试用例"><a href="#6-3-修改测试用例" class="headerlink" title="6.3 修改测试用例"></a>6.3 修改测试用例</h3><p>让我们修改并添加一些测试用例到现有测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpDTONestedMappingToEmp_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmployeeDTO dto = <span class="keyword">new</span> EmployeeDTO();</span><br><span class="line">    dto.setDivision(<span class="keyword">new</span> DivisionDTO(<span class="number">1</span>, <span class="string">"Division1"</span>));</span><br><span class="line">    Employee entity = mapper.employeeDTOtoEmployee(dto);</span><br><span class="line">    assertEquals(dto.getDivision().getId(), </span><br><span class="line">      entity.getDivision().getId());</span><br><span class="line">    assertEquals(dto.getDivision().getName(), </span><br><span class="line">      entity.getDivision().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-映射过程中的类型转换"><a href="#7-映射过程中的类型转换" class="headerlink" title="7. 映射过程中的类型转换"></a>7. 映射过程中的类型转换</h2><p>MapStruct还提供了几个现成的隐式类型转换，对于我们的示例，我们将尝试将String日期转换为实际的<em>Date</em>对象。</p>
<p>有关隐式类型转换的更多详细信息，可以阅读<a href="http://mapstruct.org/documentation/1.0/reference/html/#implicit-type-conversions" target="_blank" rel="noopener">MapStruct参考指南</a>。</p>
<h3 id="7-1-修改-POJO"><a href="#7-1-修改-POJO" class="headerlink" title="7.1 修改 POJO"></a>7.1 修改 POJO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">    <span class="keyword">private</span> Date startDt;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">    <span class="keyword">private</span> String employeeStartDt;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-修改Mapper"><a href="#7-2-修改Mapper" class="headerlink" title="7.2 修改Mapper"></a>7.2 修改Mapper</h3><p>修改映射器并为我们的开始日期提供<em>dateFormat</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source = <span class="string">"entity.id"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source = <span class="string">"entity.name"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeStartDt"</span>, source = <span class="string">"entity.startDt"</span>,</span><br><span class="line">           dateFormat = <span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"startDt"</span>, source=<span class="string">"dto.employeeStartDt"</span>,</span><br><span class="line">           dateFormat=<span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-修改测试用例"><a href="#7-3-修改测试用例" class="headerlink" title="7.3 修改测试用例"></a>7.3 修改测试用例</h3><p>让我们再添加一些测试用例来验证转换是否正确：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATE_FORMAT = <span class="string">"dd-MM-yyyy HH:mm:ss"</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpStartDtMappingToEmpDTO_whenMaps_thenCorrect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    Employee entity = <span class="keyword">new</span> Employee();</span><br><span class="line">    entity.setStartDt(<span class="keyword">new</span> Date());</span><br><span class="line">    EmployeeDTO dto = mapper.employeeToEmployeeDTO(entity);</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(DATE_FORMAT);</span><br><span class="line">  </span><br><span class="line">    assertEquals(format.parse(dto.getEmployeeStartDt()).toString(),</span><br><span class="line">      entity.getStartDt().toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpDTOStartDtMappingToEmp_whenMaps_thenCorrect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    EmployeeDTO dto = <span class="keyword">new</span> EmployeeDTO();</span><br><span class="line">    dto.setEmployeeStartDt(<span class="string">"01-04-2016 01:00:00"</span>);</span><br><span class="line">    Employee entity = mapper.employeeDTOtoEmployee(dto);</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(DATE_FORMAT);</span><br><span class="line">  </span><br><span class="line">    assertEquals(format.parse(dto.getEmployeeStartDt()).toString(),</span><br><span class="line">      entity.getStartDt().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-自定义映射结合（抽象类）"><a href="#8-自定义映射结合（抽象类）" class="headerlink" title="8. 自定义映射结合（抽象类）"></a>8. 自定义映射结合（抽象类）</h2><p>有时，我们希望通过自定义一些映射方式来扩展 <em>@Mapping</em>功能，比如除了类型转换之外，我们可能希望以某种方式转换值，如下面的示例所示，在这种情况下，我们可以创建一个抽象类并实现我们想要自定义的方法，并留下那些应该由MapStruct生成的抽象类。</p>
<h3 id="8-1-基本模型"><a href="#8-1-基本模型" class="headerlink" title="8. 1 基本模型"></a>8. 1 基本模型</h3><p>在这个例子中，我们将使用以下类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//standard getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匹配的 DTO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDTO</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="keyword">private</span> Long totalInCents;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里棘手的部分是将<em>BigDecimal</em>  <em>总</em>金额转换为<em>Long totalInCents</em>。</p>
<h3 id="8-2-定义-Mapper"><a href="#8-2-定义-Mapper" class="headerlink" title="8.2 定义 Mapper"></a>8.2 定义 Mapper</h3><p>我们可以通过将<em>Mapper</em> 创建  为抽象类来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionDTO <span class="title">toTransactionDTO</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">        TransactionDTO transactionDTO = <span class="keyword">new</span> TransactionDTO();</span><br><span class="line">        transactionDTO.setUuid(transaction.getUuid());</span><br><span class="line">        transactionDTO.setTotalInCents(transaction.getTotal()</span><br><span class="line">          .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>)).longValue());</span><br><span class="line">        <span class="keyword">return</span> transactionDTO;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;TransactionDTO&gt; <span class="title">toTransactionDTO</span><span class="params">(Collection&lt;Transaction&gt; transactions)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们为单个对象转换实现了完全自定义的映射方法。</p>
<p>另一方面，我们留下了将<em>Collection</em>映射到<em>List</em>抽象的方法，因此<em>MapStruct</em> 将为我们实现它。</p>
<h3 id="8-3-生成的结果"><a href="#8-3-生成的结果" class="headerlink" title="8.3 生成的结果"></a>8.3 生成的结果</h3><p>由于我们已经实现了将单个<em>Transaction</em>映射到<em>TransactionDTO的方法</em>，我们希望<em>Mapstruct</em>在第二种方法中使用它。将生成以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Generated</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionMapperImpl</span> <span class="keyword">extends</span> <span class="title">TransactionMapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TransactionDTO&gt; <span class="title">toTransactionDTO</span><span class="params">(Collection&lt;Transaction&gt; transactions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( transactions == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        List&lt;TransactionDTO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( Transaction transaction : transactions ) &#123;</span><br><span class="line">            list.add( toTransactionDTO( transaction ) );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们在第12行中看到的，<em>MapStruct</em> 在它生成的方法中使用我们的实现。</p>
<h2 id="9-支持-Lombok"><a href="#9-支持-Lombok" class="headerlink" title="9. 支持 Lombok"></a>9. 支持 Lombok</h2><p>在最新版本的MapStruct中，已经提供了对Lombok的支持。<strong>因此，我们可以使用Lombok轻松映射源实体和目标。</strong> 要启用Lombok支持，我们需要在注释处理器路径中添加<a href="https://search.maven.org/search?q=a:lombok" target="_blank" rel="noopener">依赖项</a>。所以现在我们在Maven编译器插件中有了mapstruct-processor和Lombok：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.Beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们使用Lombok注释定义源实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和目标数据传输对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个mapper接口仍然类似于我们前面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarMapper</span> </span>&#123;</span><br><span class="line">    CarMapper INSTANCE = Mappers.getMapper(CarMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function">CarDTO <span class="title">carToCarDTO</span><span class="params">(Car car)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-支持-defaultExpression"><a href="#10-支持-defaultExpression" class="headerlink" title="10. 支持  defaultExpression"></a>10. 支持  defaultExpression</h2><p>从版本1.3.0开始，<strong>我们可以使用@Mapping批注的defaultExpression属性来指定一个表达式，如果源字段为null，则该表达式确定目标字段的值。</strong>这是现有<em>defaultValue</em>属性功能的补充。</p>
<p>源实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标数据传输对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果源实体的<em>id</em>字段为<em>null，</em>我们想要生成一个随机<em>id</em>并将其分配给目标，保持其他属性值为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"id"</span>, source = <span class="string">"person.id"</span>, </span><br><span class="line">      defaultExpression = <span class="string">"java(java.util.UUID.randomUUID().toString())"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">personToPersonDTO</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们添加一个测试用例来验证表达式的执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPersonEntitytoPersonWithExpression_whenMaps_thenCorrect</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    Person entity  </span>= <span class="keyword">new</span> Person();</span><br><span class="line">    entity.setName(<span class="string">"Micheal"</span>);</span><br><span class="line">    PersonDTO personDto = PersonMapper.INSTANCE.personToPersonDTO(entity);</span><br><span class="line">    assertNull(entity.getId());</span><br><span class="line">    assertNotNull(personDto.getId());</span><br><span class="line">    assertEquals(personDto.getName(), entity.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>PATCH与PUT and POST</title>
    <url>/2018/12/19/patch-yu-put-yi-ji-post-de-qu-bie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>另外：区分PATCH与PUT、POST方法</p>
<p>　　在HTTP原本的定义中[RFC2616]，用于上传数据的方法只有POST和PUT。后来鉴于POST和PUT语义和功能上的不足，又加入了PATCH方法[RFC5789]。POST与PUT方法的差异是显而易见的，而PUT与PATCH方法就比较相似，但它们的用法却完全不同。</p>
<a id="more"></a>
<p>　　PUT方法和PATCH方法所请求的目标地址都是直接指向资源的，而POST方法请求的目标是一个行为处理器，这点很容易区分。但PUT和PATCH呢？根据规范中所介绍的PUT用于替换资源，而PATCH用于更新部分资源。仅凭这个描述，我无法理解他们的区别，直到看到后面介绍PATCH是非幂等的时候才恍然大悟。</p>
<p>　　从这里开始要考虑一个问题，PATCH为什么是非幂等的呢？POST方法非幂等可以理解，因为它请求服务器执行一个动作，多次发起请求可能导致动作多次执行。而像PATCH这样请求的目标是一个资源的，如果它只是更新一个资源，不执行其它动作，又何来不幂等呢？其实是我忽略了一个问题，PATCH方法和POST方法有个很相似的地方，它们的实体部分都是结构化的数据。POST方法的实体结构一般是 multipart/form-data 或 application/x-www-form-urlencoded 而PATCH方法的实体结构则随其它规范定义。这和PUT方法的无结构实体相比就是最大的区别。</p>
<p>　　PUT方法的实体无结构的，它直接把实体部分的数据替换到服务器的资源上。而PATCH提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的数据。也就是说，PATCH请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是不幂等的了。</p>
<p>　　举个例子，如果服务器上有个资源/abc.int，里面存放一个整数，值为 1。也就是说，GET这个资源的话，服务器响应的实体只包含了 1 这个数字。现在在自己的框架中定义当提交PATCH请求，实体匹配^+\d+$的格式时就对服务器资源中的数字执行一个加法操作。于是当客户端向/abc.int地址发起PATCH请求，实体部分为+3之后，服务器的/abc.int资源中的数据就变成 4，也就是说，GET它会得到 4。如果客户端不小心重复提交了PATCH请求，那么+3就会被再执行一次，这个资源的数据就变成 7。</p>
<p>　　这么一看，PATCH和PUT的区别就非常明显了吧。</p>
<p>序号        方法        描述</p>
<p>1        GET        请求指定的页面信息，并返回实体主体。</p>
<p>2        HEAD        类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</p>
<p>3        POST        向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p>
<p>4        PUT        从客户端向服务器传送的数据取代指定的文档的内容。</p>
<p>5        DELETE        请求服务器删除指定的页面。</p>
<p>6        CONNECT        HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>7        OPTIONS        允许客户端查看服务器的性能。</p>
<p>8        TRACE        回显服务器收到的请求，主要用于测试或诊断。</p>
<p>9        PATCH        实体中包含一个表，表中说明与该URI所表示的原内容的区别。</p>
<p>10        MOVE        请求服务器将指定的页面移至另一个网络地址。</p>
<p>11        COPY        请求服务器将指定的页面拷贝至另一个网络地址。</p>
<p>12        LINK        请求服务器建立链接关系。</p>
<p>13        UNLINK        断开链接关系。</p>
<p>14        WRAPPED        允许客户端发送经过封装的请求。</p>
<p>15        Extension-mothed        在不改动协议的前提下，可增加另外的方法。</p>
<p>草案规范：<a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5789</a></p>
<p><a href="https://tools.ietf.org/html/rfc5789#section-2" target="_blank" rel="noopener">2</a>.  The PATCH Method</p>
<p>The PATCH method requests that a set of changes described in the<br>​    request entity be applied to the resource identified by the Request-<br>​    URI.  The set of changes is represented in a format called a “patch<br>​    document” identified by a media type.  If the Request-URI does not<br>​    point to an existing resource, the server MAY create a new resource,<br>​    depending on the patch document type (whether it can logically modify<br>​    a null resource) and permissions, etc.</p>
<p>Dusseault &amp; Snell            Standards Track                    [Page 2]</p>
<p> <a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">RFC 5789</a>                       HTTP PATCH                     March 2010</p>
<p>The difference between the PUT and PATCH requests is reflected in the<br>​    way the server processes the enclosed entity to modify the resource<br>​    identified by the Request-URI.  In a PUT request, the enclosed entity<br>​    is considered to be a modified version of the resource stored on the<br>​    origin server, and the client is requesting that the stored version<br>​    be replaced.  With PATCH, however, the enclosed entity contains a set<br>​    of instructions describing how a resource currently residing on the<br>​    origin server should be modified to produce a new version.  The PATCH<br>​    method affects the resource identified by the Request-URI, and it<br>​    also MAY have side effects on other resources; i.e., new resources<br>​    may be created, or existing ones modified, by the application of a<br>​    PATCH.</p>
<p>PATCH is neither safe nor idempotent as defined by [<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC2616</a>], <a href="https://tools.ietf.org/html/rfc5789#section-9.1" target="_blank" rel="noopener">Section</a></p>
]]></content>
      <tags>
        <tag>Restfule</tag>
        <tag>HttpMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>PlantUML</title>
    <url>/2011/03/11/plantuml/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PlantUML 是一个开源项目，支持快速绘制（通过简单直观的语言来定义这些示意图）：</p>
<ul>
<li>时序图</li>
<li>用例图</li>
<li>类图</li>
<li>活动图</li>
<li>组件图</li>
<li>状态图</li>
<li>对象图</li>
<li>部署图</li>
<li>定时图</li>
</ul>
<a id="more"></a>
<p>同时还支持以下非 UML 图:</p>
<ul>
<li>线框图形界面</li>
<li>架构图</li>
<li>规范和描述语言 (SDL)</li>
<li>Ditaa diagram</li>
<li>甘特图</li>
<li>以 AsciiMath 或 JLaTeXMath 符号的数学公式</li>
</ul>
<p>PlantUML 本体是一个 plantuml.jar文件, 依赖于 graphviz，graphviz 是一个开源的图片渲染库， 安装了这个库才能在 Windows 下把脚本转换为图片(sequence diagram 和 activity beta diagrams 可以不需要)。</p>
<p>下载 graphviz之后, 设置GRAPHVIZ_DOT环境变量为 <code>path/to/graphviz/release/dot.exe</code>, 使 PlantUML能够找到 dot.exe, 然后使用 <code>java -jar ./plantuml.jar -testdot</code> 测试配置是否成功.</p>
<p>配置完成之后, 新建文件, 在其中写入简单的 Demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Alice -&gt; Bob: test</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>然后执行命令 <code>java -jar plantuml.jar demo.txt</code> 即可生成图片. 也可以直接双击 <code>plantuml.jar</code>文件打开GUI窗口来操作.</p>
<p>PlantUML 几乎可以集成到任何编辑器/IDE/文档工具中, 比如 Sublime Text 中有 <a href="https://github.com/jvantuyl/sublime_diagram_plugin" target="_blank" rel="noopener">PlantUML for Sublime</a> 、Intellij IDEA 、Eclipse、Chrome 中都有相应的插件.在<a href="http://plantuml.com/running" target="_blank" rel="noopener">这里</a>查看如何在你当前的使用的软件中集成 PlantUML。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="http://plantuml.com/PlantUML_Language_Reference_Guide.pdf" target="_blank" rel="noopener">PlanUML 官方文档</a></li>
</ul>
]]></content>
      <tags>
        <tag>开源工具</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP 切点表达式</title>
    <url>/2012/03/28/spring-aop-qie-dian-biao-da-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a><strong>1.概述</strong></h2><p>本文主要记录一下 Spring AOP 中 <em>Pointcut</em> 切点表达式。</p>
<p>关于 AOP 及切点相关的概念可以参考 <a href="/2012/02/25/spring-yuan-ma-fen-xi-aop/">Spring源码解读——AOP</a>。<br><a id="more"></a></p>
<h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h2><p>在基于注解的 AOP 开发过程中，切点表达式主要用于 <em>@Pointcut</em> 注释的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(@org.springframework.stereotype.Repository *)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repositoryClassMethods</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>方法声明称为<strong>切入点签名</strong>，它定义了一个切点范围，后续在创建 <em>Advice</em> 时可以直接引用这个签名，来确定 <em>Advice</em>  的拦截范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"repositoryClassMethods()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">measureMethodExecutionTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过 XML <em>aop:pointcut</em> 配置的方式定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"anyDaoMethod"</span> <span class="attr">expression</span>=<span class="string">"@target(org.springframework.stereotype.Repository)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-切入点指示符"><a href="#3-切入点指示符" class="headerlink" title="3. 切入点指示符"></a>3. 切入点指示符</h2><p>切入点表达式以<strong>pointcut designator（PCD）</strong>开头，告诉Spring AOP要匹配的关键字。下面将介绍常用的指示符，例如方法的执行，类型，方法参数或注解。</p>
<h3 id="3-1-execution"><a href="#3-1-execution" class="headerlink" title="3.1 execution"></a>3.1 <em>execution</em></h3><p><em>execution</em> 是 Spring AOP 中最主要也是最常用的 PCD，它匹配方法执行点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public String com.doleje.dao.FooDao.findById(Long))"</span>)</span><br></pre></td></tr></table></figure>
<p>此示例切入点将严格匹配<em>FooDao</em>类的<em>findById</em>方法的执行。如果我们想更灵活的控制，比如匹配<em>FooDao</em>类的所有方法，它们可能具有不同的签名，返回类型和参数，那么还可以使用通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.doleje.dao.FooDao.*(..))"</span>)</span><br></pre></td></tr></table></figure>
<p>这里第一个 *  匹配任何返回值，第二个 * 任何方法名称，*(..)* 模式匹配任意数量的参数（零或更多）。</p>
<h3 id="3-2-within"><a href="#3-2-within" class="headerlink" title="3.2 within"></a>3.2 <em>within</em></h3><p><em>within</em> 用于匹配某个类或者包内的所有操作，比如我们要实现上一节中的匹配 <em>FooDao</em> 中所有方法还可以用如下的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.doleje.dao.FooDao)"</span>)</span><br></pre></td></tr></table></figure>
<p>我们也可以匹配<em>com.doleje</em> 包或子包中的任何类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.doleje..*)"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-3-this-和-target"><a href="#3-3-this-和-target" class="headerlink" title="3.3 this 和 target"></a>3.3 <em>this</em> 和 <em>target</em></h3><p><em>this</em> 切点函数则通过判断 <strong>代理类</strong> 是否按类型匹配指定类来决定是否和切点匹配。 用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配。 this中使用的表达式必须是类型全限定名，不支持通配符。</p>
<p><em>target</em> 匹配<strong>目标对象</strong>的类型，即被代理对象的类型，例如A继承了B接口，则使用target(“B”)，target(“A”) 均可以匹配到A（因为 A 也是 B 接口的目标对象）。</p>
<p>这两个概念确实比较绕，也很容易弄混。但简单的，你可以记住如下的规则，假设目标类实现了一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooDao</span> <span class="keyword">implements</span> <span class="title">BarDao</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于接口的存在，在这种情况下，Spring AOP将使用基于JDK的动态代理技术，你应该使用<em>target</em> ，因为代理对象将是<em>Proxy</em>类的实例并实现<em>BarDao</em>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.doleje.dao.BarDao)"</span>)</span><br></pre></td></tr></table></figure>
<p>另一方面，如果<em>FooDao</em>没有实现任何接口或者 <em>proxyTargetClass</em> 属性设置为true，则代理对象将是<em>FooDao</em>的子类，并且可以使用<em> this</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"this(com.doleje.dao.FooDao)"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-4-args"><a href="#3-4-args" class="headerlink" title="3.4 args"></a>3.4 <em>args</em></h3><p><em>args</em> 用于匹配特定方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* *..find*(Long))"</span>)</span><br></pre></td></tr></table></figure>
<p>此切入点匹配以find开头的任何方法，并且只有一个<em>Long</em>类型的参数。如果我们想要一个方法与任意数量的参数匹配但是具有<em>Long</em>类型的第一个参数，我们可以使用以下表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* *..find*(Long,..))"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-5-target"><a href="#3-5-target" class="headerlink" title="3.5 @target"></a>3.5 <em>@target</em></h3><p><em>@target</em> 用于匹配某些有特定注解的类，注意，不要与 <em>target</em> 混淆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`@Pointcut``(``&quot;@target(org.springframework.stereotype.Repository)&quot;``)`</span><br></pre></td></tr></table></figure>
<h3 id="3-6-args"><a href="#3-6-args" class="headerlink" title="3.6 @args"></a>3.6 @args</h3><p><em>@args</em> 匹配任何一个只接受一个参数的方法，且方法运行时传入的参数持有该注解的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@args(com.doleje.aop.annotations.Entity)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodsAcceptingEntities</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过 Advice 提供的 <em>JoinPoint</em> 来访问具体的参数以及注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"methodsAcceptingEntities()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMethodAcceptionEntityAnnotatedBean</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Accepting beans with @Entity annotation: "</span> + jp.getArgs()[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-within"><a href="#3-7-within" class="headerlink" title="3.7 @within"></a>3.7 @within</h3><p><em>@within</em> 将匹配具有给定注解的类型中的连接点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(org.springframework.stereotype.Repository)"</span>)</span><br></pre></td></tr></table></figure>
<p>这相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(@org.springframework.stereotype.Repository *)"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-8-annotation"><a href="#3-8-annotation" class="headerlink" title="3.8 @annotation"></a>3.8 @annotation</h3><p><em>@annotation</em> 将匹配添加了某个注解的方法，比如我们定义一个 <em>@Loggable</em> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Loggable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后针对有这个注解的方法添加一个切点：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.doleje.aop.annotations.Loggable)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loggableMethods</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们写一个 <em>Advice</em> 来对匹配到这个切点的方法进行一些切面处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"loggableMethods()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMethod</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">    String methodName = jp.getSignature().getName();</span><br><span class="line">    logger.info(<span class="string">"Executing method: "</span> + methodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-切入点表达式的组合"><a href="#4-切入点表达式的组合" class="headerlink" title="4. 切入点表达式的组合"></a>4. 切入点表达式的组合</h2><p>Pointcut expressions 是可以使用<strong>&amp;&amp;</strong>，<strong>||</strong> 以及 <strong>!</strong> 来组合的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@target(org.springframework.stereotype.Repository)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repositoryMethods</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* *..create*(Long,..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstLongParamMethods</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"repositoryMethods() &amp;&amp; firstLongParamMethods()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entityCreationMethods</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING MVC 介绍</title>
    <url>/2004/10/08/spring-mvc-jie-shao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>最近很多同学也开始使用<code>Spring</code>框架（<a href="http://springframework.org/" target="_blank" rel="noopener">http://springframework.org</a>）做一些网站了，之前给大家推荐的时候好像都还不感冒，甚至都不知道是什么框架，仍然埋头 <code>Struts</code> 和 <code>Hibernate</code> 的学习。</p>
<p>Spring作为当前J2EE编程实践的替代方案而受到欢迎。实际上，<code>Spring</code>提供了在J2EE之外的很多通用功能，用于促进良好的编程实践，例如设计接口，单元测试和灵活性（例如，避免依赖性，可配置性）。</p>
<p><code>Spring</code>的核心是通过配置文件（通常是XML）来组装组件的系统，这个简单的概念被称为控制反转（IoC），好莱坞原则（“不要找我，我会找你”）和依赖注入。</p>
<p>例如，考虑一下我们的 DAO 对象所需要的<code>Connection</code>对象，通常，DAO 将在 JNDI 或其他服务中查找此资源。它通常是主动的去从某个地方去“拉”取这个依赖的资源，这种方法强制了 DAO 对于某个特定资源的依赖，必须很明确的知道这个资源来自哪里，怎么实例化（如果是单例的，还要考虑怎么从工厂方法中引入），从而限制DAO的重用性，灵活性和可测试性。当然，可以使用诸如JNDI之类的让这个查找过程简单一点，但仍然必须手动的去管理这些资源的依赖。</p>
<p>那现在，不妨考虑一种场景，如果我们不让 DAO 自己去“拉”这些依赖的资源，反过来，我们通过其它的一些手段将它需要的资源“推”送给它呢，DAO 本身不需要管理这些依赖资源，只需要关注本身的业务逻辑，是不是更通用一些呢。实际上，这个就是<code>Spring</code>提供的核心理念，让这种资源的依赖管理方式反过来，由<code>Spring</code>容器来主动的推送资源到目标中去，而不需要目标自己去管理，又被称为“依赖注入”。</p>
<p><code>Spring</code>有时被称为轻量级容器，但<code>Spring</code>实际上非常大（大约有1000个类/接口）。轻量级术语更多地指的是它以最少的依赖性集成技术的能力（与需要实现特定接口的许多J2EE解决方案相反）。</p>
<p>使用依赖注入框架作为基础，<code>Spring</code>增加了对应用程序功能的许多常见方面的支持，包括持久化，事务控制，AOP，错误处理和分布式计算等。今天主要简单的给大家讲解一下 Spring MVC 相关的知识，好让其它感兴趣的同学能更清晰的认知<code>Spring</code>，加入到基于<code>Spring</code>的应用开发过程中来，提高效率。</p>
<a id="more"></a>
<h2 id="2-SPRING-MVC"><a href="#2-SPRING-MVC" class="headerlink" title="2. SPRING MVC"></a>2. SPRING MVC</h2><p>和<code>Struts</code>等其它 MVC 框架类似，<code>Spring</code>也采用了熟悉的模型 - 视图 - 控制器架构，如各种基于Web的框架所示， 一个Front <code>Controller</code>Servlet接收系统的所有HTTP请求，并使用定义的映射路由到实际的业务处理程序。这些处理程序通常是<code>Controller</code>接口的实现，但可以是符合框架规范的任何类。在<code>Spring</code>MVC 中，<code>DispatcherServlet</code>作为Front <code>Controller</code>，调用其他<code>Controller</code>s。它在处理请求的过程中执行若干其他任务（所有这些都以高度可配置的方式提供），包括视图映射和专门的异常处理。本文仅简要介绍这些领域，重点介绍<code>Controller</code>s的使用。</p>
<p>控制器类似于Struts Action。它处理请求并返回一个<code>ModelAndView</code>对象，该对象包含一个表示<code>Model</code>（用于表示的数据，类似 <code>Map</code>，实际上它的底层实现就是<code>Map</code>）和一个表示展现层的<code>View</code>。<code>Model</code>大家都很熟悉，也很好理解，<code>View</code>则是 <code>Spring</code>的一个抽象概念，表示一个视图对象，<code>Controller</code>通常会返回一个<code>String</code>（由可配置解析<code>ViewResolver</code>将 <code>String</code>解析成真正的页面）或者实例<code>View</code>（直接使用）来表示要展示的页面，空返回表示控制器已完成请求的处理，无需额外的<code>View</code>操作。</p>
<p><code>Spring</code>框架中存在许多控制器，如下图所示：</p>
<p><img src="/images/pasted-112.png" alt="Spring Framework Diagram"></p>
<p>其中<code>SimpleFormController</code>是这些<code>Controller</code>类中最常用的。虽然名称翻译过来是<em>简单表单控制器</em><code>，但SimpleFormController</code> 具有非平凡的生命周期和相关功能 - 正如上面显示的深层继承层次结构所暗示的那样。我们将依次讨论其基类来详细说明其功能。</p>
<p><code>AbstractController</code>在将请求处理委托给派生类的<code>handleRequestInternal()</code>方法之前，提供一些称之为“低级别”的配置和功能。它生成一些诸如控制缓存的头信息<em>cacheSeconds</em>的属性，根据配置拒绝GET或POST请求，并确保在标记为必需时存在会话，还可以在会话上同步请求以防止同一客户端进行多线程访问等。请注意，<code>Spring</code>与<code>Struts</code>类似，绝大部分<code>Controller</code>是单例重复使用的。（或者，<code>ThrowawayController</code>为每个请求实例化控制器实现。）</p>
<p><code>BaseCommandController</code>将请求参数映射到一个配置好的命令类（类似的<code>Struts</code>的<code>ActionForm</code>，但它是一个非常简单的JavaBean，没有框架的依赖关系）。有时还会注册一个 <em>Validator 验证器</em> 来检查请求内容。注意，该类并未实现 <code>handleRequestInternal()</code>（处理实际的业务逻辑），而是将这部分工作留给它的派生类。它定义了 <code>final bindAndValidate()</code> 来将请求参数绑定到<em>Command Object</em>并验证它的内容。提供了几个钩子来定制这个过程：</p>
<ul>
<li><code>initBinder(request, binder)</code>- 可以覆盖以添加<code>PropertyEditors</code>到binder以处理特殊类型</li>
<li><code>onBind(request, command)</code> - 在绑定后调用，但在验证之前调用。可以重写以执行专门的映射，正确的映射等。</li>
<li><code>onBindAndValidate(request, command)</code> - 验证后调用。例如，可以覆盖以执行其他验证。</li>
</ul>
<p><code>AbstractFormController</code>继承了<code>BaseCommandController</code>并覆盖<code>handleRequestInternal()</code>用于处理GET和POST请求。此类将<em>Command Object</em>（from <code>BaseCommandController</code>）称为表单对象，因此下面将使用此术语。对于POST请求，可以创建表单（命令）对象的默认实例，也可以从会话中检索预先存在的实例（然后删除）。派生<code>AbstractWizardFormController</code>利用会话方法进行多屏输入。会话范围的<em>Command Object</em>也可以用作通过将控制器配置为要求其存在来防止重复表单提交的手段（有关详细信息，请参阅相关的javadocs）。可以通过覆盖<code>formBackingObject()</code>方法来定义初始<em>Command Object</em>。</p>
<p>接下来，使用请求参数填充表单对象<code>BaseCommandController.bindAndValidate()</code>，<code>AbstractFormController</code>没有定义上面提到的任何相应的抽象方法（<code>initBind</code>等等）。最后，业务逻辑处理被委托给抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ModelAndView <span class="title">processFormSubmission</span><span class="params">(HttpServletRequest request,	</span></span></span><br><span class="line"><span class="function"><span class="params">                  HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                  Object command, </span></span></span><br><span class="line"><span class="function"><span class="params">                  BindException errors)</span></span></span><br></pre></td></tr></table></figure>
<p>通过获取<em>Command Object</em>（表单）开始GET请求处理<code>formBackingObject()</code>。这可以被覆盖以提供填充有来自数据库的数据的对象。如果启用，则请求参数然后绑定到<em>Command Object</em>对象，（同样，<code>initBinder()</code>可以专门处理）。最后，处理委托给：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">showForm</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   	 	    HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">	 	    HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">		    BindException errors)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>
<p>具体的类<code>SimpleFormController</code>又增强了一些<code>AbstractFormController</code>功能。可以配置表单和成功视图 - 验证失败将用户返回到表单视图，同时成功验证和后续操作将导致成功视图。通常，派生类只需要覆盖几种<code>onSubmit()</code>方法中的一种来处理表单提交（例如保存到数据库）。</p>
<h2 id="3-MVC-示例"><a href="#3-MVC-示例" class="headerlink" title="3. MVC 示例"></a>3. MVC 示例</h2><p>现在我们来测试验证一下。我们将创建一个简单的表单，用户输入他们的名字并选择他们喜欢的水果。</p>
<h3 id="3-1-实体对象：Fruit"><a href="#3-1-实体对象：Fruit" class="headerlink" title="3.1 实体对象：Fruit"></a>3.1 实体对象：Fruit</h3><p>Fruit类是一个相当标准的JDK 1.5 Java枚举类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map instanceMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit APPLE = <span class="keyword">new</span> Fruit(<span class="number">0</span>, <span class="string">"Apple"</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit ORANGE = <span class="keyword">new</span> Fruit(<span class="number">1</span>, <span class="string">"Orange"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Fruit</span><span class="params">(Long id, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    instanceMap.put(<span class="keyword">new</span> Long(id), <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这也可以作为查找表存储在数据库中。由于这些对象对应于HTML <code>&lt;OPTION&gt;</code>标签的字符串值属性，因此主要问题是将下拉列表映射到服务器管理的对象列表。</p>
<p>要将基于字符串的引用转换为枚举值（反之亦然），我们定义一个专门的<code>java.beans.PropertyEditor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitSupport</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object value = getValue();</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="string">""</span> : ((Fruit)value).getId().toString();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String string)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Long id = Long.valueOf(string);</span><br><span class="line">      Fruit f = Fruit.getById(id);</span><br><span class="line">      <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid id for Fruit: "</span> + string);</span><br><span class="line">      &#125;</span><br><span class="line">      setValue(f);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid id for Fruit: "</span> + string);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Command-Form-类"><a href="#3-2-Command-Form-类" class="headerlink" title="3.2 Command (Form) 类"></a>3.2 Command (Form) 类</h3><p>我们还需要一个JavaBean来表示表单的内容（名称和结果）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormBean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Fruit fruit = Fruit.APPLE;</span><br><span class="line"> </span><br><span class="line">  .. getters and setters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这是一个非常非常简单的 JavaBean ，除了属性及 <em>Getter/Setter</em>外没有任何其它的依赖。</p>
<h3 id="3-3-Spring-配置"><a href="#3-3-Spring-配置" class="headerlink" title="3.3 Spring 配置"></a>3.3 Spring 配置</h3><p>首先我们添加<code>DispatcherServlet</code>到<code>web.xml</code>中，来接管所有的 HTTP 请求（这个就是我们之前提到的 Front Controller Servlet）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">     org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/classes/spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，所有<code>.htm</code>URL都将路由到<code>Spring</code>servlet。除了配置MVC架构的其他方面之外，该<code>spring-servlet.xml</code>文件还定义了<code>DispatcherServlet</code>委托给各种处理程序（此处为 <code>Controller</code>）的映射。下面的部分定义了<code>Controller</code>相关的类及其到URL的映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formController"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">class</span>=<span class="string">"com.ociweb.spring.MyFormController"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"commandName"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>formBeanId<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"commandClass"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.ociweb.spring.FormBean<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;property name="validator"&gt;&lt;ref local="MyValidator"&gt;&lt;/ref&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"formView"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>form<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successView"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>form<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"urlMapping"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/form.htm"</span>&gt;</span>formController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例<code>MyFormController</code>给出一个id<code>formController</code>，并由<code>urlMapping</code>bean 中的id引用，以将URL映射<code>/form.htm</code>到控制器实例。<code>MyFormControllerr</code>的属性如下：</p>
<ul>
<li><code>commandName</code> 定义<em>Command Object</em>的 id</li>
<li><code>commandClass</code> 将我们的表单bean定义为 <code>FormBean</code>的实例</li>
<li><code>formView</code> 如果表单提交失败，则定义要调用的视图</li>
<li><code>successView</code> 如果表单提交成功，则定义要调用的视图</li>
</ul>
<p>请注意，这个例子中<code>formViews</code>和<code>uccessView</code>引用了相同的视图，实际的场景中通常不是这样的，这里只是举例演示用法。</p>
<h3 id="3-4-Controller"><a href="#3-4-Controller" class="headerlink" title="3.4 Controller"></a>3.4 Controller</h3><p>我们演示用的<code>MyFormController</code>比较简单，扩展<code>SimpleFormController</code>并定义了一个默认构造函数来支持<code>Spring</code>实例化。实现<code>initBinder()</code>方法注册<code>PropertyEditor</code>到binder对象以支持我们前面提到的<code>Fruit</code>枚举类型。<code>referenceData()</code>方法获取所有Fruit实例，并将它们放在具有唯一键的映射中，这些内容将在 JSP 页面中使用。</p>
<p>最后，该<code>onSubmit()</code>方法处理来自表单<em>Command Object</em>的数据。虽然存在许多更简单的<code>onSubmit()</code>方法并且可以被覆盖，但在这种情况下需要完整的参数集（<code>Request</code>，<code>Response</code>等）。复杂性在于返回表单页面，同时保持提供的项目列表<code>referenceData()</code>。在成功提交表单时，不会调用此方法，从而产生一个空列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFormController</span> <span class="keyword">extends</span> <span class="title">SimpleFormController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyFormController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ServletRequestDataBinder binder)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    binder.registerCustomEditor(Fruit<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FruitSupport</span>())</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Map <span class="title">referenceData</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map retval = <span class="keyword">new</span> HashMap();</span><br><span class="line">    retval.put(<span class="string">"fruits"</span>, Fruit.getAll());</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">onSubmit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                        Object command,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BindException errors)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">    FormBean form = (FormBean)command;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Act on form submission (e.g. write to database)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Redirect back to form</span></span><br><span class="line">    <span class="comment">// This will ensure referenceData is set, etc.</span></span><br><span class="line">    <span class="comment">// This is needed when submit action fails despite success of earlier validation.</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> showForm(request, response, errors);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-JSP-页面"><a href="#3-5-JSP-页面" class="headerlink" title="3.5 JSP 页面"></a>3.5 JSP 页面</h3><p>最后，JSP页面用于<code>/form.htm</code>定义<code>View</code>。<code>Spring</code>为许多不同的View选项提供了轻松集成，包括JSP，XSLT，Velocity和FreeMarker。视图可以很容易地与不同的处理程序集成。关于JSP，<code>Spring</code>只支持少量自定义标签，只有一个<code>spring:bind</code>是常用的。我们写的<code>form.jsp</code>页面同时演示了它与JSTL的用法。</p>
<p>本质上，<code>spring:bind</code>标记创建一个本地上下文，其中  <code>status</code> 变量与HTML标签中引用的变量的绑定相关联。 <code>status</code> 包含上次验证尝试的结果，值绑定和属性的标识符。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">"post"</span>&gt;</span><br><span class="line">&lt;spring:bind path=<span class="string">"formBeanId.name"</span>&gt;</span><br><span class="line">  &lt;br/&gt;Name   :  &lt;input name=<span class="string">"name"</span> value=<span class="string">"&lt;c:out value="</span>$&#123;status.value&#125;<span class="string">"&gt;&lt;/c:out&gt;"</span>&gt;&lt;br&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">&lt;/spring:bind&gt;</span><br><span class="line"> </span><br><span class="line">&lt;spring:bind path=<span class="string">"formBeanId.fruit"</span>&gt;</span><br><span class="line">  Favorite Fruit:   </span><br><span class="line">  &lt;select name=<span class="string">"fruit"</span>&gt;</span><br><span class="line">    &lt;c:forEach <span class="keyword">var</span>=<span class="string">"fruitType"</span> items=<span class="string">"$&#123;fruits&#125;"</span>&gt;</span><br><span class="line">      &lt;option value=<span class="string">"&lt;c:out value="</span>$&#123;fruitType.id&#125;<span class="string">"&gt;&lt;/option&gt;"</span> </span><br><span class="line">        &lt;c:if test="$&#123;fruitType.id == status.value&#125;"&gt; selected="selected"&lt;/c:if&gt; </span><br><span class="line">      &gt;</span><br><span class="line">        &lt;c:out value="$&#123;fruitType.name&#125;"&gt;&lt;/c:out&gt;</span><br><span class="line">      &lt;/option&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/spring:bind&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> name=<span class="string">"Submit"</span> value=<span class="string">"Submit"</span>&gt;</span><br><span class="line">&lt;br/&gt;&lt;br /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-摘要"><a href="#4-摘要" class="headerlink" title="4. 摘要"></a>4. 摘要</h2><p>本文仅涉及<code>SpringMVC</code>框架的简单使用方式，并没有涉及 <code>Spring</code>的其它部分，实际上<code>Spring</code>在系统的其他层提供了许多好处，包括与JDO和Hibernate的集成。作为一种通用方法，它促进并简化了测试驱动开发（TDD），它促进了许多有益的设计和开发实践。</p>
<p><code>Spring</code>正在非常积极的发展和工具整合不断改进。例如，计划的增强功能包括与JSF，JMX和AspectJ的新集成或改进集成。XDoclet支持是可用的，还有一个Eclipse插件。鼓励大家学习研究一个这个<code>Spring</code>框架。</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot/Cloud 的背后</title>
    <url>/2018/03/23/spring-boot-cloud-de-bei-hou/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-45.png" alt="upload successful"></p>
<p>我们刚开始学习 Spring Boot 的时候肯定都会看到这么一句话：</p>
<blockquote>
<p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。</p>
</blockquote>
<p>这里的 Pivotal 团队肯定就是 Spring Boot 的研发团队了，那么这个 Pivotal 团队到底是个什么来头呢？和 Spring 又有那些关系？不着急且听我慢慢道来。</p>
<p>要说起这个 Pivotal 公司的由来，我得先从 Spring 企业的这条线来说起。<br><a id="more"></a></p>
<h3 id="Spring-的发展"><a href="#Spring-的发展" class="headerlink" title="Spring 的发展"></a>Spring 的发展</h3><p>时间回到 2002 年，当时正是 Java EE 和 EJB 大行其道的时候，很多知名公司都是采用此技术方案进行项目开发。这时候有一个美国的小伙子认为 EJB 太过臃肿，并不是所有的项目都需要使用 EJB 这种大型框架，应该会有一种更好的方案来解决这个问题。</p>
<p>他为了证明自己的想法是正确的，在 2002 年 10 月写了一本书《Expert One-on-One J2EE》，介绍了当时 Java 企业应用程序开发的情况，并指出了 Java EE 和 EJB 组件框架中存在的一些主要缺陷。在这本书中，他提出了一个基于普通 Java 类和依赖注入的更简单的解决方案。</p>
<p>在书中，他展示了如何在不使用 EJB 的情况下构建高质量、可扩展的在线座位预留系统。为了构建应用程序，他编写了超过 30,000 行的基础结构代码，项目中的根包命名为 com.interface21，所以人们最初称这套开源框架为 interface21，这就是 Spring 的前身。</p>
<p>这个小伙子是谁呢？他就是大名鼎鼎的 Rod Johnson（下图），Rod Johnson 在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位，更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。现在 Rod Johnson 已经离开了 Spring，成为了一个天使投资人，同时也是多个公司的董事，早已走上人生巅峰。</p>
<p><img src="/images/pasted-46.png" alt="upload successful"></p>
<p>在这本书发布后，一对一的 J2EE 设计和开发一炮而红。这本书免费提供的大部分基础架构代码都是高度可重用的。2003 年 Rod Johnson 和同伴在此框架的基础上开发了一个全新的框架命名为 Spring，据 Rod Johnson 介绍 Spring 是传统 J2EE 新的开始，随后 Spring 发展进入快车道。</p>
<ul>
<li>2004 年 03 月，1.0 版发布。</li>
<li>2006 年 10 月，2.0 版发布。</li>
<li>2007 年 11 月，更名为 SpringSource，同时发布了 Spring 2.5。</li>
<li>2009 年 12 月，Spring 3.0 发布。</li>
<li>2013 年 12 月，Pivotal 宣布发布 Spring 框架 4.0。</li>
<li>2017 年 09 月，Spring 5.0 发布。</li>
</ul>
<p>网上有一张图，清晰的展示了 Spring 发展：</p>
<p><img src="/images/pasted-47.png" alt="upload successful"></p>
<p>从上面这个时间线我们可以看出 Pivotal 团队和 Spring 在 2013 年交上了线，这是为什么呢？</p>
<blockquote>
<p>友情提示，接下来科技行业的一系列商业并购大片即将开启。</p>
</blockquote>
<h3 id="Pivotal-公司"><a href="#Pivotal-公司" class="headerlink" title="Pivotal 公司"></a>Pivotal 公司</h3><p>上面说的 Pivotal 团队是指 Pivotal 公司，先给大家来一段 Pivotal 公司的简介：</p>
<blockquote>
<p>Pivotal 成立于2013年4月，致力于“改变世界构造软件的方式（We are transforming how the world builds software）”，提供云原生应用开发 PaaS 平台及服务，帮助企业客户采用敏捷软件开发方法论，从而提高软件开发人员工作效率、减少运维成本，实现数字化转型、IT 创新，并最终实现业务创新。</p>
<p>截至目前，财富 100 强中超过三分之一的企业使用 Pivotal 云原生平台。Pivotal 部分大型客户在采用 Pivotal 产品后，开发人员与运营人员比例可提高到 200:1，开发人员专注于编写软件代码时间增长了 50%。</p>
</blockquote>
<p>看了简介大家可能会有点犯迷糊，这不是一个 2013 年成立的 IT 服务公司吗，和 2002 年发展起来的 Spring 又是怎么扯上关系的呢？其实呀，要说起 Pivotal 公司的起源要追溯到 1989 年的 Pivotal Labs 实验室。</p>
<p><img src="/images/pasted-49.png" alt="upload successful"></p>
<p>Pivotal Labs 公司</p>
<p>1989 年，Rob Mee 创立的咨询公司 Pivotal Labs，专注于快速的互联网式软件开发，即敏捷编程。创立 Pivotal Labs 的时候，它还是一家非常小的软件顾问公司，它的主营业务就是与客户合作，帮助客户开发软件。</p>
<p>Pivotal Labs 一直是敏捷开发领域的领导者，为部分硅谷最有影响力的公司塑造了软件开发文化，并树立了良好口碑，其中 Google、Twitter 都曾是 Pivotal Labs 客户。</p>
<p>时间很快到了 2012 年，深受客户喜爱的 Pivotal 终于引起了商用软件巨头 EMC 的关注，EMC 在 2012 年以现金方式收购了 Pivotal 并照单全收了它的 200 名员工。</p>
<p>刚开始的时候，公司并没有发生太大的变化，只是作为新部门成为了 EMC 的一部分，Pivotal Labs 仍然继续像以前样与客户合作。</p>
<p>但是到 2013 年的时候，EMC 突然扔下了一颗重磅炸弹。它将 Pivotal Labs 的核心业务分拆出去，成立了一家名为 Pivotal Software 的新公司。这家新公司的股东是 EMC 、 VMware 和通用电气，之前在 EMC 子公司 VMware 担任首席执行官的马瑞兹出任公司的首席执行官。</p>
<p>EMC 和 VMware 分拆出其 Cloud Foundry、Pivotal Labs、Greenplum 等云计算、大数据资源，GE 投资 1.05 亿美元，成立新公司 Pivotal。新生的 Pivotal 是名副其实的“富二代”，这轮估值高达 10.5 亿美元。</p>
<p>那么 EMC 和 VMware 又有什么关联呢？</p>
<p>2003 年 12 月， EMC 公司宣布以 6.35 亿美元收购了 VMware 公司。</p>
<p>EMC 于 1979 年成立于美国麻州 Hopkinton 市，1989 年开始进入企业数据储存市场。二十多年来，EMC 全心投注在各项新的储存技术，已获得了 1,300 个已通过或审核中的储存技术专利。无论是全球外接 RAID 储存系统、网络储存亦或是储存管理软件等储存专业领域，EMC 均是业界公认的领导厂商。</p>
<p>EMC 是全球第六大企业软件公司，全球信息基础架构技术与解决方案的领先开发商与提供商。同时也是美国财富五百强之一，在全世界拥有超过四万二千名员工，在全球 60 个国家或地区拥有分支机构。我们接触比较多就是 EMC 的各种存储产品。</p>
<p>EMC 公司做大 EMC 的秘诀，就是研发与并购双轮驱动，研发与并购的投入占当年营业收入的 22% 左右，并购投入略高于研发。从 2003 年到2 015 年的 12 年间，EMC 总共投入超过 420 亿美元用于研发和收购。其中，206 亿美元用于研发，213 亿美元用于并购，总共并购了 100 多家公司。</p>
<p>VMware 收购 Spring</p>
<p>2009 年是 Spring 企业的一个转折点，VMware 以 4.2 亿美元收购 Spring Source (3.6亿现金外加5800万股份） 。</p>
<p><strong>可以说虚拟化就是 VMware 发明的</strong></p>
<p>VMware 于 1998 年成立，公司总部位于美国加州帕洛阿尔托，是全球云基础架构和移动商务解决方案厂商，提供基于VMware的解决方案，企业通过数据中心改造和公有云整合业务，借助企业安全转型维系客户信任，实现任意云端和设备上运行、管理、连接及保护任意应用。2018 财年全年收入 79.2 亿美元。</p>
<p>相信作为研发人员肯定都使用过 VMware 公司的产品，最常用的是 VMware 的虚拟机产品，但其实 VMware 公司的产品线非常多。</p>
<p>从发展路线来看，VMware 具备三大特点：</p>
<ul>
<li>第一，是技术具备领先性，虚拟化技术在70年代就已出现，但VMware是第一个将这项技术应用到X86服务器上，并在这个基础上不断完善，使其能够满足企业级客户需求；</li>
<li>第二，是瞄准大型企业客户。VMware 刚刚上市时，年营收不到4亿美金，但已经覆盖80%的财富1000强客户；</li>
<li>第三，是高度产品化。VMware 的毛利率长期保持在 85% 左右，咨询业务占比非常少，几乎将所有部署工作都交给合作伙伴。</li>
</ul>
<p>VMware 也是一个并购大户，通过投资和收购补全业务线，客户资源是一大优势。</p>
<p><img src="/images/pasted-50.png" alt="upload successful"></p>
<blockquote>
<p>2012 年 Rod Johnson 宣布他将要离开 Spring Source 。</p>
</blockquote>
<h3 id="EMC-又被收购"><a href="#EMC-又被收购" class="headerlink" title="EMC 又被收购"></a>EMC 又被收购</h3><p>2015 年的时候，曾经被大量报道 EMC 考虑被子公司 VMware 收购，让人大跌眼镜，竟然可以有这样的骚动作，这是为什么呢？</p>
<p>EMC 在 2003 年斥资 6.25 亿美元收购了 VMware，四年之后，EMC 选择让 VMware 分拆上市，结果独立上市的 VMware 发展越来越好，反观 EMC 的各项业务持续陷入低潮。到 2015 年的时候，VMware 的市值已达到约 370 亿美元，占据了 EMC 总市值的近 75%。</p>
<p>可能各方利益不能达成一致，最终 EMC 却被戴尔（dell）收购。</p>
<p>2015 年 10 月 12 日，戴尔（Dell）和EMC（易安信）公司宣布签署最终协议，戴尔公司与其创始人、主席和首席执行官麦克尔•戴尔，与 MSD Partner 以及银湖资本一起，收购 EMC 公司，交易总额达 670亿 美元，成为科技史上最大并购。</p>
<p>当时业界最关心的云计算软件商 VMware 仍然保持独立上市公司的身份。据悉，EMC 当前持有 VMware 大约 80% 的股权，市值约为 320 亿美元。而戴尔收购 EMC 实际上是项庄舞剑，VMware 才是戴尔收购 EMC 的关键。</p>
<p>戴尔的故事</p>
<p>1984 年，创办人迈克尔·戴尔在德州大学奥斯汀分校就学时创立了 PCs Limited 这家计算机公司。在 1985 年，公司生产了第一部拥有自己独特设计的计算机“Turbo PC”，售价为 795 美元。从此开启了戴尔公司的发展史，下面为戴尔公司的里程碑</p>
<ul>
<li>1984年 - 年仅19岁的Michael Dell凭借1,000美元的资金建立了PC’s Limited，并且树立了颠覆技术行业的愿景。</li>
<li>1988年 - 我们完成了首次公开募股，募集了3,000万美元资金，公司市值从1,000美元增长到8500万美元。</li>
<li>1992年 - 戴尔跻身财富500强公司行列，Michael Dell也成为榜单上最年轻的CEO。</li>
<li>1996年 - Dell.com上线，该站点上线仅六个月之后，每天销售额即达100万美元。</li>
<li>2001年 - 戴尔成为 全球第一大计算机系统提供商。</li>
<li>2005年 - 在《财富》杂志的“美国最受赞赏公司”排名中，戴尔位列第一。</li>
<li>2010年 - 戴尔被 Gartner, Inc.评为世界第一大医疗保健信息技术服务提供商。</li>
<li>2013年 - Michael Dell携手私人股本公司Silver Lake Partners，从公众股东手里买回了戴尔股份，旨在加快解决方案战略的实施并专注于大多数客户重视的创新和长期投资。</li>
<li>2016年 - 戴尔与EMC合并为Dell Technologies，这是业内最大的技术集成事件。</li>
<li>戴尔提供的工作</li>
</ul>
<p>2018年的时候又传出，VMware 反收购戴尔？写到这里的时候我都感觉有点乱了？戴尔收购了 EMC， ECM 收购了 VMware ，那么 VMware 就差不多算戴尔的重孙子，那么怎么又来 VMware 反收购戴尔？</p>
<p>原来是这样，在 2015 年 10 月 12 日业界正式爆料戴尔收购 EMC（包括 VMware），当时的 VMware 股价在 60－70 美元左右。到了 2016 年 9 月戴尔宣布正式并购 EMC 包括 VMware，只是让 VMware 独立运营，VMware 当时股价也还是在 70 美元左右。</p>
<p>可是到了 2018 年初一看，VMware 股价已经到达了 130 多美元，在 2018 年的最高点，股价甚至达到了 160 多美元，股价又 TM 涨了一倍多，VMware 公司简直发展太好了。VMware 最新的市值快到了 600 亿美金，当初收购时 VMware 市值也就 200 多亿美金，简直赚翻了呀！</p>
<p>传言只是传言，最终 2018 年 7 月，戴尔还是选择了独立上市，拥有 VMware 80% 的股份。</p>
<p>并购时间表</p>
<p>上面写的有点乱，大家看完之后也许有点迷糊，在这里重新整理一下这里面几个关键公司的收购时间点：</p>
<ul>
<li>1989 年，Rob Mee 创立的咨询公司 Pivotal Labs;</li>
<li>2003 年，Rod Johnson 和同伴创建了 Spring；</li>
<li>2003 年，EMC 收购了 VMware 公司；</li>
<li>2009 年，VMware 收购了 Spring ;</li>
<li>2012 年，EMC 又收购了 Pivotal Labs 公司；</li>
<li>2013 年，EMC 、 VMware 和收购来的 Pivotal Labs 公司重新组建了新的公司 Pivotal;</li>
<li>2015 年，戴尔又并购了 EMC;</li>
<li>2018 年，戴尔独立上市。</li>
</ul>
<p>接着说 Pivotal 公司</p>
<p>上面一系列的商业并购搞的眼花缭乱的，但是大家只要知道 Pivotal 公司出身高贵，来自几个都不太差钱的世界 500 强公司联合组建而成，Pivotal 公司的产品非常的高大上，就连我们平时使用的 12306 都使用了他们公司的产品。</p>
<p>Pivotal 公司可谓是大牛云集，公司的开源产品有：Spring 以及 Spring 衍生产品、Web 服务器 Tomcat、缓存中间件 Redis、消息中间件 RabbitMQ、平台即服务的 Cloud Foundry、Greenplum 数据引擎、还有大名鼎鼎的 GemFire（12306 系统解决方案组件之一）。</p>
<p>这些著名开源产品背后的开发者都在 Pivotal 公司，其研发团队汇集了全球的一流开发者，Spring Boot 为什么如此优秀，或许在这里可以找到一些答案。</p>
<p>Pivotal 中国研发中心在中国创建于 2010 年，它的前身是 EMC Greenplum 部门，其团队成员分布在北京和上海两地，目前正致力于以下产品的研发和服务的提供：Pivotal Web Service (PWS), Pivotal Hadoop (PHD), Hawq 和 Greenplum Database (GPDB)。</p>
<p>毕威拓科技（北京）有限公司（Pivotal中国公司）2015年3月1日正式成立并单独运营。</p>
<p>Pivotal 公司成立之后，于 2014 年发布了 Spring Boot，2015 年发布了 Spring Cloud，2018 年 Pivotal 公司在纽约上市。我们可以通过一张图来了解 Pivotal 公司的发展史。</p>
<p><img src="/images/pasted-51.png" alt="upload successful"></p>
<p>Pivotal 的定位是一家下一代云计算和大数据应用相结合的公司，而 VMWare 和原 EMC 的业务方向则依然是软件定义数据中心和信息基础架构。</p>
<p>官网这样介绍他们的产品：Pivotal 提供的工具能够帮助开发人员构建更出色软件，可让您在任意云环境中运行应用的平台，帮助您打造未来。</p>
<p>公司的产品主要分为三大类：部署和运行软件，规划、构建和集成软件，分析和决策</p>
<h3 id="部署和运行软件"><a href="#部署和运行软件" class="headerlink" title="部署和运行软件"></a>部署和运行软件</h3><ul>
<li>Pivotal Cloud Foundry (PCF)，用于快速交付应用、容器和函数的多云平台。</li>
<li>PCF: Pivotal Application Service，</li>
<li>在具有内置日志记录、监控和自动扩展功能且高度可用的自助服务平台上，运行使用任意语言构建的应用。</li>
<li>PCF: Pivotal Container Service，基于企业级Kubernetes环境构建应用，该环境采用按需群集、滚动升级和VMware NSX提供的软件定义的网络。</li>
<li>Pivotal Services Marketplace，</li>
<li>将您的应用与托管、代理或按需服务相结合。产品涵盖数据管理、API管理、消息传递、日志记录等。</li>
</ul>
<h3 id="规划、构建和集成软件"><a href="#规划、构建和集成软件" class="headerlink" title="规划、构建和集成软件"></a>规划、构建和集成软件</h3><ul>
<li>Spirng Boot，借助领先的Java框架快速构建功能强大的应用和服务。</li>
<li>Spirng Cloud，</li>
<li>将经过验证的微服务模式融入您的软件。提供配置存储、服务发现、消息传递等功能。</li>
<li>Steeltoe，受 Spring Cloud 启发，用该框架构建恢复力强、可扩展的.NET应用。</li>
<li>Pivotal Cloud Cache，采用基于 Pivotal GemFire 的快速且高度可用的缓存，可提供地理复制和后台写入功能。</li>
<li>Pivotal GemFire，利用可扩展、事件驱动的分布式数据网格执行内存中计算。12306采用的商业方案。</li>
<li>RabbitMQ，借助这款广受欢迎的消息传递代理，分离服务并扩展处理进程。</li>
<li>Pivotal Tracker，经过验证的项目管理工具，帮您打造成功的敏捷团队。</li>
<li>Concourse，利用自动化管道实现 PCF 的持续升级。</li>
</ul>
<h3 id="分析和决策"><a href="#分析和决策" class="headerlink" title="分析和决策"></a>分析和决策</h3><ul>
<li>Pivotal Greenplum，使用这个功能齐全的多云大规模并行处理(MPP)数据平台，可以对大型数据集进行高级分析。。</li>
<li>Apache MADlib，通过采用数据并行方式实施多结构数据的数学、统计和机器学习方法来执行数据库内分析。</li>
</ul>
<p>Pivotal 公司的产品有 Spring Boot 、Spring Cloud 、RabbitMQ 等非常著名的开源软件，也有很多类似 GemFire 等商业解决方案，通过他们公司的产品即可发现，一边通过开源软件打造生态，一方面通过商业解决方案来挣钱。</p>
<p>曾经有一段时间，有人就问我一个问题，说开源的是不是就意味着是免费的，不免费的服务，是不是就意味着不是开源的软件？这种商业模式其实就是对这种观点的一种反驳，开源不等于免费，开源是一种开放分享的精神，不要什么东西来到国内都变味了。</p>
<p>Pivotal 掌握很多最新前沿的开源技术，公司提供的从云端部署到一整套的大数据解决方案，从开发到平台到提供解决方案到提供咨询，可以说真正依赖技术挣钱的典范，我辈之楷模！</p>
]]></content>
      <tags>
        <tag>业界传奇</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cache 性能分析</title>
    <url>/2016/04/19/spring-cache-xing-neng-fen-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>缓存是我们经常在提高应用性能的手段，Spring 对缓存的支持也非常好，我们通常只需要添加 <code>&lt;cache:annotation-driven /&gt;</code> 配置，选择合适的 <em>CacheManager</em>  及底层的缓存实现框架，即可在需要缓存的方法中通过 <em>@Cacheable</em> 来完成缓存接入了，如果你使用 SpringBoot 那么整个接入过程则更加的简单，只需要在 <em>maven</em> 中添加缓存相关的 <em>starter</em> 即可（具体的接入过程可以参考 <a href="https://docs.spring.io/spring/docs/5.1.4.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">Spring Cache</a>）。</p>
<p>本文主要关注 Spring Cache 通用的基于注解的的解决方案和手动的缓存操作之间的性能对比。</p>
<a id="more"></a>
<h2 id="2-测试用例——简单KEY"><a href="#2-测试用例——简单KEY" class="headerlink" title="2. 测试用例——简单KEY"></a>2. 测试用例——简单KEY</h2><h3 id="2-1-用例场景"><a href="#2-1-用例场景" class="headerlink" title="2.1 用例场景"></a>2.1 用例场景</h3><p>为了测试几种场景，我们写了一个简单的基于 SpringBoot 的测试，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheService</span><span class="params">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">        cache = cacheManager.getCache(<span class="string">"time"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">noCache</span><span class="params">(String dummy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(<span class="string">"time"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">annotationBased</span><span class="params">(String dummy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">manual</span><span class="params">(String dummy)</span> </span>&#123;</span><br><span class="line">        Cache.ValueWrapper valueWrapper = cache.get(dummy);</span><br><span class="line">        <span class="keyword">long</span> result;</span><br><span class="line">        <span class="keyword">if</span> (valueWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = System.currentTimeMillis();</span><br><span class="line">            cache.put(dummy, result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = (<span class="keyword">long</span>) valueWrapper.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：这个例子（获取当前时间）并不是真实的业务场景，也完全不符合缓存的使用原则，仅仅只是用来作为演示的目的</p>
</blockquote>
<p>分别采用 3 种不同的方法来测试我们的性能，分别是：</p>
<ul>
<li><em>noCache</em>：无缓存</li>
<li><em>annotationBased</em>：基于注解的缓存</li>
<li><em>manual</em>：手动操作缓存</li>
</ul>
<h3 id="2-2-基准测试"><a href="#2-2-基准测试" class="headerlink" title="2.2 基准测试"></a>2.2 基准测试</h3><p>然后我们针对这3种分别进行基准测试，关于基准测试的知识，如果不了解的可以查阅我的另外一篇博客：<a href="/2016/03/09/xing-neng-ce-shi-li-qi-jmh-kuang-jia">性能测试利器：JMH</a>，基准测试类如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext context;</span><br><span class="line">    <span class="keyword">private</span> CacheService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == context) &#123;</span><br><span class="line">            context = SpringApplication.run(SpringbootDemoApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            service = context.getBean(<span class="string">"service"</span>, CacheService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TearDown</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != context) &#123;</span><br><span class="line">            context.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line">    <span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nocache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.noCache(<span class="string">"const"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line">    <span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">annotationBased</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.annotationBased(<span class="string">"const"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line">    <span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">manual</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.manual(<span class="string">"const"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(CacheBenchmark<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">timeUnit</span>(<span class="title">TimeUnit</span>.<span class="title">NANOSECONDS</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">threads</span>(1)</span></span><br><span class="line"><span class="class">                .<span class="title">forks</span>(2)</span></span><br><span class="line"><span class="class">                .<span class="title">warmupIterations</span>(5)</span></span><br><span class="line"><span class="class">                .<span class="title">measurementIterations</span>(10)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">                .<span class="title">shouldFailOnError</span>(<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">shouldDoGC</span>(<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-结果分析"><a href="#2-3-结果分析" class="headerlink" title="2.3 结果分析"></a>2.3 结果分析</h3><p>这个用例在我本机的测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Run complete. Total time: 00:02:42</span><br><span class="line"></span><br><span class="line">Benchmark                       Mode  Cnt    Score    Error  Units</span><br><span class="line">CacheBenchmark.annotationBased  avgt   20  337.636 ± 24.020  ns/op</span><br><span class="line">CacheBenchmark.manual           avgt   20   20.028 ±  0.697  ns/op</span><br><span class="line">CacheBenchmark.nocache          avgt   20   19.153 ±  1.465  ns/op</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：由于机器的性能各不相同，这里并不比较绝对值</p>
</blockquote>
<p>由于我们的用例仅仅只是返回当前的时间，执行时间几乎可以忽略，所以可以看到我们的 <strong>无缓存</strong> 方案的性能是最好的，该方案仅仅用作基准，不参与比较。</p>
<p>但是，对于有缓存的情况（时间单位采用的是 <em>NANOSECOND</em>），结果可能令大多数人吃惊，手动操作缓存与基于Spring注解的缓存方案差距非常大，有 <em>337.636/19.153 = 17.628</em> 倍之多（本机测试数据而言）。</p>
<h2 id="3-测试用例——SpEL"><a href="#3-测试用例——SpEL" class="headerlink" title="3. 测试用例——SpEL"></a>3. 测试用例——SpEL</h2><h3 id="3-1-用例"><a href="#3-1-用例" class="headerlink" title="3.1 用例"></a>3.1 用例</h3><p>这次我们测试一下带有 SpEL 的缓存 KEY 场景，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">manual</span><span class="params">(String dummy, String dummy2)</span> </span>&#123;</span><br><span class="line">    String key = dummy + dummy2;</span><br><span class="line">    Cache.ValueWrapper valueWrapper = cache.get(key);</span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (valueWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = System.currentTimeMillis();</span><br><span class="line">        cache.put(key, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = (<span class="keyword">long</span>) valueWrapper.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"time"</span>, key = <span class="string">"#p0.concat(#p1)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">annotationWithSpel</span><span class="params">(String dummy1, String dummy2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"time"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">annotationBased</span><span class="params">(String dummy1, String dummy2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是 3 种方法：</p>
<ul>
<li><em>manual</em>：完全手动的完成 KEY 的拼接及缓存的控制</li>
<li><em>annotationBased</em>：基于注解，并使用默认的 KEY 生成机制</li>
<li><em>annotationWithSpel</em>：基于注解，并通过 SpEL 指定 KEY 的生成方式</li>
</ul>
<h3 id="3-2-基准测试"><a href="#3-2-基准测试" class="headerlink" title="3.2 基准测试"></a>3.2 基准测试</h3><p>测试过程和之前一样，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">manual</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.manual(<span class="string">"const"</span>, <span class="string">"const"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">annotationBased</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.annotationBased(<span class="string">"const"</span>, <span class="string">"const"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">annotationWithSpel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.annotationWithSpel(<span class="string">"const"</span>, <span class="string">"const"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-结果分析"><a href="#3-3-结果分析" class="headerlink" title="3.3 结果分析"></a>3.3 结果分析</h3><p>测试的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                           Mode  Cnt     Score     Error  Units</span><br><span class="line">CacheBenchmark2.annotationBased     avgt   20   380.550 ±  39.698  ns/op</span><br><span class="line">CacheBenchmark2.annotationWithSpel  avgt   20  1582.346 ± 122.755  ns/op</span><br><span class="line">CacheBenchmark2.manual              avgt   20    35.999 ±   0.598  ns/op</span><br></pre></td></tr></table></figure>
<p>同样的，手动操作缓存要比基于注解的方式快 <em>（380.550 / 35.999 = 10.571）</em> 倍，相比 SpEL 要快 <em>（1582.346 / 35.999 = 43.955）</em> 倍。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>如上分析所见，针对特定问题的自定义解决方案比通用解决方案快 <em>15 - 45</em> 倍。当然，这绝不是指责 Spring 是一个缓慢的框架，或者大部分场景下，几百纳秒的差距并不会对应用有实质性的影响！</p>
<p>实际上，对于一个如此通用的框架而言，Spring 要做的绝不是在每一个点上都完美的提供既兼容易用性又能完全保证性能优势的方案，而是在满足绝大多数应用场景的情况下提供极高的开发效率与易用性的平衡。</p>
<p>但是，我们仍然会说几百纳秒，这在大多数情况下可能是微不足道的时间差，但在极少数情况下，仍然有一些优化的意义，如果我们的应用有着分毫必究的性能要求，那么不妨试试手动的缓存操作。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Controller 状态码</title>
    <url>/2016/01/26/spring-controller-zhuang-tai-ma/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本文将演示<strong>从Spring MVC控制器返回自定义HTTP状态代码</strong>的几种方法。</p>
<p>状态码使用HTTP协议的完整丰富语义向客户端表达请求的结果并，状态码在响应的头部，会更快的传递给客户端，以便客户端能更快速地做出响应。例如，如果请求出现问题，则为每种可能的问题发送特定的错误代码将允许客户端向用户显示适当的错误消息。<br><a id="more"></a></p>
<h2 id="2-返回自定义状态代码"><a href="#2-返回自定义状态代码" class="headerlink" title="2. 返回自定义状态代码"></a>2. 返回自定义状态代码</h2><p>Spring提供了一些从<em>Controller</em>类返回自定义状态代码的主要方法：</p>
<ul>
<li>使用<em>ResponseEntity</em></li>
<li>在异常类上使用<em>@ResponseStatus</em>注释，以及</li>
<li>使用<em>@ControllerAdvice</em>和<em>@ExceptionHandler</em>注释。</li>
</ul>
<p>这些选择不是相互排斥，实际上可以相互补充。</p>
<h3 id="2-1-通过ResponseEntity返回状态代码"><a href="#2-1-通过ResponseEntity返回状态代码" class="headerlink" title="2.1 通过ResponseEntity返回状态代码"></a>2.1 通过ResponseEntity返回状态代码</h3><p>在标准的Spring MVC控制器中，我们将定义一个简单的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/controller"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">sendViaResponseEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在收到对 “<em>/ controller</em>  “的GET请求后，Spring将返回一个包含406 Code（Not Acceptable）的响应。我们任意选择了此示例的特定响应代码。您可以返回任何HTTP状态代码（可在<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">此处</a>找到完整列表）。</p>
<h3 id="2-2-通过异常返回状态代码"><a href="#2-2-通过异常返回状态代码" class="headerlink" title="2.2 通过异常返回状态代码"></a>2.2 通过异常返回状态代码</h3><p>我们将向控制器添加第二个方法，以演示如何使用<em>Exception</em>返回状态代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/exception"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">sendViaException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ForbiddenException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收到对” <em>/ exception</em> “ 的GET请求后，Spring将抛出<em>ForbiddenException</em>，然后在在单独的类中定义的自定义异常处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.FORBIDDEN)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForbiddenException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>所有工作都由<em>@ResponseStatus</em>注释完成。</p>
<p>在这种情况下，当抛出异常时，抛出异常的控制器返回响应代码403（禁止）的响应。如有必要，您还可以在注释中添加将与响应一起返回的消息。</p>
<p>在这种情况下，该类将如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">esponseStatus(value = HttpStatus.FORBIDDEN, reason=<span class="string">"To show an example of a custom message"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForbiddenException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，尽管在技术上可以使异常返回任何状态代码，但在大多数情况下，仅使用错误代码的异常（4XX和5XX）才具有逻辑意义。</p>
</blockquote>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Redis</title>
    <url>/2016/03/26/spring-data-redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p> <a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>是当前最流行的基于内存的 K-V 数据库（通常被用作高性能缓存），本文是<strong>对Spring Data Redis的介绍</strong>，它向<strong>Redis</strong>提供Spring Data平台的抽象。</p>
<p>Redis由基于密钥库的数据结构驱动，以持久保存数据，并可用作数据库，缓存，消息代理等。</p>
<p>Spring Data 对其的抽象封装成了我们在 Spring 生态中常见的模板模式，同时还具有所有Spring Data项目的传统简单性。<br><a id="more"></a></p>
<h2 id="2-Maven依赖"><a href="#2-Maven依赖" class="headerlink" title="2. Maven依赖"></a>2. Maven依赖</h2><p>让我们首先在<em>pom.xml中</em>声明Spring Data Redis依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以从Maven Central下载最新版本的<a href="https://search.maven.org/classic/#search%7Cga%7C1%7Cspring-data-redis" target="_blank" rel="noopener">spring-data-redis</a>和<a href="https://search.maven.org/classic/#search%7Cga%7C1%7Ca%3A%22jedis%22%20AND%20g%3A%22redis.clients%22" target="_blank" rel="noopener">jedis</a>。</p>
<h2 id="3-Redis配置"><a href="#3-Redis配置" class="headerlink" title="3. Redis配置"></a>3. Redis配置</h2><p>要定义应用程序客户端和Redis服务器实例之间的连接设置，我们需要使用Redis客户端。</p>
<p>有许多可用于Java的Redis客户端实现。在本教程中，<strong>我们将使用Jedis - 一个简单而强大的Redis客户端实现</strong>。</p>
<p>框架中对XML和Java Config都有很好的支持， 对于本教程，我们将使用Java Config来配置。</p>
<h3 id="3-1-Java配置"><a href="#3-1-Java配置" class="headerlink" title="3.1 Java配置"></a>3.1 Java配置</h3><p>让我们从配置bean定义开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置非常简单。首先，使用Jedis客户端，我们定义了一个<em>connectionFactory</em>，然后，我们定义了一个<em>RedisTemplate</em>使用<em>jedisConnectionFactory</em>。</p>
<h3 id="3-2-自定义连接属性"><a href="#3-2-自定义连接属性" class="headerlink" title="3.2 自定义连接属性"></a>3.2 自定义连接属性</h3><p>您可能已经注意到上述配置中缺少通常的与连接相关的属性。例如，配置中缺少服务器地址和端口。原因很简单：对于我们的示例，我们使用默认值。</p>
<p>但是，如果我们需要配置连接细节，我们总是可以修改<em>jedisConnectionFactory</em>配置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JedisConnectionFactory jedisConFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">    jedisConFactory.setHostName(<span class="string">"localhost"</span>);</span><br><span class="line">    jedisConFactory.setPort(<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">return</span> jedisConFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Redis-Repository"><a href="#4-Redis-Repository" class="headerlink" title="4. Redis Repository"></a>4. Redis Repository</h2><p>让我们使用<em>Student</em>实体作为示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RedisHash</span>(<span class="string">"Student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Gender &#123; </span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-Spring-Data-Repository"><a href="#4-1-Spring-Data-Repository" class="headerlink" title="4.1 Spring Data Repository"></a>4.1 Spring Data Repository</h3><p>现在让我们创建<em>StudentRepository</em>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Student</span>, <span class="title">String</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-使用StudentRepository进行数据访问"><a href="#5-使用StudentRepository进行数据访问" class="headerlink" title="5. 使用StudentRepository进行数据访问"></a>5. 使用StudentRepository进行数据访问</h2><p><strong>通过在StudentRepository中扩展CrudRepository，我们可以自动获得一组执行CRUD功能的完整持久性方法。</strong></p>
<h3 id="5-1-保存新的学生对象"><a href="#5-1-保存新的学生对象" class="headerlink" title="5.1 保存新的学生对象"></a>5.1 保存新的学生对象</h3><p>让我们在数据存储中保存一个新的学生对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"Eng2015001"</span>, <span class="string">"John Doe"</span>, Student.Gender.MALE, <span class="number">1</span>);</span><br><span class="line">studentRepository.save(student);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-检索现有学生对象"><a href="#5-2-检索现有学生对象" class="headerlink" title="5.2 检索现有学生对象"></a>5.2 检索现有学生对象</h3><p>我们可以通过获取学生数据来验证学生在上一部分中的正确插入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student retrievedStudent = studentRepository.findById(<span class="string">"Eng2015001"</span>).get();</span><br></pre></td></tr></table></figure>
<h3 id="5-3-更新现有学生对象"><a href="#5-3-更新现有学生对象" class="headerlink" title="5.3 更新现有学生对象"></a>5.3 更新现有学生对象</h3><p>让我们更改上面检索的学生的姓名并再次保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">retrievedStudent.setName(<span class="string">"Richard Watson"</span>);</span><br><span class="line">studentRepository.save(student);</span><br></pre></td></tr></table></figure>
<p>最后，我们可以再次检索学生的数据，并验证数据库中的名称是否已更新。</p>
<h3 id="5-4-删除现有学生数据"><a href="#5-4-删除现有学生数据" class="headerlink" title="5.4 删除现有学生数据"></a>5.4 删除现有学生数据</h3><p>我们可以删除上面插入的学生数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">studentRepository.deleteById(student.getId());</span><br></pre></td></tr></table></figure>
<p>现在我们可以搜索学生对象并验证结果是否为<em>null</em>。</p>
<h3 id="5-5-查找所有学生数据"><a href="#5-5-查找所有学生数据" class="headerlink" title="5.5 查找所有学生数据"></a>5.5 查找所有学生数据</h3><p>我们可以插入一些学生对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student engStudent = <span class="keyword">new</span> Student(<span class="string">"Eng2015001"</span>, <span class="string">"John Doe"</span>, Student.Gender.MALE, <span class="number">1</span>);</span><br><span class="line">Student medStudent = <span class="keyword">new</span> Student(<span class="string">"Med2015001"</span>, <span class="string">"Gareth Houston"</span>, Student.Gender.MALE, <span class="number">2</span>);</span><br><span class="line">studentRepository.save(engStudent);</span><br><span class="line">studentRepository.save(medStudent);</span><br></pre></td></tr></table></figure>
<p>我们也可以通过<em>saveAll()</em>方法来插入一个集合来实现这，它接受一个包含我们想要持久化的多个学生对象的<em>Iterable</em>对象。</p>
<p>要查找所有插入的学生，我们可以使用<em>findAll()</em>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">studentRepository.findAll().forEach(students::add);</span><br></pre></td></tr></table></figure>
<p>然后我们可以通过检查每个对象的属性来快速检查<em>学生</em>列表的大小或验证更大的粒度。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>SpringData</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务简化配置</title>
    <url>/2008/03/02/spring-shi-wu-jian-hua-pei-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 spring 中, 事务管理一般是通过声明一个 txProxyTemplate, 然后业务 bean 中 parent = “txProxyTemplate”, 这样做未免显得有些繁琐, 并且如果业务 bean 还需要其他拦截器, 配置也不太方便, 下面贴出我的配置, 用 DefaultAdvisorAutoProxyCreator 实现自动代理。</p>
<a id="more"></a>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Transaction manager for a single Hibernate SessionFactory (alternative to JTA) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"sessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributeSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                com.skyon.user.manager.UserManager.*=PROPAGATION_REQUIRED</span><br><span class="line">                <span class="comment">&lt;!-- Add new defines here --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>transactionInterceptor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">                增加新的 Interceptor </span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">ref</span>=<span class="string">"transactionInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里利用 DefaultAdvisorAutoProxyCreator 实现了对容器中所有 bean 的自动代理, 增加一个需要事务的业务 bean 时只要在 transactionInterceptor 增加一行即可, 增加别的 interceptor 也非常方便，极大减少了配置量。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot——Netflix Feign</title>
    <url>/2016/09/07/springboot-netflix-feign/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h3><p>Feign是一个 Netflix 开发的声明性的Web服务客户端，灵感来源于<code>Retrofit</code>、<code>JAXRS-2.0</code>和<code>WebSocket</code>。Feign 最初是为了降低统一绑定Denominator 到 HTTP API 的复杂度，使得 Java HTTP 客户端编写更方便。<br>Feign 的 MAVEN 直接依赖如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;feign.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;feign.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <em>feign-gson</em> 主要是为了进行 gson 序列化，并不是必需的</p>
</blockquote>
<a id="more"></a>
<h3 id="Why-Feign？"><a href="#Why-Feign？" class="headerlink" title="Why Feign？"></a>Why Feign？</h3><p>当然，你可以使用 <code>Jersey</code> 和 <code>CXF</code> 这些来写一个 <code>Rest</code> 或 <code>SOAP</code> 服务的java客服端，也可以直接使用 <code>Apache HttpClient</code> 来实现。但是 <code>Feign</code> 的目的是尽量的减少资源和代码来实现和 <code>HTTP API</code> 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 <code>HTTP API</code>。</p>
<h3 id="How？"><a href="#How？" class="headerlink" title="How？"></a>How？</h3><p><code>Feign</code> 通过注解注入一个模板化请求进行工作，它本身并不对请求进行处理，只不过通过注解来生成 Request，并进行 URL 的模板进行参数替换。然而这也限制了 <code>Feign</code>，<strong>只支持文本形式的API</strong>，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p>
<h2 id="2-使用简介"><a href="#2-使用简介" class="headerlink" title="2. 使用简介"></a>2. 使用简介</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p>​    Feign 的使用比较简单，如下是获取 GitHub Contributors 的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RequestLine注解声明请求方法和请求地址,可以允许有查询参数</span></span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">    <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String login;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> contributions;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Contributor</span><span class="params">(String login, <span class="keyword">int</span> contributions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.login = login;</span><br><span class="line">            <span class="keyword">this</span>.contributions = contributions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <em>@RequestLine</em> 即可定义一个远程的 Http 请求，通过参数指定请求的方法以及 PATH 属性（支持参数替换），具体值来自于以 <em>@Param</em> 指定的方法参数。</p>
<p>单元测试用例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFeign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GitHubClient github = Feign.builder()</span><br><span class="line">                .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                .target(GitHubClient.class, "https://api.github.com");</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">        List&lt;GitHubClient.Contributor&gt; contributors = github.contributors(<span class="string">"OpenFeign"</span>, <span class="string">"feign"</span>);</span><br><span class="line">        <span class="keyword">for</span> (GitHubClient.Contributor contributor : contributors) &#123;</span><br><span class="line">            log.info(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里并没有严格按照单元测试用例的规范来通过 assert 验证，而是将数据打印了出来。</p>
</blockquote>
<h3 id="2-2-自定义与定制化"><a href="#2-2-自定义与定制化" class="headerlink" title="2.2 自定义与定制化"></a>2.2 自定义与定制化</h3><p>可以看到在测试用例中，我们通过 <code>Feign.Builder</code>来实例化我们的 <code>GitHubClient</code>，其`Build的过程其实有许多的定制化入口，比如日志、编码、解码、重试机制等等。</p>
<p>比如，下面的代码演示了如何构建使用自定义的编码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BankClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /account/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">Account <span class="title">getAccountInfo</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// AccountDecoder() 是自己实现的一个Decoder</span></span><br><span class="line">BankClient bankClient = Feign.builder().decoder(new AccountDecoder()).target(BankClient.class, "https://api.examplebank.com");</span><br></pre></td></tr></table></figure>
<h2 id="3-Feign-的组成"><a href="#3-Feign-的组成" class="headerlink" title="3. Feign 的组成"></a>3. Feign 的组成</h2><h3 id="3-1-编码器-Encoder"><a href="#3-1-编码器-Encoder" class="headerlink" title="3.1 编码器 Encoder"></a>3.1 编码器 <em>Encoder</em></h3><p>发送一个Post请求最简单的方法就是传递一个 <code>String</code> 或者 <code>byte[]</code> 类型的参数了。你也许还需添加一个Content-Type请求头，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">client.login(<span class="string">"&#123;\"user_name\": \"denominator\", \"password\": \"secret\"&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>通过配置一个解码器，你可以发送一个安全类型的请求体，如下是一个使用 feign-gson 扩展的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String user_name;</span><br><span class="line">  <span class="keyword">final</span> String password;</span><br><span class="line"></span><br><span class="line">  Credentials(String user_name, String password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.user_name = user_name;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(Credentials creds)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">LoginClient client = Feign.builder()</span><br><span class="line">                          .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                          .target(LoginClient.class, "https://foo.com");</span><br><span class="line"></span><br><span class="line">client.login(<span class="keyword">new</span> Credentials(<span class="string">"denominator"</span>, <span class="string">"secret"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="3-2-解码器-Decoder"><a href="#3-2-解码器-Decoder" class="headerlink" title="3.2 解码器 Decoder"></a>3.2 解码器 <em>Decoder</em></h3><p>相对应于编码器，假如有接口方法返回的消息不是 <code>Response</code>, <code>String</code>, <code>byte[]</code> 或者 <code>void</code> 类型的，那么你需要配置一个非默认的解码器。<br>下面是一个配置使用JSON解码器(使用的是feign-gson扩展)的例子:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .target(GitHub.class, "https://api.github.com");</span><br></pre></td></tr></table></figure>
<p>假如你想在将响应传递给解码器处理前做一些额外的处理，那么你可以使用<code>mapAndDecode</code>方法。一个用例就是使用jsonp服务的时候:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">JsonpApi jsonpApi = Feign.builder()</span><br><span class="line">            .mapAndDecode((response, type) -&gt; jsopUnwrap(response, type), <span class="keyword">new</span> GsonDecoder())</span><br><span class="line">            .target(JsonpApi.class, "https://some-jsonp-api.com");</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Body-模板"><a href="#3-3-Body-模板" class="headerlink" title="3.3 @Body 模板"></a>3.3 @Body 模板</h3><p><code>@Body</code>注解申明一个请求体模板，模板中可以带有参数，与方法中 <code>@Param</code> 注解申明的参数相匹配,使用方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoginClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/xml"</span>)</span><br><span class="line">  <span class="meta">@Body</span>(<span class="string">"&lt;login \"user_name\"=\"&#123;user_name&#125;\" \"password\"=\"&#123;password&#125;\"/&gt;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">xml</span><span class="params">(@Param(<span class="string">"user_name"</span>)</span> String user, @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="comment">// json curly braces must be escaped!</span></span><br><span class="line">  <span class="comment">// 这里JSON格式需要的花括号居然需要转码，有点蛋疼了。</span></span><br><span class="line">  <span class="meta">@Body</span>(<span class="string">"%7B\"user_name\": \"&#123;user_name&#125;\", \"password\": \"&#123;password&#125;\"%7D"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">json</span><span class="params">(@Param(<span class="string">"user_name"</span>)</span> String user, @<span class="title">Param</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// &lt;login "user_name"="denominator" "password"="secret"/&gt;</span></span><br><span class="line">client.xml(<span class="string">"denominator"</span>, <span class="string">"secret"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;"user_name": "denominator", "password": "secret"&#125;</span></span><br><span class="line">client.json(<span class="string">"denominator"</span>, <span class="string">"secret"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-4-Headers-支持"><a href="#3-4-Headers-支持" class="headerlink" title="3.4 Headers 支持"></a>3.4 Headers 支持</h3><p><code>Feign</code> 支持给请求的api设置或者请求的客户端设置请求头：</p>
<h4 id="3-4-1-给API设置请求头"><a href="#3-4-1-给API设置请求头" class="headerlink" title="3.4.1 给API设置请求头"></a>3.4.1 给API设置请求头</h4><ol>
<li><p>使用 <code>@Headers</code> 设置静态请求头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给BaseApi中的所有方法设置Accept请求头</span></span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"Accept: application/json"</span>)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 单独给put方法设置Content-Type请求头</span></span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"PUT /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>设置动态值的请求头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"X-Ping: &#123;token&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(@Param(<span class="string">"token"</span>)</span> String token)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>设置key和value都是动态的请求头 </p>
<p>有些API需要根据调用时动态确定使用不同的请求头（比如：设置 <em>x-amz-meta- 或者 </em>x-goog-meta-*）,<br>这时候可以使用 <code>@HeaderMap</code> 注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @HeaderMap 注解设置的请求头优先于其他方式设置的</span></span><br><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"POST /"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(@HeaderMap Map&lt;String, Object&gt; headerMap)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-4-2-给Target设置请求头"><a href="#3-4-2-给Target设置请求头" class="headerlink" title="3.4.2 给Target设置请求头"></a>3.4.2 给Target设置请求头</h4><p>有时我们需要在一个API实现中根据不同的endpoint来传入不同的Header，这个时候我们可以使用自定义的RequestInterceptor 或 Target来实现。<br>下面是一个通过自定义Target来实现给每个Target设置安全校验信息Header的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAuthTokenTarget</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Target</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicAuthTokenTarget</span><span class="params">(Class&lt;T&gt; clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">                                UrlAndTokenProvider provider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ThreadLocal&lt;String&gt; requestIdProvider)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Request <span class="title">apply</span><span class="params">(RequestTemplate input)</span> </span>&#123;</span><br><span class="line">    TokenIdAndPublicURL urlAndToken = provider.get();</span><br><span class="line">    <span class="keyword">if</span> (input.url().indexOf(<span class="string">"http"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      input.insert(<span class="number">0</span>, urlAndToken.publicURL);</span><br><span class="line">    &#125;</span><br><span class="line">    input.header(<span class="string">"X-Auth-Token"</span>, urlAndToken.tokenId);</span><br><span class="line">    input.header(<span class="string">"X-Request-ID"</span>, requestIdProvider.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input.request();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Bank bank = Feign.builder()</span><br><span class="line">        .target(<span class="keyword">new</span> DynamicAuthTokenTarget(Bank<span class="class">.<span class="keyword">class</span>, <span class="title">provider</span>, <span class="title">requestIdProvider</span>))</span>;</span><br></pre></td></tr></table></figure>
<p>这种方法的实现依赖于给<code>Feign</code> 客户端设置的自定义的RequestInterceptor 或 Target。可以被用来给一个客户端的所有api请求设置请求头。比如说可是被用来在header中设置身份校验信息。这些方法是在线程执行api请求的时候才会执行，所以是允许在运行时根据上下文来动态设置header的。<br>比如说可以根据线程本地存储(thread-local storage)来为不同的线程设置不同的请求头。</p>
<h2 id="4-Feign-与第三方组件的集成"><a href="#4-Feign-与第三方组件的集成" class="headerlink" title="4. Feign 与第三方组件的集成"></a>4. Feign 与第三方组件的集成</h2><h3 id="4-1-Gson"><a href="#4-1-Gson" class="headerlink" title="4.1 Gson"></a>4.1 Gson</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/gson" target="_blank" rel="noopener">Gson</a> 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。<br>添加 <code>GsonEncoder</code> 以及 <code>GsonDecoder</code> 到你的 <code>Feign.Builder</code> 中， 如下:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GsonCodec codec = <span class="keyword">new</span> GsonCodec();</span><br><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .encoder(<span class="keyword">new</span> GsonEncoder())</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .target(GitHub.class, "https://api.github.com");</span><br></pre></td></tr></table></figure>
<p>需要的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-Jackson"><a href="#4-2-Jackson" class="headerlink" title="4.2 Jackson"></a>4.2 Jackson</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/jackson" target="_blank" rel="noopener">Jackson</a> 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。<br>添加 <code>JacksonEncoder</code> 以及 <code>JacksonDecoder</code> 到你的 <code>Feign.Builder</code> 中， 如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .encoder(<span class="keyword">new</span> JacksonEncoder())</span><br><span class="line">                     .decoder(<span class="keyword">new</span> JacksonDecoder())</span><br><span class="line">                     .target(GitHub.class, "https://api.github.com");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-Sax"><a href="#4-3-Sax" class="headerlink" title="4.3 Sax"></a>4.3 Sax</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/sax" target="_blank" rel="noopener"><code>SaxDecoder</code></a> 用于解析XML,并兼容普通JVM和Android。下面是一个配置sax来解析响应的例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">api = Feign.builder()</span><br><span class="line">           .decoder(SAXDecoder.builder()</span><br><span class="line">                              .registerContentHandler(UserIdHandler<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                              .<span class="title">build</span>())</span></span><br><span class="line">           .target(Api.class, "https://apihost");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-sax<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-JAXB"><a href="#4-4-JAXB" class="headerlink" title="4.4 JAXB"></a>4.4 JAXB</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/jaxb" target="_blank" rel="noopener">JAXB</a> 包含了一个编码器和一个解码器，这个可以被用于XML格式的API。<br>添加 <code>JAXBEncoder</code> 以及 <code>JAXBDecoder</code> 到你的 <code>Feign.Builder</code> 中， 如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">api = Feign.builder()</span><br><span class="line">           .encoder(<span class="keyword">new</span> JAXBEncoder())</span><br><span class="line">           .decoder(<span class="keyword">new</span> JAXBDecoder())</span><br><span class="line">           .target(Api.class, "https://apihost");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jaxb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-JAX-RS"><a href="#4-5-JAX-RS" class="headerlink" title="4.5 JAX-RS"></a>4.5 JAX-RS</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/jaxrs" target="_blank" rel="noopener"><code>JAXRSContract</code></a> 使用 JAX-RS 规范重写覆盖了默认的注解处理。下面是一个使用 JAX-RS 的例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span> <span class="meta">@Path</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@PathParam(<span class="string">"owner"</span>)</span> String owner, @<span class="title">PathParam</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// contract 方法配置注解处理器,注解处理器定义了哪些注解和值是可以作用于接口的</span></span><br><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .contract(<span class="keyword">new</span> JAXRSContract())</span><br><span class="line">                     .target(GitHub.class, "https://api.github.com");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jaxrs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-OkHttp"><a href="#4-6-OkHttp" class="headerlink" title="4.6 OkHttp"></a>4.6 OkHttp</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/okhttp" target="_blank" rel="noopener">OkHttpClient</a> 使用 <code>OkHttp</code> 来发送 <code>Feign</code> 的请求，<code>OkHttp</code> 支持 <code>SPDY</code> (SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验),并有更好的控制http请求。<br>要让 <code>Feign</code> 使用 <code>OkHttp</code> ，你需要将 <code>OkHttp</code> 加入到你的环境变量中区，然后配置 <code>Feign</code> 使用 <code>OkHttpClient</code>，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">                     .target(GitHub.class, "https://api.github.com");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-7-Ribbon"><a href="#4-7-Ribbon" class="headerlink" title="4.7 Ribbon"></a>4.7 Ribbon</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/ribbon" target="_blank" rel="noopener"><code>RibbonClient</code></a> 重写了 <code>Feign</code> 客户端的对URL的处理，其添加了 智能路由以及一些其他由<a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">Ribbon</a>提供的弹性功能。<br>集成Ribbon需要你将ribbon的客户端名称当做url的host部分来传递，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myAppProd是你的ribbon client name</span></span><br><span class="line">MyService api = Feign.builder().client(RibbonClient.create()).target(MyService.class, "https://myAppProd");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-Hystrix"><a href="#4-8-Hystrix" class="headerlink" title="4.8 Hystrix"></a>4.8 Hystrix</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/hystrix" target="_blank" rel="noopener"><code>HystrixFeign</code></a> 配置了 <code>Hystrix</code> 提供的<strong>熔断</strong>机制。<br>要在 <code>Feign</code> 中使用 <code>Hystrix</code> ，你需要添加<code>Hystrix</code>模块到你的环境变量，然后使用 <code>HystrixFeign</code> 来构造你的API：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MyService api = HystrixFeign.builder().target(MyService.class, "https://myAppProd");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-9-SLF4J"><a href="#4-9-SLF4J" class="headerlink" title="4.9 SLF4J"></a>4.9 SLF4J</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/slf4j" target="_blank" rel="noopener">SLF4JModule</a> 允许你使用 <code>SLF4J</code> 作为 <code>Feign</code> 的日志记录模块，这样你就可以轻松的使用 <code>Logback</code>, <code>Log4J</code> , 等 来记录你的日志.<br>要在 <code>Feign</code> 中使用 <code>SLF4J</code> ，你需要添加<code>SLF4J</code>模块和对应的日志记录实现模块(比如Log4J)到你的环境变量，然后配置 <code>Feign</code>使用<code>Slf4jLogger</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .logger(<span class="keyword">new</span> Slf4jLogger())</span><br><span class="line">                     .target(GitHub.class, "https://api.github.com");</span><br></pre></td></tr></table></figure>
<p>对应的 MAVEN 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.netflix.feign/feign-gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-高级用法"><a href="#5-高级用法" class="headerlink" title="5. 高级用法"></a>5. 高级用法</h2><h3 id="5-1-通用-API"><a href="#5-1-通用-API" class="headerlink" title="5.1 通用 API"></a>5.1 通用 API</h3><p>有些请求中的一些方法是通用的，但是可能会有不同的参数类型或者返回类型，这个时候可以这么用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用API</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /health"</span>)</span><br><span class="line">  <span class="function">String <span class="title">health</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /all"</span>)</span><br><span class="line">  <span class="function">List&lt;Entity&gt; <span class="title">all</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承通用API</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomAPI</span> <span class="keyword">extends</span> <span class="title">BaseAPI</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /custom"</span>)</span><br><span class="line">  <span class="function">String <span class="title">custom</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种类型有相同的表现形式，定义一个统一的API</span></span><br><span class="line"><span class="meta">@Headers</span>(<span class="string">"Accept: application/json"</span>)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BaseApi</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /api"</span>)</span><br><span class="line">  <span class="function">List&lt;V&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Headers</span>(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"PUT /api/&#123;key&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(@Param(<span class="string">"key"</span>)</span> String key, V value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同的类型来继承</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Foo</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BarApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span>&lt;<span class="title">Bar</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Logging"><a href="#5-2-Logging" class="headerlink" title="5.2 Logging"></a>5.2 Logging</h3><p>你可以通过设置一个 <code>Logger</code> 来记录http消息，如下:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GitHub github = Feign.builder()</span><br><span class="line">                     .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                     .logger(<span class="keyword">new</span> Logger.JavaLogger().appendToFile(<span class="string">"logs/http.log"</span>))</span><br><span class="line">                     .logLevel(Logger.Level.FULL)</span><br><span class="line">                     .target(GitHub.class, "https://api.github.com");</span><br></pre></td></tr></table></figure>
<p>参考第 4 部分的 <em>SLF4J</em> 集成</p>
<h3 id="5-2-Request-Interceptors"><a href="#5-2-Request-Interceptors" class="headerlink" title="5.2 Request Interceptors"></a>5.2 Request Interceptors</h3><p>当你希望修改所有的的请求的时候，你可以使用Request Interceptors。比如说，你作为一个中介，你可能需要为每个请求设置 <code>X-Forwarded-For</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardedForInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">    template.header(<span class="string">"X-Forwarded-For"</span>, <span class="string">"origin.host.com"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Bank bank = Feign.builder()</span><br><span class="line">                 .decoder(accountDecoder)</span><br><span class="line">                 .requestInterceptor(<span class="keyword">new</span> ForwardedForInterceptor())</span><br><span class="line">                 .target(Bank.class, "https://api.examplebank.com");</span><br></pre></td></tr></table></figure>
<h3 id="5-3-自定义-Param-展开"><a href="#5-3-自定义-Param-展开" class="headerlink" title="5.3 自定义 @Param 展开"></a>5.3 自定义 @Param 展开</h3><p>在使用 <code>@Param</code> 注解给模板中的参数设值的时候，默认的是使用的对象的 <code>toString()</code> 方法的值，通过声明 自定义的<code>Param.Expander</code>，用户可以控制其行为，比如说格式化 <code>Date</code> 类型的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过设置 @Param 的 expander 为 DateToMillis.class 可以定义Date类型的值</span></span><br><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"GET /?since=&#123;date&#125;"</span>) </span><br><span class="line"><span class="function">Result <span class="title">list</span><span class="params">(@Param(value = <span class="string">"date"</span>, expander = DateToMillis.class)</span> Date date)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-动态查询参数"><a href="#5-4-动态查询参数" class="headerlink" title="5.4 动态查询参数"></a>5.4 动态查询参数</h3><p>动态查询参数支持，通过使用 <code>@QueryMap</code> 可以允许动态传入请求参数,如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestLine</span>(<span class="string">"GET /find"</span>)</span><br><span class="line"><span class="function">V <span class="title">find</span><span class="params">(@QueryMap Map&lt;String, Object&gt; queryMap)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-表态方法与默认方法"><a href="#5-5-表态方法与默认方法" class="headerlink" title="5.5 表态方法与默认方法"></a>5.5 表态方法与默认方法</h3><p>如果你使用的是JDK 1.8+ 的话，那么你可以给接口设置统一的默认方法和静态方法,这个事JDK8的新特性，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /users/&#123;username&#125;/repos?sort=&#123;sort&#125;"</span>)</span><br><span class="line">  <span class="function">List&lt;Repo&gt; <span class="title">repos</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"sort"</span>)</span> String sort)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Repo&gt; <span class="title">repos</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repos(owner, <span class="string">"full_name"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Lists all contributors for all repos owned by a user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">    MergingContributorList contributors = <span class="keyword">new</span> MergingContributorList();</span><br><span class="line">    <span class="keyword">for</span>(Repo repo : <span class="keyword">this</span>.repos(owner)) &#123;</span><br><span class="line">      contributors.addAll(<span class="keyword">this</span>.contributors(user, repo.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contributors.mergeResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GitHub <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Feign.builder()</span><br><span class="line">                .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                .target(GitHub.class, "https://api.github.com");</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 静态资源的缓存</title>
    <url>/2016/05/02/spring-mvc-jing-tai-zi-yuan-de-huan-cun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本文重点介绍在使用Spring MVC提供静态资源（如Javascript和CSS文件）时的缓存。同时介绍下一 当文件更新时，如何从缓存中替换旧版本，不会从缓存中错误地提供，即所谓的“perfect cache”。<br><a id="more"></a></p>
<h2 id="2-静态资源缓存"><a href="#2-静态资源缓存" class="headerlink" title="2. 静态资源缓存"></a>2. 静态资源缓存</h2><p>为了使静态资源可缓存，我们需要配置其相应的资源处理程序。下面是一个简单的示例：将响应的<em>Cache-Control</em> 头信息设置为<em>max-age = 31536000</em>，这会导致浏览器使用该文件的缓存版本一年：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/js/**"</span>) </span><br><span class="line">                .addResourceLocations(<span class="string">"/js/"</span>) </span><br><span class="line">                .setCacheControl(CacheControl.maxAge(<span class="number">365</span>, TimeUnit.DAYS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们拥有如此长的缓存有效期的原因是我们希望客户端在文件更新之前使用文件的缓存版本，根据<a href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">RFC的<em>Cache-Control，</em></a>我们可以使用365天的最大值<a href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">标题</a>。</p>
<p><strong>因此，当客户端第一次请求foo.js时</strong>，他将通过网络接收整个文件，状态代码为<em>200 OK</em>。响应将具有以下头信息来控制缓存行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>
<p>这个头信息将告诉浏览器缓存文件的过期持续时间为一年：</p>
<p><img src="/images/pasted-108.png" alt="缓存头信息"></p>
<p><strong>当客户端第二次请求相同的文件时</strong>，浏览器不会向服务器发出另一个请求。相反，它将直接从其缓存中提供文件并避免网络往返，因此页面加载速度会更快：</p>
<p><img src="/images/pasted-109.png" alt="来自缓存"></p>
<p>Chrome浏览器用户在测试时需要小心，因为如果您通过按屏幕上的刷新按钮或按F5键刷新页面，Chrome将不会使用缓存，您需要在地址栏中敲回车才行。<a href="http://stackoverflow.com/questions/3401049/chrome-doesnt-cache-images-js-css/16510707#16510707" target="_blank" rel="noopener">这里</a>有一个关于这个问题的讨论，貌似确实是有一些问题，不知道是不是 chrome 故意为之。</p>
<h2 id="3-版本化静态资源"><a href="#3-版本化静态资源" class="headerlink" title="3. 版本化静态资源"></a>3. 版本化静态资源</h2><p>使用缓存来提供静态资源会使页面加载速度非常快，但它有一个重要的问题：更新文件时，客户端将无法获取该文件的最新版本，因为如果该文件是最新的并且只是从浏览器缓存中提供文件，它不会检查服务器。</p>
<p>当文件更新的，如果想要浏览器能及时地从服务器重新获取最新文件，可以采取如下的方式：</p>
<ul>
<li>提供具有版本号的静态资源文件，例如，<em>foo.js</em> 修改为 <em>/js/foo-6944c7e3a9bd20cc30fdc085cae46f2.js</em>。</li>
<li>采用一个新的URL链接。</li>
<li>每当文件更新时，都会更新URL的版本部分。例如，当更新 <em>foo.js</em> 时，它的版本信息更新，链接变为：<em>/js/foo-a3d8d7780349a12d739799e9aa7d2623.js</em> 下。</li>
</ul>
<p>这样客户端将在更新时从服务器请求该文件，因为该页面将具有指向其他URL的链接，因此浏览器无法使用缓存。如果文件未更新，其版本（连带URL）将不会更改，客户端将继续使用该文件的缓存。</p>
<p>通常，我们需要手动完成所有这些操作，但Spring支持这些开箱即用，包括计算每个文件的哈希并将它们附加到URL。让我们看看我们如何配置Spring应用程序来为我们完成所有这些工作。</p>
<h3 id="3-1-给-URL-添加版本支持"><a href="#3-1-给-URL-添加版本支持" class="headerlink" title="3.1 给 URL 添加版本支持"></a>3.1 给 URL 添加版本支持</h3><p>我们需要在路径中添加<em>VersionResourceResolver</em>，以便为其下的文件提供更新的版本字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"/js/**"</span>)</span><br><span class="line">            .addResourceLocations(<span class="string">"/js/"</span>)</span><br><span class="line">            .setCacheControl(CacheControl.maxAge(<span class="number">365</span>, TimeUnit.DAYS))</span><br><span class="line">            .resourceChain(<span class="keyword">false</span>)</span><br><span class="line">            .addResolver(<span class="keyword">new</span> VersionResourceResolver().addContentVersionStrategy(<span class="string">"/**"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用内容版本策略。<em>/ js</em> 文件夹中的每个文件都将在具有根据其内容计算的版本的URL，这称为指纹识别。例如，<em>foo.js</em> 现在将有版本信息 URL <em>/js/foo/6944c7e3a9bd20cc30fdc085cae46f2.js</em> 。</p>
<p>使用此配置，当客户端请求 <em><a href="http://localhost:8080/js/46944c7e3a9bd20cc30fdc085cae46f2.js" target="_blank" rel="noopener">http://localhost:8080/js/46944c7e3a9bd20cc30fdc085cae46f2.js</a></em> 时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i http://localhost:8080/js/foo-46944c7e3a9bd20cc30fdc085cae46f2.js</span><br></pre></td></tr></table></figure>
<p>服务器将使用Cache-Control头信息响应，告诉客户端浏览器将文件缓存一年：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Last-Modified: Tue, 09 Aug 2016 06:43:26 GMT</span><br><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用新的URL链接"><a href="#3-2-使用新的URL链接" class="headerlink" title="3.2 使用新的URL链接"></a>3.2 使用新的URL链接</h3><p>在我们将版本插入URL之前，我们可以使用一个简单的 <em>script</em> 标记来导入<em>foo.js</em>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/foo.js"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在我们在带有版本的URL：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"&lt;em&gt;/js/foo-46944c7e3a9bd20cc30fdc085cae46f2.js&lt;/em&gt;"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显然，手动去修改带有版本信息的 URL 是很麻烦的，而且很难提前知道这些版本的 HASH 值。好在 Spring 提供了一个更好的解决方案来解决这个问题，我们可以使用<em>ResourceUrlEncodingFilter</em>和JSTL的<em>url</em>标记来重写带有版本化链接的链接的URL。</p>
<p>首先需要在 <em>web.xml</em> 下注册 <em>ResourceURLEncodingFilter</em> ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>resourceUrlEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.servlet.resource.ResourceUrlEncodingFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>resourceUrlEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时，在JSP页面上导入JSTL核心标记库：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> <span class="attr">prefix</span>=<span class="string">"c"</span> %&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们可以使用<em>url</em>标签导入<em>foo.js</em>，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">js</span>/<span class="attr">foo.js</span>" /&gt;</span>"&gt;</span><br></pre></td></tr></table></figure>
<p>此时JSP页面在渲染时，Spring 会正确重写该文件的URL，将版本信息追加到 URL 中去，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/foo-46944c7e3a9bd20cc30fdc085cae46f2.js"</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-更新URL的版本部分"><a href="#3-3-更新URL的版本部分" class="headerlink" title="3.3 更新URL的版本部分"></a>3.3 更新URL的版本部分</h3><p>由于我们 URL 的版本信息是根据文件内容进行 HASH 计算得到的，所以每当更新文件时，都会再次计算其版本，并在包含新版本的URL下提供文件。我们不需要为此做任何额外的工作，<em>VersionResourceResolver</em> 为我们处理这个。</p>
<h2 id="4-修复CSS链接的问题"><a href="#4-修复CSS链接的问题" class="headerlink" title="4. 修复CSS链接的问题"></a>4. 修复CSS链接的问题</h2><p>CSS文件可以使用 <em>@import</em> 指令导入其他CSS文件，例如，<em>myCss.css</em>文件导入 <em>another.css</em> 文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"another.css"</span>;</span><br></pre></td></tr></table></figure>
<p>如果我们采用了版本化的资源路由，那么实际上 <em>another.css</em>  文件的路径会被版本化为 <em>another-9556ab93ae179f87b178cfad96a6ab72.css</em>，而不再是 <em>another.css</em> ，这将导致这个 <em>@import</em> 由于找不到文件而失效。</p>
<p>要解决此问题并向正确的路径发出请求，我们需要将 <em>CssLinkResourceTransformer</em> 引入资源处理程序配置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"/resources/**"</span>)</span><br><span class="line">            .addResourceLocations(<span class="string">"/resources/"</span>, <span class="string">"classpath:/other-resources/"</span>)</span><br><span class="line">            .setCacheControl(CacheControl.maxAge(<span class="number">365</span>, TimeUnit.DAYS))</span><br><span class="line">            .resourceChain(<span class="keyword">false</span>)</span><br><span class="line">            .addResolver(<span class="keyword">new</span> VersionResourceResolver().addContentVersionStrategy(<span class="string">"/**"</span>))</span><br><span class="line">            .addTransformer(<span class="keyword">new</span> CssLinkResourceTransformer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在处理 css 资源请求时，会修改 <em>myCss.css</em> 中 的内容并使用以下内容，并替换 <em>@import</em> 语句中的文件路径：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"another-9556ab93ae179f87b178cfad96a6ab72.css"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>利用HTTP缓存是对网站性能的巨大推动，但在使用缓存时避免提供过时资源可能很麻烦。</p>
<p>在本文中，我们实现了一个很好的策略，即在使用Spring MVC提供静态资源时使用HTTP缓存，并在更新文件时让缓存失效。</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码解读——打包启动器原理</title>
    <url>/2018/10/23/springboot-yuan-ma-jie-du-da-bao-qi-dong-qi-yuan-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>SpringBoot</strong>提供了非常多的非常好用的特性，比如内置容器，一键运行，注解驱动，内置监控等等。其中一个非常吸引人也非常便捷的特性就是一键启动：即<strong>将应用打包成一个可执行的JAR，并直接启动运行</strong>；</p>
</blockquote>
<p>很多初学者都会比较困惑，SpringBoot是如何做到将应用代码和所有的依赖打包成一个独立的JAR并运行的，因为传统的开发方式如果要将应用打包成独立的JAR并通过<em>java -jar</em>命令的话，需要通过<em>-classpath</em>属性来指定依赖。我们今天就来分析讲解一下SpringBoot的打包、启动及运行的原理；</p>
<a id="more"></a>
<h2 id="1-SpringBoot打包插件"><a href="#1-SpringBoot打包插件" class="headerlink" title="1. SpringBoot打包插件"></a>1. SpringBoot打包插件</h2><p>我们先看一下SpringBoot打包后的结构是什么样的，打开target目录我们发现有两个jar包：</p>
<ol>
<li><em>boot2-example-0.0.1-SNAPSHOT.jar</em>：46.6MB</li>
<li><em>boot2-example-0.0.1-SNAPSHOT.jar.original</em>：52KB</li>
</ol>
<p>其中，<em>boot2-example-0.0.1-SNAPSHOT.jar</em>是通过SpringBoot提供的打包插件采用新的格式打成一体化的Jar，包含了所有的依赖，所以比较大，有<strong>46.6MB</strong>；而<em>boot2-example-0.0.1-SNAPSHOT.jar.original</em>则是Java原生的打包方式生成的，仅仅只包含了项目本身的内容，没有依赖，所以比较小，52KB。</p>
<p>简单的从大小来看也知道52KB的原生Jar包是不可能独立的运行的，想要通过这个Jar包运行的话，必须要通过<em>-classpath</em>来指定所需要的依赖路径；</p>
<p>而 SpringBoot 插件打出来的包就可以独立运行，因为它将所依赖的包也一同包括进来了，通过一定的组织结构和定制的 <em>ClassLoader</em> 实现了 <strong>Jar in Jar</strong> 的加载与执行；</p>
<p>我们通过<strong>Archetype</strong>或者通过<a href="http://start.spring.io" target="_blank" rel="noopener">http://start.spring.io</a>新建一个SpringBoot应用的时候，在<em>pom.xml</em>中我们都会看到SpringBoot内置的Maven打包插件，如所示（这是完整的插件配置，并不在项目的<em>pom.xml</em>，实际上它定义在<em>spring-boot-starter-parent</em>中）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>$&#123;start-class&#125;<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>感兴趣的同学可以去翻阅一下这个插件打包的源码，了解是怎么组织最终的代码结构的，这里我们只需要了解到其独特的包结构是通过这个插件打包出来的就行，我们重点分析最终打好的包，并分析SpringBoot是怎么运行起来的；</p>
<h2 id="2-SpringBoot-FatJar-的组织结构"><a href="#2-SpringBoot-FatJar-的组织结构" class="headerlink" title="2. SpringBoot FatJar 的组织结构"></a>2. SpringBoot FatJar 的组织结构</h2><p>我们将<strong>SpringBoot</strong>打的可执行Jar展开后的结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.yml</span><br><span class="line">│   │   ├── com</span><br><span class="line">│   │   │   └── doleje</span><br><span class="line">│   │   │       └── boot2</span><br><span class="line">│   │   │           └── example</span><br><span class="line">│   │   └── i18n</span><br><span class="line">│   │       ├── message.properties</span><br><span class="line">│   │       ├── message_en_US.properties</span><br><span class="line">│   │       └── message_zh_CN.properties</span><br><span class="line">│   └── lib</span><br><span class="line">│       ├── spring-boot-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-autoconfigure-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-configuration-processor-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-aop-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-cache-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-data-jpa-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-jdbc-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-json-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-logging-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-security-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-tomcat-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── spring-boot-starter-web-2.1.0.RELEASE.jar</span><br><span class="line">│       ├── ...</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   ├── maven</span><br><span class="line">│   │   └── com.dole.framework</span><br><span class="line">│   │       └── boot2-example</span><br><span class="line">│   │           ├── pom.properties</span><br><span class="line">│   │           └── pom.xml</span><br><span class="line">│   └── spring-configuration-metadata.json</span><br><span class="line">├── org</span><br><span class="line">│   └── springframework</span><br><span class="line">│       └── boot</span><br><span class="line">│           └── loader</span><br><span class="line">│               ├── ExecutableArchiveLauncher.class</span><br><span class="line">│               ├── JarLauncher.class</span><br><span class="line">│               ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">│               ├── LaunchedURLClassLoader.class</span><br><span class="line">│               ├── Launcher.class</span><br><span class="line">│               ├── MainMethodRunner.class</span><br><span class="line">│               ├── ...</span><br></pre></td></tr></table></figure>
<ul>
<li>BOOT-INF：包含了我们的项目代码（<strong>classes</strong>目录），以及所需要的依赖（<strong>lib</strong> 目录）</li>
<li>META-INF：常见的Jar包元信息，我们的启动信息将在这里配置</li>
<li>org.springframework.boot.loader：SpringBoot的加载器代码，实现的<strong>Jar in Jar</strong>加载的魔法源</li>
</ul>
<p>我们看到，如果去掉<strong>BOOT-INF</strong>目录，这将是一个非常普通且标准的Jar包，包括元信息以及可执行的代码部分，其<em>/META-INF/MAINFEST.MF</em>指定了Jar包的启动元信息，<strong>org.springframework.boot.loader</strong>执行对应的逻辑操作。</p>
<h2 id="3-META-INF-MAINFEST-MF-元信息分析"><a href="#3-META-INF-MAINFEST-MF-元信息分析" class="headerlink" title="3. /META-INF/MAINFEST.MF 元信息分析"></a>3. /META-INF/MAINFEST.MF 元信息分析</h2><p>元信息内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: boot2-example</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Built-By: ivan</span><br><span class="line">Implementation-Vendor-Id: com.dole.framework</span><br><span class="line">Spring-Boot-Version: 2.1.0.RELEASE</span><br><span class="line">Implementation-Vendor: DoLe Team</span><br><span class="line"></span><br><span class="line"># 整个Jar包的执行入口</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br><span class="line"></span><br><span class="line"># 定义了应用的入口</span><br><span class="line">Start-Class: com.doleje.boot2.example.Boot2ExampleApplication</span><br><span class="line"></span><br><span class="line"># 定义了应用的代码目录</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line"></span><br><span class="line"># 定义了应用所依赖的库目录</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line"></span><br><span class="line">Created-By: Apache Maven 3.3.9</span><br><span class="line">Build-Jdk: 1.8.0_191</span><br><span class="line">Implementation-URL: https://projects.spring.io/spring-boot/#/spring-bo</span><br><span class="line"> ot-starter-parent/dole-boot2-parent/boot2-example</span><br></pre></td></tr></table></figure>
<p>根据上面的注释我们了解到，除了一些常规提版本信息之外，主要指定了：</p>
<ol>
<li>两个入口：一个用于执行标准的<em>java -jar</em>命令，一个用于查询真正的业务入口类；</li>
<li>两个目录：一个用于指定加载应用类的入口，一个指定了应用的依赖库，即我们所说的<em>-classpath</em>；</li>
</ol>
<h2 id="4-JarLauncher"><a href="#4-JarLauncher" class="headerlink" title="4. JarLauncher"></a>4. JarLauncher</h2><p>根据上一段落的讲解，我们知道在通过独立<em>java -jar</em>执行时，是一个标准的Jar执行过程，即通过<em>MAINFEST.MF</em>的定义进入到我们的<em>Main-Class</em>进行执行，即：<em>org.springframework.boot.loader.JarLauncher</em>，注意这个类不在我们的应用中，也不在<strong>SpringBoot</strong>的基础框架中，所以我们直接在应用代码中是找不到这个类的，如果想看这个类的源码，我们可以将下面的依赖加入到项目中去：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-loader<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>JarLauncher</em>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarLauncher</span> <span class="keyword">extends</span> <span class="title">ExecutableArchiveLauncher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_CLASSES = <span class="string">"BOOT-INF/classes/"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_LIB = <span class="string">"BOOT-INF/lib/"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JarLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">JarLauncher</span><span class="params">(Archive archive)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(archive);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">			<span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> JarLauncher().launch(args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类比较简单，真正的启动逻辑都在其父类中（两级父类<em>ExecutableArchiveLauncher</em>&amp;<em>Launcher</em>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutableArchiveLauncher</span> <span class="keyword">extends</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Archive archive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先把启动流程放一放，来看看这里出现的一个很重要的一个概念：<em>Archive</em>。</p>
<p>archive即归档文件，这个概念在linux下比较常见，通常就是一个tar/zip格式的压缩包，jar是zip格式。<br>在spring boot里，抽象出了Archive的概念，一个archive可以是一个jar（JarFileArchive），也可以是一个文件目录（ExplodedArchive）。可以理解为Spring boot抽象出来的统一访问资源的层。</p>
<p>上面的demo-0.0.1-SNAPSHOT.jar 是一个Archive，然后demo-0.0.1-SNAPSHOT.jar里的/lib目录下面的每一个Jar包，也是一个Archive，就是嵌套的 Archive 概念。</p>
<p>每个 Archive 有一个自己的 URL，便于 ClassLoader 来加载，标准的 Java Archive 提供的 URL 如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/</span><br></pre></td></tr></table></figure>
<p>以 <em>!/</em> 分隔，且只支持一个，不支持嵌套，而 SpringBoot 对其的扩展后的 URL 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/demo/target/demo-0.0.1-SNAPSHOT.jar!/lib/spring-beans-4.2.3.RELEASE.jar!/META-INF/MANIFEST.MF</span><br></pre></td></tr></table></figure>
<p>可以看到以 <em>!/</em>分隔的 Jar in Jar 的资源表达方式。</p>
<p>当然，标准的 ClassLoader 是不支持这种资源 URL 格式的，而为了支持这种 Jar in Jar 的嵌套资源，SpringBoot 实现了自己扩展的 ClassLoader。</p>
<p>构建 Archive 的代码在 <em>Launcher</em> 里面，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Archive <span class="title">createArchive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">   CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">   URI location = (codeSource != <span class="keyword">null</span>) ? codeSource.getLocation().toURI() : <span class="keyword">null</span>;</span><br><span class="line">   String path = (location != <span class="keyword">null</span>) ? location.getSchemeSpecificPart() : <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to determine code source archive"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   File root = <span class="keyword">new</span> File(path);</span><br><span class="line">   <span class="keyword">if</span> (!root.exists()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"Unable to determine code source archive from "</span> + root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (root.isDirectory() ? <span class="keyword">new</span> ExplodedArchive(root)</span><br><span class="line">         : <span class="keyword">new</span> JarFileArchive(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见最后一行，如果是目录的话将会创建 <em>ExplodedArchive</em>，否则将会创建一个 <em>JarFileArchive</em>。</p>
<h2 id="5-LaunchedURLClassLoader"><a href="#5-LaunchedURLClassLoader" class="headerlink" title="5. LaunchedURLClassLoader"></a>5. LaunchedURLClassLoader</h2><p>前面提到 SpringBoot 定义了一种嵌套的 Jar in Jar 格式，这种格式是不被标准的 Java ClassLoader 所支持，这就需要自定义的 ClassLoader 来完成这种内嵌的资源加载。</p>
<p>一般来说 ClassLoader 除了加载 Java 字节码生成类之外，还需要加载指定的资源。SpringBoot 的扩展 ClassLoader 是 <em>LaunchedURLClassLoader</em>，入口地址仍然在 <em>Launcher</em> 中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application. This method is the initial entry point that should be</span></span><br><span class="line"><span class="comment"> * called by a subclass &#123;<span class="doctag">@code</span> public static void main(String[] args)&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the incoming arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the application fails to launch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   JarFile.registerUrlProtocolHandler();</span><br><span class="line">   ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">   launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实如果知道了资源的格式（自己定义的，当然知道），再根据规则来自定义实现相应的 <em>ClassLoader</em> 是一件非常容易的事情，只需要实现 <em>ClassLoader.findResource</em> 并根据规则来返回资源的路由即可。SpringBoot 通过定义了一个 <em>URLStreamHandler</em> 来实现这种资源的查找与路由，具体的实现过程可以查阅 <em>org.springframework.boot.loader.jar.Handler</em>，这里不再帖出来了。</p>
<p>而 <em>Handler</em> 是如何和我们的资源关联起来的呢，这部分代码是在 <em>JarFile.getUrl()</em> 方法里面，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a URL that can be used to access this JAR file. <span class="doctag">NOTE:</span> the specified URL</span></span><br><span class="line"><span class="comment"> * cannot be serialized and or cloned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException if the URL is malformed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.url == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Handler handler = <span class="keyword">new</span> Handler(<span class="keyword">this</span>);</span><br><span class="line">      String file = <span class="keyword">this</span>.rootFile.getFile().toURI() + <span class="keyword">this</span>.pathFromRoot + <span class="string">"!/"</span>;</span><br><span class="line">      file = file.replace(<span class="string">"file:////"</span>, <span class="string">"file://"</span>); <span class="comment">// Fix UNC paths</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 关联定制的 Handler 以处理 Jar in Jar 的资源路由</span></span><br><span class="line">      <span class="keyword">this</span>.url = <span class="keyword">new</span> URL(<span class="string">"jar"</span>, <span class="string">""</span>, -<span class="number">1</span>, file, handler);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>JarFile</em> 组成了我们的 <em>JarFileArchive</em>，而我们的 <em>JarFile</em> 在执行 <em>getUrl()</em> 时，会通过之前定义好的 <em>Handler</em> 来完成嵌套资源的路由，以便定制的 <em>ClassLoader</em> 加载。</p>
<p>至此，我们解决了 SpringBoot 打包，并解压完成压缩包内嵌套资源的加载问题，之后的执行过程将和普通的 Java 应用程序是一样的，大家可以参考另外一篇文章<a href="/2018/12/20/springboot-yuan-ma-jie-du-qi-dong-pian/">SpringBoot源码解读——启动篇</a>来了解。</p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot源码解读——启动篇</title>
    <url>/2018/12/20/springboot-yuan-ma-jie-du-qi-dong-pian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文主要基于SpringBoot-2.1.0.RELEASE版本分析其启动过程，以及如何完成自动配置的过程。学习理解SpringBoot是如何将我们从繁重的配置文件中解救出来的。</p>
<p>为了演示重点和缩短文章，文中的代码引用通常会省略掉非讲解点的代码。</p>
</blockquote>
<a id="more"></a>
<h3 id="一、示例及入口"><a href="#一、示例及入口" class="headerlink" title="一、示例及入口"></a>一、示例及入口</h3><p>​    一个典型的SpringBoot的应用的入口代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot2ExampleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Boot2ExampleApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    如果你了解过SpringBoot或者在哪里看到过SpringBoot应用的样子（你也可以在<a href="https://start.spring.io/" target="_blank" rel="noopener">SPRING INITIALIZR</a>生成一个最简单的模板应用），一定会惊叹于它的简洁与强大。</p>
<p>​    从代码也能看出，所有有关SpringBoot的魔法，都隐藏<code>@SpringBootApplication</code>和<code>SpringApplication.run</code>中，接下来我们将从这两个概念入手，逐步分析出SpringBoot的运行原理。</p>
<h3 id="二、-SpringBootApplication的解析"><a href="#二、-SpringBootApplication的解析" class="headerlink" title="二、@SpringBootApplication的解析"></a>二、<code>@SpringBootApplication</code>的解析</h3><p>​    这是SpringBoot应用的初始入口注解，定义的核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 各种属性...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到它其实是一个组合其它注解的入口而已，其重点在于上面的3个注解：<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>。其中<code>@ComponentScan</code>可能大家很熟悉，它相当于我们之前在XML配置中的<code>&lt;context:component-scan&gt;</code>节点，主要用来扫描我们通过<strong>JavaConfig</strong>方式定义的SpringBean。而<code>@EnableAutoConfiguration</code>我们打开其源码会发现它只是一个标记接口，仅仅是开启了<strong>JavaConfig</strong>能力，并没有什么魔法。我们会重点讲解<code>@EnableAutoConfiguration</code>这个注解，因为<strong>SpringBoot</strong>的重点就在于自动配置，而最终的实现手段就来自于这个注解。</p>
<p>​    如下是<code>@EnableAutoConfiguration</code>的核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">	 * applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这个注解本身也没有什么实际的功能，仅仅只是定义了自动配置过程中想要<strong>exclude</strong>的类，而真正完成自动配置的过程都在它自身的注解<code>@Import(AutoConfigurationImportSelector.class)</code>上。</p>
<p>​    <code>@Import</code>我们知道是一个从其它<strong>JavaConfig</strong>类装载SpringBean定义的注解，所以我们的注意力要放在<code>AutoConfigurationImportSelector</code>，看看它里面有什么功能。其核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(</span><br><span class="line">			autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">	<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> AutoConfigurationEntry&#125; based on the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125;</span></span><br><span class="line"><span class="comment"> * of the importing &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoConfigurationMetadata the auto-configuration metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">		AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">			attributes);</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the &#123;<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">		AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">			getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the class used by &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; to load configuration</span></span><br><span class="line"><span class="comment"> * candidates.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the factory class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="comment">// 加载到所有 EnableAutoConfiguration 工厂</span></span><br><span class="line">	<span class="keyword">return</span> EnableAutoConfiguration<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    一路看下来，我们发现所有的重点都落在了<code>SpringFactoriesLoader.loadFactoryNames</code>方法中，所做的一切就是从<code>SpringFactoriesLoader</code>中查找所有的<code>EnableAutoConfiguration</code>工厂。</p>
<p>​    我们再看看<code>SpringFactoriesLoader</code>的核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 所有JAR包中的 spring.factories 位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Load and instantiate the factory implementations of the given type from</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given class loader.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The returned factories are sorted through &#123;<span class="doctag">@link</span> AnnotationAwareOrderComparator&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If a custom instantiation strategy is required, use &#123;<span class="doctag">@link</span> #loadFactoryNames&#125;</span></span><br><span class="line"><span class="comment">	 * to obtain all registered factory names.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading (can be &#123;<span class="doctag">@code</span> null&#125; to use the default)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IllegalArgumentException if any factory implementation class cannot</span></span><br><span class="line"><span class="comment">	 * be loaded or if an error occurs while instantiating any factory</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #loadFactoryNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">		List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line">    	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">		<span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">			result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment">	 * given type from &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given</span></span><br><span class="line"><span class="comment">	 * class loader.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		String factoryClassName = factoryClass.getName();</span><br><span class="line">		<span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">        <span class="comment">// 扫描并加载所有的 spring.factories</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">			result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">			<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">				URL url = urls.nextElement();</span><br><span class="line">				UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">				Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">				<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">					String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">					<span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">						result.add(factoryClassName, factoryName.trim());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cache.put(classLoader, result);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    至此，<code>@SpringBootApplication</code>的核心代码执行完成，我们发现它仅仅只是做了一件事情：</p>
<blockquote>
<p><strong>扫描所有JAR包中 <em>META-INF/spring.factories</em> 文件中配置的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>来完成各个组件的自动化配置</strong></p>
</blockquote>
<p>​    我们后面会讲解这个自动化配置的过程，已经<strong>spring.factories</strong>文件的格式、内容以及功能。我们暂时先放下<code>@SpringBootApplication</code>，先来看看SpringBoot魔法的另外一个支点<code>SpringApplication.run</code>的执行过程。</p>
<h3 id="三、SpringApplication-run的解析"><a href="#三、SpringApplication-run的解析" class="headerlink" title="三、SpringApplication.run的解析"></a>三、<code>SpringApplication.run</code>的解析</h3><pre><code>#### 关键路径源码分析
</code></pre><p>​    在分析这个方法之前，我们先来看看<code>SpringApplication</code>这个类的构造方法，看看它做了什么事情，其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">	Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">	<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">	<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意如下的2行代码，分别用来设置容器的初始化工作和监听器的</span></span><br><span class="line">	setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">			ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    我们看到<code>setInitializers</code>和<code>setListeners</code>这两个方法其实都是调用了<code>getSpringFactoriesInstances</code>方法，只不过一个是获取初始化的组件，一个是获取监听器组件。我们跟进去看看这个方法是如何做的，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">		Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">	ClassLoader classLoader = getClassLoader();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 注意这行代码</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(</span><br><span class="line">			SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    </span><br><span class="line">	List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">			classLoader, args, names);</span><br><span class="line">	AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">	<span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    怎么样，是不是很眼熟，我们又一次看到了<code>SpringFactoriesLoader.loadFactoryNames</code>的调用，只不过这一次不是获取<code>EnableAutoConfiguration</code>，而是<code>ApplicationContextInitializer</code>和<code>ApplicationListener</code>。但是最终的来源仍然是：<strong>各个JAR包中的 spring.factories</strong>，这个文件大有玄机，后面我们重点分析，现在大家只要知道在初始化的时候会读取这个文件就行了。</p>
<p>​    我们再来真正进入<code>SpringApplication.run</code>方法看看它做了什么，辗转几次之后，其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 获取运行监听器并启动</span></span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">				args);</span><br><span class="line">        <span class="comment">// 2. 准备环境信息，并从环境信息中配置需要忽略掉的 Bean 配置</span></span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">				applicationArguments);</span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 打印 Banner，这个可以自定义</span></span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">        </span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 获取异常报告器</span></span><br><span class="line">		exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">				SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">				new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 准备 ApplicationContext 并刷新</span></span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">				printedBanner);</span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 通知监听器</span></span><br><span class="line">		listeners.started(context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7. 执行 ApplicationRunner 和 CommandLineRunner</span></span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">		ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">		ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.1 执行 SpringApplication 构造方法中收集到的 Initializer</span></span><br><span class="line">	applyInitializers(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    其中第 1，4 步故技重施地从 <strong>spring.factories</strong> 中读取了<code>SpringApplicationRunListener</code>和<code>SpringBootExceptionReporter</code>的配置。第 2，5，6 步是Spring容器的标准构建启动过程，在这里不做讲述，有兴趣的同学可以关注我对Spring源码的研究文章。</p>
<p>​    我们重点讲解一下第 3 步<strong>Banner的处理</strong>和第 7 步 <strong>ApplicationRunner</strong> 的处理，因为这两个步骤在我们实际应用过程中经常会直接接触到。</p>
<h4 id="Banner-的处理"><a href="#Banner-的处理" class="headerlink" title="Banner 的处理"></a>Banner 的处理</h4><p>​    我们在启动一个SpringBoot的应用时，会在控制台打印如下的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::        (v2.1.0.RELEASE)</span><br></pre></td></tr></table></figure>
<p>​    这个就是默认的Banner信息，我们从源码看看这个Banner内容是怎么生成及怎么定制，其核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">printBanner</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Banner.Mode.OFF) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ResourceLoader resourceLoader = (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>)</span><br><span class="line">			? <span class="keyword">this</span>.resourceLoader : <span class="keyword">new</span> DefaultResourceLoader(getClassLoader());</span><br><span class="line">	SpringApplicationBannerPrinter bannerPrinter = <span class="keyword">new</span> SpringApplicationBannerPrinter(</span><br><span class="line">			resourceLoader, <span class="keyword">this</span>.banner);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Mode.LOG) &#123;</span><br><span class="line">		<span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, logger);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到是通过<code>SpringApplicationBannerPrinter</code>来打印这些信息的，那么这个类里面又是如何确定这些内容及如何去定制呢，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文本类 Banner 的路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BANNER_LOCATION_PROPERTY = <span class="string">"spring.banner.location"</span>;</span><br><span class="line"><span class="comment">// 图片类 Banner 的路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BANNER_IMAGE_LOCATION_PROPERTY = <span class="string">"spring.banner.image.location"</span>;</span><br><span class="line"><span class="comment">// 默认的 Banner 信息存放的文件名</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_BANNER_LOCATION = <span class="string">"banner.txt"</span>;</span><br><span class="line"><span class="comment">// 图片类 Banner 支持的文件后缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] IMAGE_EXTENSION = &#123; <span class="string">"gif"</span>, <span class="string">"jpg"</span>, <span class="string">"png"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Banner <span class="title">print</span><span class="params">(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Banner 信息</span></span><br><span class="line">	Banner banner = getBanner(environment);</span><br><span class="line">	banner.printBanner(environment, sourceClass, out);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PrintedBanner(banner, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">getBanner</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">	Banners banners = <span class="keyword">new</span> Banners();</span><br><span class="line">	banners.addIfNotNull(getImageBanner(environment));</span><br><span class="line">	banners.addIfNotNull(getTextBanner(environment));</span><br><span class="line">	<span class="keyword">if</span> (banners.hasAtLeastOneBanner()) &#123;</span><br><span class="line">		<span class="keyword">return</span> banners;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.fallbackBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.fallbackBanner;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 系统默认的 Banner</span></span><br><span class="line">	<span class="keyword">return</span> DEFAULT_BANNER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文本类 Banner</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">getTextBanner</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">	String location = environment.getProperty(BANNER_LOCATION_PROPERTY,</span><br><span class="line">			DEFAULT_BANNER_LOCATION);</span><br><span class="line">	Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(location);</span><br><span class="line">	<span class="keyword">if</span> (resource.exists()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResourceBanner(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片类 Banner</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">getImageBanner</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">	String location = environment.getProperty(BANNER_IMAGE_LOCATION_PROPERTY);</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">		Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(location);</span><br><span class="line">		<span class="keyword">return</span> resource.exists() ? <span class="keyword">new</span> ImageBanner(resource) : <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (String ext : IMAGE_EXTENSION) &#123;</span><br><span class="line">		Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(<span class="string">"banner."</span> + ext);</span><br><span class="line">		<span class="keyword">if</span> (resource.exists()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ImageBanner(resource);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到，其默认的Banner信息是从<code>classpath:banner.txt</code>文件中读取的，那么我们只需要在这个路径的文件中填写我们想要的内容即可完成Banner的定制化了。</p>
<p>​    同时，从源码我们可以看到，这个Banner是支持图片的，也就是我们可以指定一个图片文件作为Banner，SpringBoot会自动将图片转换成 ascII 字符图形来展示。</p>
<p>​    更厉害的是，最近的SpringBoot Banner还可以支持动画，我们在图片文件后缀中看到了<code>.gif</code>，感兴趣的话可以在<code>ImageBanner</code>源码中学习SpringBoot是如何进行这个转换的。</p>
<p>​    最后，我们看看系统默认的Banner类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringBootBanner</span> <span class="keyword">implements</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BANNER = &#123; <span class="string">""</span>,</span><br><span class="line">			<span class="string">"  .   ____          _            __ _ _"</span>,</span><br><span class="line">			<span class="string">" /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\"</span>,</span><br><span class="line">			<span class="string">"( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\"</span>,</span><br><span class="line">			<span class="string">" \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )"</span>,</span><br><span class="line">			<span class="string">"  '  |____| .__|_| |_|_| |_\\__, | / / / /"</span>,</span><br><span class="line">			<span class="string">" =========|_|==============|___/=/_/_/_/"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_BOOT = <span class="string">" :: Spring Boot :: "</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRAP_LINE_SIZE = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBanner</span><span class="params">(Environment environment, Class&lt;?&gt; sourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">			PrintStream printStream)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (String line : BANNER) &#123;</span><br><span class="line">			printStream.println(line);</span><br><span class="line">		&#125;</span><br><span class="line">		String version = SpringBootVersion.getVersion();</span><br><span class="line">		version = (version != <span class="keyword">null</span>) ? <span class="string">" (v"</span> + version + <span class="string">")"</span> : <span class="string">""</span>;</span><br><span class="line">		StringBuilder padding = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">while</span> (padding.length() &lt; STRAP_LINE_SIZE</span><br><span class="line">				- (version.length() + SPRING_BOOT.length())) &#123;</span><br><span class="line">			padding.append(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT,</span><br><span class="line">				AnsiColor.DEFAULT, padding.toString(), AnsiStyle.FAINT, version));</span><br><span class="line">		printStream.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    是不是看到了我们熟悉的启动 Banner 图案。</p>
<h4 id="ApplicationRunner与CommandLineRunner的使用"><a href="#ApplicationRunner与CommandLineRunner的使用" class="headerlink" title="ApplicationRunner与CommandLineRunner的使用"></a><code>ApplicationRunner</code>与<code>CommandLineRunner</code>的使用</h4><p>​    这一节我们讲解在启动流程中的第 7 步：ApplicationRunner 是如何工作的。</p>
<p>​    在启动流程中我们看到，这是整个启动流程的最后一个环节了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 7. 执行 ApplicationRunner</span></span><br><span class="line">callRunners(context, applicationArguments);</span><br></pre></td></tr></table></figure>
<p>​    我们可以跟踪进去看看这个<code>callRunners</code>方法做了什么，其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从Spring容器中获取 ApplicationRunner</span></span><br><span class="line">	runners.addAll(context.getBeansOfType(ApplicationRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从Spring容器中获取 CommandLineRunner</span></span><br><span class="line">	runners.addAll(context.getBeansOfType(CommandLineRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经过排序后，依次执行这些接口的 run 方法</span></span><br><span class="line">	AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">	<span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">			callRunner((ApplicationRunner) runner, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">			callRunner((CommandLineRunner) runner, args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(ApplicationRunner runner, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		(runner).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute ApplicationRunner"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到这是SpringBoot容器在启动完成后给我们提供的扩展接口，如果我们在实际的应用场景中有一些操作（比如数据初始化之类的）需要在容器启动后执行，那么这两个地方就是我们的扩展点。</p>
<blockquote>
<p>好像是同样的功能点，SpringBoot提供了两个不同的操作，那么它们有什么区别，什么时候该用哪个呢？</p>
<p><strong>答案是：没有区别</strong></p>
<p>从源码中我们也看到了，唯一的区别是这两个接口接受参数的方式不同，一个是原始的<code>String[]</code>，一个是格式化好的<code>ApplicationArguments</code>，用户可以根据自己的喜好和场景随意选择。</p>
</blockquote>
<h3 id="四、spring-factories-解析"><a href="#四、spring-factories-解析" class="headerlink" title="四、spring.factories 解析"></a>四、<code>spring.factories</code> 解析</h3><p>​    在前文中我们提到<code>@SpringBootApplication</code>的核心作用是扫描所有JAR包中 <em>META-INF/spring.factories</em> 文件中配置的 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>来完成各个组件的自动化配置。同时，在<code>SpringApplicaiton.run</code>的启动过程中，也多次通过<code>SpringFactoriesLoader.loadFactoryNames</code>从<em>META-INF/spring.factories</em>中加载各类预定义的组件（初始化器、监听器等）。那么这个文件究竟长什么样，里面都有哪些东西呢？下面我们就通过真实的实例来讲解，如下代码提取（有省略）自<code>spring-boot-autoconfig-2.1.0.RELEAST/META-INFO/spring.factories</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure>
<p>​    可以看到，这份主要分为 7 个部分，注意，这 7 个部分并非所有的 <strong>spring.factories</strong> 文件都会有，实际上每个部分都是可选的。这 7 个部分刚刚我们在源码分析中也见过一些了，分别是：</p>
<ul>
<li><p><strong>Initializers</strong>：应用初始化器，在应用初始化的时候执行。</p>
</li>
<li><p><strong>Application Listeners</strong>：应用监听器，监听应用启动的各个事件。</p>
</li>
<li><p><strong>Auto Configuration Import Listeners</strong>：自动配置引入时的监听器。</p>
</li>
<li><p><strong>Auto Configuration Import Filters</strong>：自动配置时的过滤器。</p>
</li>
<li><p><strong>Auto Configure</strong>：自动配置类，这个类别非常重要，它定义了各种需要自动配置的模板，这里只是摘取了一小部分，从源码中可以看到这个配置中包含了几乎所有目前能看到的（能集成）的框架，目前的版本一共有<strong><em>超过100</em></strong>个配置类。</p>
</li>
<li><p><strong>Failure analyzers</strong>：这个定义了启动过程中的失败处理器，它将用于分析失败的原因，则将一些诊断信息所示给用户，协助用户解决问题。</p>
</li>
<li><p><strong>Template availability providers</strong>：这里定义了一些模板引擎的支持，用于判定当前系统中是否支持一些模板引擎。非常遗憾的是，由于<strong><em>Velocity</em></strong>的疏于维护，在<strong>SpringBoot1.5</strong>的时候被除名，不再提供官方的支持了。需要的同学可以自行去扩展，或者<a href="mailto:huangfengjing@gmail.com" target="_blank" rel="noopener">联系我</a>。</p>
</li>
</ul>
<p>我们可以随便打开一个<strong>auto configure</strong>项，例如我们在传统<strong>Spring</strong>应用中熟知的<code>JdbcTemplateAutoConfiguration</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">JdbcTemplate</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnSingleCandidate</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">DataSourceAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">JdbcProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcTemplateAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> JdbcProperties properties;</span><br><span class="line"></span><br><span class="line">		JdbcTemplateConfiguration(DataSource dataSource, JdbcProperties properties) &#123;</span><br><span class="line">			<span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">			<span class="keyword">this</span>.properties = properties;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@Primary</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span>(JdbcOperations<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">		<span class="title">public</span> <span class="title">JdbcTemplate</span> <span class="title">jdbcTemplate</span>() </span>&#123;</span><br><span class="line">			JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(<span class="keyword">this</span>.dataSource);</span><br><span class="line">			JdbcProperties.Template template = <span class="keyword">this</span>.properties.getTemplate();</span><br><span class="line">			jdbcTemplate.setFetchSize(template.getFetchSize());</span><br><span class="line">			jdbcTemplate.setMaxRows(template.getMaxRows());</span><br><span class="line">			<span class="keyword">if</span> (template.getQueryTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				jdbcTemplate.setQueryTimeout((<span class="keyword">int</span>) template.getQueryTimeout().getSeconds());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到，当系统中<code>@ConditionalOnMissingBean(JdbcOperations.class)</code>时，它会为我们创建一个<code>JdbcTemplate</code>，这样我们就可以直接在项目中使用 <code>@Autowired</code> 注入了。</p>
<blockquote>
<p>实际上，<strong>spring.factories</strong> 只是一个普通的 <strong>properties</strong>文件，里面的内容也是可以随意定制的，只不过<strong>SpringBoot</strong>用作了自动配置，给我们提供了一个范例。这 7 个部分也仅仅只是 <strong>spring-boot-autoconfigure</strong>所需要的，很多其它的第三方JAR包中的 <strong>spring.factories</strong> 会定义很多自己需要的配置。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，我们以源码解读的试完整地讲解了整个<strong>SpringBoot</strong>的启动过程。讲解了如何从<code>@SpringBootApplication</code>注解找到所有自动配置的类并完成配置过程，也从<code>SpringApplication.run</code>的执行过程中重现了<strong>SpringBoot</strong>应用在启动过程中的各个生命周期。也讲解了项目中常见的扩展点，以及如何去扩展我们的应用能力。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript压缩工具</title>
    <url>/2009/06/28/javascript-ya-suo-gong-ju/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>怎么压缩Js？为什么要压缩Javascript？ Javascript compressed/crunched<br>开发Ajax除了自己要写js代码外，同样也免不了要使用其它第三方js库，是否该为JavaScript减肥？<br>当你提高了用户体验，做出了很绚丽的效果而欣喜的时候，是否想过优化一下js的效率,比如微软的live，其中的js做了压缩处理。JS的速度分为两种，下载速度和执行速度。今天就先来说说下载速度。要想js的下载速度快，就需要尽量减小js文件的大小。这里我们可以使用一个工具ESC(ECMAScript cruncher)来帮我们完成这个工作，不过这个工具只能在Windows下使用。<a href="http://www.saltstorm.net/depo/esc/introduction.wbm?pod=js" target="_blank" rel="noopener">http://www.saltstorm.net/depo/esc/introduction.wbm?pod=js</a>下载ESC.zip,解压后看看它的帮助文档。很简单。 </p>
<p>压缩级别分为5种，从0到4 </p>
<p>Level 0 :: No compression </p>
<p>Level 1 :: Comment removal </p>
<p>Level 2 :: Whitespace removal </p>
<p>Level 3 :: Newline removal </p>
<p>Level 4 :: Variable substitution </p>
<p>在WINDOWS命令行下执行 </p>
<p>cscript ESC.wsf -ow menu2.js menu.js将会把menu.js按照js压缩级别2来压缩（默认js压缩级别为2）为menu2.js </p>
<p>cscript ESC.wsf -l 3 -ow menu3.js menu.js将会把menu.js按照js压缩级别3来压缩为menu3.js </p>
<p>需要注意的是，js压缩级别4会把变量名修改，如果你的js中用到了全局变量或者类的话，就不能使用该压缩级别了，否则其它使用你的js的文件可能会无法正常运行。 </p>
<p>试了一下，把yui的menu.js压缩了一下，对应的级别和压缩率分别如下： </p>
<p>js压缩级别1 :: 压缩率44.41% </p>
<p>js压缩级别2 :: 压缩率62.82% </p>
<p>js压缩级别1 :: 压缩率64.93% </p>
<p>原来130多K的js文件压缩后也就40多K，看来还是挺有用处的。  </p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中Bean的生命周期</title>
    <url>/2015/08/10/spring-zhong-bean-de-sheng-ming-zhou-qi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Spring框架中，一旦把一个Bean纳入Spring IOC容器之中，这个Bean的生命周期就会交由容器进行管理，所以准确的了解Spring Bean的生命周期是非常必要的。我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。</p>
<p>Spring是通过一系列的回调方法来完成 Bean 的生命周期管理的，开发者通过实现Spring的<code>InitializeingBean</code>和<code>DisposableBean</code>接口，就可以让容器来介入 Bean 生命周期的管理，主要是初始化阶段和销毁阶段的处理。除了初始化和销毁回调，Spring管理的对象也实现了<code>Lifecycle</code>接口来让管理的对象在容器的生命周期内启动和关闭。</p>
<blockquote>
<p>JSR-250的<code>@PostConstruct</code>和<code>@PreDestroy</code>注解就是现代Spring应用生命周期回调的最佳实践。使用这些注解意味着Bean不在耦合在Spring特定的接口上。<br>如果开发者不想使用JSR-250的注解，仍然可以考虑使用<code>init-method</code>和<code>destroy-method</code>定义来解耦。</p>
</blockquote>
<p>内部来说，Spring框架使用<code>BeanPostProcessor</code>的实现来处理任何接口的回调，<code>BeanPostProcessor</code>能够找到并调用合适的方法。如果开发者需要一些Spring并不直接提供的生命周期行为，开发者可以自行实现一个<code>BeanPostProcessor</code>。</p>
<p>本文主要介绍我们常见的一些生命周期的管理方式。</p>
<a id="more"></a>
<h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点，如下图所示：</p>
<div id="flowchart-0" class="flow-chart"></div>


<p>可以看到，Bean 的整个生命周期相关的过程主要分为如下几种类型：</p>
<ul>
<li>Bean级生命周期接口：包括Bean本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的 <em>init-method</em> 和 <em>destroy-method</em>指定的方法，<code>InitializingBean</code> 和 <code>DiposableBean</code> 的接口实现；</li>
<li>容器级生命周期接口：包括了 <code>InstantiationAwareBeanPostProcessor</code> 和 <code>BeanPostProcessor</code> 以及 <code>LifecycleProcessor</code> 这三个接口实现，一般称它们的实现类为“后置处理器”；</li>
<li>工厂后置处理器接口：包括了<code>BeanFactoryPostProcessor</code>的各种实现，比如<code>PropertyPlaceholderConfigurer</code>， <code>CustomEditorConfigurer</code>， <code>PropertyOverrideConfigurer</code> 等等非常有用的工厂后置处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li>
</ul>
<p>接下来我们将分别介绍这几类生命周期的相关内容。</p>
<h2 id="3-Bean-级生命周期"><a href="#3-Bean-级生命周期" class="headerlink" title="3. Bean 级生命周期"></a>3. Bean 级生命周期</h2><h3 id="2-1-初始化回调"><a href="#2-1-初始化回调" class="headerlink" title="2.1 初始化回调"></a>2.1 初始化回调</h3><p><code>org.springframework.beans.factory.InitializingBean</code>接口允许Bean在所有的必要的依赖配置配置完成后来执行初始化Bean的操作。<code>InitializingBean</code>接口中特指了一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>
<p>Spring团队建议开发者不要使用<code>InitializingBean</code>接口，因为这样会不必要的将代码耦合到Spring之上（其实问题也不大，现实场景中我们的应用一般也不会脱离 Spring 框架，这么说只是为了理想中的应用设计模式），而通过使用<code>@PostConstruct</code>注解或者指定一个POJO的实现方法，比实现接口要更好。在基于XML的配置元数据上，开发者可以使用<code>init-method</code>属性来指定一个没有参数的方法。使用Java配置的开发者可以使用<code>@Bean</code>之中的<code>initMethod</code>属性，比如如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与如下代码一样效果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是前一个版本的代码是没有耦合到Spring的。</p>
<h3 id="2-2-销毁回调"><a href="#2-2-销毁回调" class="headerlink" title="2.2 销毁回调"></a>2.2 销毁回调</h3><p>实现了<code>org.springframework.beans.factory.DisposableBean</code>接口的Bean就能通让容器通过回调来销毁Bean所用的资源。<code>DisposableBean</code>接口包含了一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>
<p>同 <code>InitializingBean</code> 一样，Spring团队仍然不建议开发者来使用<code>DisposableBean</code>回调接口，因为这样会将开发者的代码耦合到Spring代码上。换种方式，比如使用<code>@PreDestroy</code>注解或者指定一个Bean支持的配置方法，比如在基于XML的配置元数据中，开发者可以在Bean标签上指定<code>destroy-method</code>属性。而在Java配置中，开发者可以配置<code>@Bean</code>的<code>destroyMethod</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码配置和如下配置是等同的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是第一段代码是没有耦合到Spring的。</p>
<blockquote>
<p><code>&lt;bean/&gt;</code>标签的<code>destroy-method</code>可以被配置为特殊指定的值，来方便让Spring能够自动的检查到<code>close</code>或者<code>shutdown</code>方法（可以实现<code>java.lang.AutoCloseable</code>或者<code>java.io.Closeable</code>都会匹配。）这个特殊指定的值可以配置到<code>&lt;beans/&gt;</code>的<code>default-destroy-method</code>来让所有的Bean实现这个行为。</p>
</blockquote>
<h3 id="3-3-默认初始化和销毁方法"><a href="#3-3-默认初始化和销毁方法" class="headerlink" title="3.3 默认初始化和销毁方法"></a>3.3 默认初始化和销毁方法</h3><p>当开发者不使用Spring特有的<code>InitializingBean</code>和<code>DisposableBean</code>回调接口来实现初始化和销毁方法的时候，开发者通常定义的方法名字都是好似<code>init()</code>，<code>initialize()</code>或者是<code>dispose()</code>等等。那么，想这类的方法就可以标准化，来让所有的开发者都使用一样的名字来确保一致性。</p>
<p>开发者可以配置Spring容器来针对每一个Bean都查找这种名字的初始化和销毁回调函数。也就是说，任何的一个应用开发者，都会在应用的类中使用一个叫<code>init()</code>的初始化回调，而不需要在每个Bean中定义<code>init-method=&quot;init&quot;</code>这中属性。Spring IoC容器会在Bean创建的时候调用那个方法（就如前面描述的标准生命周期一样。）这个特性也强制开发者为其他的初始化以及销毁回调函数使用同样的名字。</p>
<p>假设开发者的初始化回调方法名字为<code>init()</code>而销毁的回调方法为<code>destroy()</code>。那么开发者的类就会好似如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBlogService</span> <span class="keyword">implements</span> <span class="title">BlogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlogDao blogDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlogDao</span><span class="params">(BlogDao blogDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blogDao = blogDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this is (unsurprisingly) the initialization callback method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blogDao == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The [blogDao] property must be set."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blogService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultBlogService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogDao"</span> <span class="attr">ref</span>=<span class="string">"blogDao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;beans/&gt;</code>标签上面的<code>default-init-method</code>属性会让Spring IoC容器识别叫做<code>init</code>的方法来作为Bean的初始化回调方法。当Bean创建和装载之后，如果Bean有这么一个方法的话，Spring容器就会在合适的时候调用。</p>
<p>类似的，开发者也可以配置默认销毁回调函数，基于XML的配置就在<code>&lt;beans/&gt;</code>标签上面使用<code>default-destroy-method</code>属性。</p>
<p>当存在一些Bean的类有了一些回调函数，而和配置的默认回调函数不同的时候，开发者可以通过特指的方式来覆盖掉默认的回调函数。以XML为例，就是通过使用<code>&lt;bean&gt;</code>标签的<code>init-method</code>和<code>destroy-method</code>来覆盖掉<code>&lt;beans/&gt;</code>中的配置。</p>
<p>Spring容器会做出如下保证，Bean会在装载了所有的依赖以后，立刻就开始执行初始化回调。这样的话，初始化回调只会在直接的Bean引用装载好后调用，而AOP拦截器还没有应用到Bean上。首先目标Bean会完全初始化好，然后，AOP代理以及其拦截链才能应用。如果目标Bean以及代理是分开定义的，那么开发者的代码甚至可以跳过AOP而直接和引用的Bean交互。因此，在初始化方法中应用拦截器会前后矛盾，因为这样做耦合了目标Bean的生命周期和代理/拦截器，还会因为同Bean直接交互而产生奇怪的现象。</p>
<h3 id="3-4-联合生命周期机制"><a href="#3-4-联合生命周期机制" class="headerlink" title="3.4 联合生命周期机制"></a>3.4 联合生命周期机制</h3><p>在Spring 2.5之后，开发者有三种选择来控制Bean的生命周期行为：</p>
<ul>
<li><code>InitializingBean</code>和<code>DisposableBean</code>回调接口</li>
<li>自定义的<code>init()</code>以及<code>destroy</code>方法</li>
<li>使用<code>@PostConstruct</code>以及<code>@PreDestroy</code>注解</li>
</ul>
<p>开发者也可以在Bean上联合这些机制一起使用</p>
<blockquote>
<p>如果Bean配置了多个生命周期机制，而且每个机制配置了不同的方法名字，那么每个配置的方法会按照后面描述的顺序来执行。然而，如果配置了相同的名字，比如说初始化回调为<code>init()</code>，在不止一个生命周期机制配置为这个方法的情况下，这个方法只会执行一次。</p>
</blockquote>
<p>如果一个Bean配置了多个生命周期机制，并且含有不同的方法名，执行的顺序如下：</p>
<ul>
<li>包含<code>@PostConstruct</code>注解的方法</li>
<li>在<code>InitializingBean</code>接口中的<code>afterPropertiesSet()</code>方法</li>
<li>自定义的<code>init()</code>方法</li>
</ul>
<p>销毁方法的执行顺序和初始化的执行顺序相同：</p>
<ul>
<li>包含<code>@PreDestroy</code>注解的方法</li>
<li>在<code>DisposableBean</code>接口中的<code>destroy()</code>方法</li>
<li>自定义的<code>destroy()</code>方法</li>
</ul>
<h2 id="4-容器级生命周期"><a href="#4-容器级生命周期" class="headerlink" title="4. 容器级生命周期"></a>4. 容器级生命周期</h2><h3 id="4-1-Bean后置处理器BeanPostProcessor"><a href="#4-1-Bean后置处理器BeanPostProcessor" class="headerlink" title="4.1 Bean后置处理器BeanPostProcessor"></a>4.1 Bean后置处理器<code>BeanPostProcessor</code></h3><p>这个接口主要用于在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些逻辑处理，它的接口定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span></span><br><span class="line"><span class="comment">	 * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span></span><br><span class="line"><span class="comment">	 * post-processor can decide whether to apply to either the FactoryBean or created</span></span><br><span class="line"><span class="comment">	 * objects or both through corresponding &#123;<span class="doctag">@code</span> bean instanceof FactoryBean&#125; checks.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span></span><br><span class="line"><span class="comment">	 * in contrast to all other BeanPostProcessor callbacks.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BeanPostProcessor</code>的主要特征是它将逐个处理IoC容器中的所有bean实例，而不仅仅是单个bean实例，通常<strong>用于根据特定标准检查bean属性的有效性或改变bean属性</strong>。</p>
<p><code>BeanPostProcessor</code>在 Bean 生命周期中的位置如下：</p>
<ol>
<li>通过构造函数或工厂方法创建Bean 实例</li>
<li>设置Bean 属性的值和bean引用</li>
<li>调用所有 <code>Aware</code> 接口中的 <code>Setter</code> 方法</li>
<li><strong>将Bean 实例传递给<code>postProcessBeforeInitialization()</code>每个bean后处理器的方法</strong></li>
<li>调用初始化回调方法</li>
<li><strong>将Bean 实例传递给 <code>postProcessAfterInitialization()</code> 每个bean后处理器的方法</strong></li>
<li>Bean 初始化完成</li>
<li>关闭容器时，调用销毁回调方法</li>
</ol>
<h3 id="4-2-实例后置处理器InstantiationAwareBeanPostProcessor"><a href="#4-2-实例后置处理器InstantiationAwareBeanPostProcessor" class="headerlink" title="4.2 实例后置处理器InstantiationAwareBeanPostProcessor"></a>4.2 实例后置处理器<code>InstantiationAwareBeanPostProcessor</code></h3><p>这个接口是 <code>BeanPostProcessor</code> 接口的一个子类，它多了三个方法，主要是添加了 <strong>Bean 实例化</strong> 的前后回调，注意，此时，所有的属性及依赖都还没设置。三个方法分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postProcessBeforeInstantiation方法的作用在目标对象被实例化之前调用的方法，可以返回目标实例的一个代理用来代替目标实例</span></span><br><span class="line"><span class="comment">// beanClass参数表示目标对象的类型，beanName是目标实例在Spring容器中的name</span></span><br><span class="line"><span class="comment">// 返回值类型是Object，如果返回的是非null对象，接下来除了postProcessAfterInitialization方法会被执行以外，其它bean构造的那些方法都不再执行。否则那些过程以及postProcessAfterInitialization方法都会执行</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postProcessAfterInstantiation方法的作用在目标对象被实例化之后并且在属性值被populate之前调用</span></span><br><span class="line"><span class="comment">// bean参数是目标实例(这个时候目标对象已经被实例化但是该实例的属性还没有被设置)，beanName是目标实例在Spring容器中的name</span></span><br><span class="line"><span class="comment">// 返回值是boolean类型，如果返回true，目标实例内部的返回值会被populate，否则populate这个过程会被忽视</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postProcessPropertyValues方法的作用在属性中被设置到目标实例之前调用，可以修改属性的设置</span></span><br><span class="line"><span class="comment">// pvs参数表示参数属性值(从BeanDefinition中获取)，pds代表参数的描述信息(比如参数名，类型等描述信息)，bean参数是目标实例，beanName是目标实例在Spring容器中的name</span></span><br><span class="line"><span class="comment">// 返回值是PropertyValues，可以使用一个全新的PropertyValues代替原先的PropertyValues用来覆盖属性设置或者直接在参数pvs上修改。如果返回值是null，那么会忽略属性设置这个过程(所有属性不论使用什么注解，最后都是null)</span></span><br><span class="line"><span class="function">PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>postProcessBeforeInstantiation</code>：方法是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；否则按照正常的流程走。</li>
<li><code>postProcessAfterInstantiation</code>：方法在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。如果该方法返回false，会忽略属性值的设置；如果返回true，会按照正常流程设置属性值。</li>
</ol>
<h2 id="5-工厂后置处理器"><a href="#5-工厂后置处理器" class="headerlink" title="5. 工厂后置处理器"></a>5. 工厂后置处理器</h2><h3 id="5-1-接口定义"><a href="#5-1-接口定义" class="headerlink" title="5.1 接口定义"></a>5.1 接口定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context's internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure>
<p>实现该接口，可以在Spring的Bean创建之前，修改Bean的定义属性。也就是说，Spring允许<code>BeanFactoryPostProcessor</code>在容器实例化任何其它Bean之前读取配置元数据，并可以根据需要进行修改，例如可以把Bean的 <em>scope</em> 从 <em>singleton</em> 改为 <em>prototype</em>，也可以把 <em>property</em> 的值给修改掉。可以同时配置多个<code>BeanFactoryPostProcessor</code>，并通过设置’order’属性来控制各个BeanFactoryPostProcessor的执行次序。</p>
<blockquote>
<p><strong>注意</strong>：<code>BeanFactoryPostProcessor</code>是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。接口方法的入参是<code>ConfigurrableListableBeanFactory</code>，使用该参数，可以获取到相关bean的定义信息。</p>
</blockquote>
<h3 id="5-2-示例"><a href="#5-2-示例" class="headerlink" title="5.2 示例"></a>5.2 示例</h3><p>如果我们有一个 Spring Bean 的定义如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foobar"</span> <span class="attr">class</span>=<span class="string">"com.doleje.demo.spring.model.FooBar"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"desc"</span> <span class="attr">value</span>=<span class="string">"测试一下啦"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"remark"</span> <span class="attr">value</span>=<span class="string">"这是备注信息啦啦啦"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们编写一个自定义的 <code>BeanFactoryPostProcessor</code>如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"调用MyBeanFactoryPostProcessor的postProcessBeanFactory"</span>);</span><br><span class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">"foobar"</span>);</span><br><span class="line">        log.info(<span class="string">"Properties: &#123;&#125;"</span>, bd.getPropertyValues().toString());</span><br><span class="line">        MutablePropertyValues pv =  bd.getPropertyValues();  </span><br><span class="line">        <span class="keyword">if</span> (pv.contains(<span class="string">"remark"</span>)) &#123;  </span><br><span class="line">            pv.addPropertyValue(<span class="string">"remark"</span>, <span class="string">"把备注信息修改一下"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改 scope</span></span><br><span class="line">        bd.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 <em>PostProcessor</em> 中，我们将 <em>foobar</em>  这个 Bean 的属性值修改了，同时还修改了它的 <em>scope</em> 信息。</p>
<p>然后在我们的 XML 配置中把这个 Processor 注册进去即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBeanFactoryPostProcessor"</span> <span class="attr">class</span>=<span class="string">"comcom.doleje.demo.spring.processor.MyBeanFactoryPostProcessor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们常见的 <em>BeanFactoryPostProcessor</em> 的关系如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20140628222350234" alt="img"></p>
<h2 id="6-Lifecycle-接口"><a href="#6-Lifecycle-接口" class="headerlink" title="6. Lifecycle 接口"></a>6. Lifecycle 接口</h2><p>严格来说，这部分内容并不属于 Spring Bean 的生命周期讨论的范围，这是一个更高阶更基础的接口，用来定义一些更抽象的生命周期及状态的。</p>
<p><code>Lifecycle</code>接口中为任何有自己生命周期需求的对象定义了基本的方法（比如启动和停止一些后台进程）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何Spring管理的对象都可实现上面的接口。那么当<code>ApplicationContext</code>本身受到了启动或者停止的信号时，<code>ApplicationContext</code>会通过委托<code>LifecycleProcessor</code>来串联上下文中的<code>Lifecycle</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码我们可以发现<code>LifecycleProcessor</code>是<code>Lifecycle</code>接口的扩展。<code>LifecycleProcessor</code>增加了另外的两个方法来针对上下文的刷新和关闭做出反应。</p>
<blockquote>
<p>常规的<code>org.springframework.context.Lifecycle</code>接口只是为明确的开始/停止通知提供一个契约，而并不表示在上下文刷新时自动开始。考虑实现<code>org.springframework.context.SmartLifecycle</code>接口可以取代在某个Bean的自动启动过程（包括启动阶段）中的细粒度控制。同时，停止通知并不能保证在销毁之前出现：在正常的关闭情况下，所有的<code>Lifecycle</code>Bean都会在销毁回调准备好之前收到停止停止，然而，在上下文存活期的热刷新或者停止刷新尝试的时候，只会调用销毁方法。</p>
</blockquote>
<p>启动和关闭调用是很重要的。如果不同的Bean之间存在<code>depends-on</code>的关系的话，被依赖的一方需要更早的启动，而且关闭的更早。然而，有的时候直接的依赖是未知的，而开发者仅仅知道哪一种类型需要更早进行初始化。在这种情况下，<code>SmartLifecycle</code>接口定义了另一种选项，就是其父接口<code>Phased</code>中的<code>getPhase()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当启动时，拥有最低的<code>phased</code>的对象优先启动，而当关闭时，是相反的顺序。因此，如果一个对象实现了<code>SmartLifecycle</code>然后令其<code>getPhase()</code>方法返回了<code>Integer.MIN_VALUE</code>的话，就会让该对象最早启动，而最晚销毁。显然，如果<code>getPhase()</code>方法返回了<code>Integer.MAX_VALUE</code>就说明了该对象会最晚启动，而最早销毁。当考虑到使用<code>phased</code>的值得时候，也同时需要了解正常没有实现<code>SmartLifecycle</code>的<code>Lifecycle</code>对象的默认值，这个值为0。因此，任何负值将标兵对象会在标准组件启动之前启动，在标准组件销毁以后再进行销毁。</p>
<p><code>SmartLifecycle</code>接口也定义了一个<code>stop</code>的回调函数。任何实现了<code>SmartLifecycle</code>接口的函数都必须在关闭流程完成之后调用回调中的<code>run()</code>方法。这样做可以是能异步关闭。而<code>LifecycleProcessor</code>的默认实现<code>DefaultLifecycleProcessor</code>会等到配置的超时时间之后再调用回调。默认的每一阶段的超时时间为30秒。开发者可以通过定义一个叫做<code>lifecycleProcessor</code>的Bean来覆盖默认的生命周期处理器。如果开发者需要配置超时时间，可以通过如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleProcessor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.DefaultLifecycleProcessor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutPerShutdownPhase"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和前文提到的，<code>LifecycleProcessor</code>接口定义了回调方法来刷新和关闭上下文。关闭的话，如果<code>stop()</code>方法已经明确调用了，那么就会驱动关闭的流程，但是如果是上下文关闭就不会发生这种情况。而刷新的回调会使能<code>SmartLifecycle</code>的另一个特性。当上下文刷新完毕（所有的对象已经实例化并初始化），那么就会调用回调，默认的生命周期处理器会检查每一个<code>SmartLifecycle</code>对象的<code>isAutoStartup()</code>返回的Bool值。如果为真，对象将会自动启动而不是等待明确的上下文调用，或者调用自己的<code>start()</code>方法(不同于上下文刷新，标准的上下文实现是不会自动启动的)。<code>phased</code>的值以及<code>depends-on</code>关系会决定对象启动和销毁的顺序。<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
op1=>operation: 收集并实例化 BeanFactoryPostProcessor
op2=>operation: 执行 BeanFactoryPostProcessor.postProcessBeanFactory 方法
op3=>operation: 收集并实例化 BeanPostProcessor
op4=>operation: 执行 BeanPostProcessor.postProcessBeforeInitialization 方法
op5=>operation: 构造 Bean 实例
op6=>operation: 执行 InitializingBean.afterPropertiesSet 方法
op7=>operation: 执行 <bean init-method> 方法
op8=>operation: 执行 BeanPostProcessor.postProcessAfterInitialization 方法
op9=>operation: 执行 DiposibleBean.destroy 方法
op10=>operation: 执行 <bean destroy-method> 方法
e=>end

st->op1->op2->op3->op4->op5->op6->op7->op8->op9->op10->e</bean></bean></textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MultipartResolver与ExceptionResolver</title>
    <url>/2008/03/29/multipartresolver-yu-exceptionresolver/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h4><p>在 Spring 中， <code>MultipartResolver</code> 主要用来处理文件上传，它支持 <a href="http://jakarta.apache.org/commons/fileupload" target="_blank" rel="noopener">Commons FileUpload</a> 和 <a href="http://www.servlets.com/cos" target="_blank" rel="noopener">COS FileUpload</a>。<br>缺省，Spring是没有multipart处理，因为一些开发者想要自己处理它们。如果你想使用Spring的multipart，需要在web应用的上下文中添加multipart解析器。这样，每个请求就会被检查是否包含multipart。然而，如果请求中包含multipart，你的上下文中定义的<code>MultipartResolver</code>就会解析它。这样，你请求中的multipart属性就会象其它属性一样被处理。 </p>
<a id="more"></a>
<p>主要配置如下： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span>     <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该属性用来配置可上传文件的最大 byte 数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maximumFileSize"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>100000<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该 Bean 还有其它的属性如 defaultEncoding, maxInMemorySize, servletContext, uploadTempDir 一般默认就可以了。<br>其它的配置和普通的没有什么区别，当然在上传的表单中必须指定其 enctype 为 mulitpart/form-data ，如： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"upload.html"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"paper"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：项目中必须有 commons-io.jar , commons-fileupload.jar 包的支持。</p>
</blockquote>
<h4 id="ExceptionResolver"><a href="#ExceptionResolver" class="headerlink" title="ExceptionResolver"></a>ExceptionResolver</h4><p>在 Spring 中，框架自动集成了异常处理，其主要核心是由 <code>ExceptionResolver</code> Bean 来处理的，在框架启动时，会检测这个 Bean ，如果不存在则不会处理系统中的异常，如果有，则会按照相关上配置来处理自动异常。<br>如有如下配置： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exceptionResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.sql.SQLException"</span>&gt;</span>showDBError<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.RuntimeException"</span>&gt;</span>showError<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"org.springframework.web.multipart.MaxUploadSizeExceededException"</span>&gt;</span>maxUploadExceeded<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则会在系统运行过程中监测异常，如果出现 SQLException ，会调用相关的 showDBError 页面来显示异常，类似的出现 RuntimeException , MaxUploadSizeExceededException 也是一样。<br>该 Bean 的主要属性为 exceptionMappings 用来映射异常对应的处理页面，以 props 的形式出现。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 对 JSON-P 的支持</title>
    <url>/2016/05/29/springmvc-dui-jsonp-de-zhi-chi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>如果你既开发后端也开发前端，那么您就知道浏览器在处理AJAX请求时所具有<strong>的同源策略约束</strong>，也就是我们常说的跨域问题。什么叫同源呢，<strong>如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的源</strong>。否则，都是跨域。</p>
<p>当然，解决这种问题的方法有很多，其中一种（也是较常见的）方法是使用<a href="https://zh.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">JSON-P</a>，本文讨论Spring 对使用JSON-P数据格式的支持。<br><a id="more"></a></p>
<h2 id="2-JSON-P-in-Action"><a href="#2-JSON-P-in-Action" class="headerlink" title="2. JSON-P in Action"></a>2. JSON-P in Action</h2><p>很重要的一点是：<strong>浏览器不会对 <code>&lt;script&gt;</code> 标签施加同源策略</strong>，允许跨不同域加载脚本，即我们可以在 <code>&lt;script&gt;</code> 中加载不同源的资源的。JSON-P 技术实际上是利用这一点通过将JSON响应作为 javascript 函数的参数传递。</p>
<h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><p>在我们的示例中，我们使用一个简单的 <em>Company</em> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// standard setters and getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并通过一个 <em>Controller</em> 的方法 返回<em>Company</em>实例的 JSON 数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanyController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/companyRest"</span>,</span><br><span class="line">      produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">getCompanyRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Company company = <span class="keyword">new</span> Company(<span class="number">1</span>, <span class="string">"Xpto"</span>);</span><br><span class="line">        <span class="keyword">return</span> company;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端，我们使用 <em>jQuery</em> 库来创建和发送AJAX请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://localhost:8080/spring-mvc-java/companyRest'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        format: <span class="string">'json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们页面是通过如下的 URL 来展示并进行AJAX请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/spring-mvc-java/companyRest</span><br></pre></td></tr></table></figure>
<p>服务器的响应如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"Xpto"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>由于请求是同源的（相同的协议、域和端口），因此响应不会被阻止，浏览器将允许JSON数据。</p>
<h3 id="2-2-跨源请求"><a href="#2-2-跨源请求" class="headerlink" title="2.2 跨源请求"></a>2.2 跨源请求</h3><p>换种方式，如果我们通过如下的 URL 来访问页面呢：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8080/spring-mvc-java/companyRest</span><br></pre></td></tr></table></figure>
<p>注意，我们的页面域名为 <em>127.0.0.1</em> ，而在 js 代码中，AJAX 请求是请求的目标是 <em>localhost</em> 域，违反了同源策略。因此响应将被浏览器阻止，不会正常的返回想要的数据。</p>
<p>这个时候就需要使用JSON-P技术了，我们可以向请求添加回调参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.1.1.1:8080/spring-mvc-java/companyRest?callback=getCompanyData</span><br></pre></td></tr></table></figure>
<p>在 JS 中进行 AJAX 时请求添加以下参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">    jsonpCallback:<span class="string">'getCompanyData'</span>,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>getCompanyData</em> 是指接收到响应时会调用的函数，同时服务端的响应也进行相应的包装，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getCompanyData(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Xpto&quot;&#125;);</span><br></pre></td></tr></table></figure>
<p>根据 JSONP 协议，这个时候浏览器不会阻止它，因为它会将响应视为在客户端和服务器之间协商并达成一致的脚本，因为请求和响应中都匹配 <em>getCompanyData</em>，这样就能解决跨域的问题。</p>
<h2 id="3-使用-AbstractJsonpResponseBodyAdvice-更改响应"><a href="#3-使用-AbstractJsonpResponseBodyAdvice-更改响应" class="headerlink" title="3. 使用 AbstractJsonpResponseBodyAdvice 更改响应"></a>3. 使用 <em>AbstractJsonpResponseBodyAdvice</em> 更改响应</h2><p><strong>从Spring 4.1开始</strong>，我们现在可以访问通过自定义一个 <em>AbstractJsonpResponseBodyAdvice</em> 的实现，来完成根据JSON-P标准的格式化响应。</p>
<p>其实非常的简单，我们自定义一个 <em>AbstractJsonpResponseBodyAdvice</em> 的实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonpControllerAdvice</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AbstractJsonpResponseBodyAdvice</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonpControllerAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"callback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是传递给父类一个类似 <strong>密钥</strong> 的东西 <em>callback</em>，这个是在 JSON-P 返回时定义的回调方法，注意，这个需要和请求中的 <em>jsonpCallback</em> 参数名保持一致才能实现 JSON-P 的协议。</p>
<h2 id="5-验证"><a href="#5-验证" class="headerlink" title="5. 验证"></a>5. 验证</h2><p>通过前面讨论的配置，我们可以使我们的REST应用程序响应JSON-P。在下面的示例中，我们将返回公司的数据，因此我们的AJAX请求URL应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8080/spring-mvc-java/companyRest?callback=getCompanyData</span><br></pre></td></tr></table></figure>
<p>进行之前的 JSON-P 配置扣，响应将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`getCompanyData(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Xpto&quot;&#125;);`</span><br></pre></td></tr></table></figure>
<p>如上所述，尽管源自不同的域，但此格式的响应不会被阻止。<em>JsonpControllerAdvice</em> 会被应用到所有 <em>@ResponseBody</em>和<em>ResponseEntity</em> 注解的方法上。</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
        <tag>JSON-P</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中多ViewResolver实践</title>
    <url>/2015/12/11/spring-zhong-duo-viewresolver-shi-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在Spring中，提供View Resolver以使用模型中可用的数据来解析视图，而无需紧密绑定到View技术，无论是JSP，Velocity，JSON 还是 Thymeleaf ，Spring都可以根据需要轻松灵活地配置<strong>一个或多个View Resolvers</strong>。</p>
<h2 id="2-Spring-MVC-请求处理流程"><a href="#2-Spring-MVC-请求处理流程" class="headerlink" title="2. Spring MVC 请求处理流程"></a>2. Spring MVC 请求处理流程</h2><p>在我们继续了解<strong>多个View Resolvers</strong>如何<strong>实现</strong>之前，我们看看 SpringMVC 是如何处理请求的流程：</p>
<ol>
<li>传入请求来自<strong>web.xml</strong>，<strong>DispatcherServlet</strong> 并最终到达 <strong>Controller</strong>。</li>
<li>Controller与应用程序层交互并准备<strong>Model</strong>。</li>
<li>Controller返回<strong>ModelAndView</strong>，包含模型和视图名称。</li>
<li><strong>ViewResolver</strong>提供视图名称和实际视图之间的映射。</li>
<li><strong>View</strong>接口决定了展示<strong>View</strong>的技术。</li>
<li>然后将视图与模型数据一起呈现到浏览器上。</li>
</ol>
<a id="more"></a>
<h2 id="3-实施"><a href="#3-实施" class="headerlink" title="3.实施"></a>3.实施</h2><p>让我们从pom依赖开始：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring 3 dependencies --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- Jackson JSON Mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-mapper-asl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- JSTL Dependency --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jstl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>web.xml中没有太大的变化。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>MultipleViewResolversExample<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/API/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是 <em>mvc-dispatcher-servlet</em>，它<strong>定义了多个View Resolvers</strong>。</p>
<p><strong>mvc-dispatcher-servlet.xml</strong>内容如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jcombat.controller"</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- Bean View Resolver --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- JSP View Resolver --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/WEB-INF/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>.jsp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"jsonView"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.json.MappingJacksonJsonView"</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，配置的两个View Resolvers是<strong>InternalResourceViewResolver</strong>和  <strong>BeanNameViewResolver</strong>。我们还使用View Resolver 的<strong>order</strong>属性设置了优先级。因此  <strong>BeanNameViewResolver</strong> 具有更高的优先级。这意味着当返回<strong>ModelAndView</strong>对象时，  <strong>BeanNameViewResolver</strong>将使用返回的视图名称检查可用的bean视图。如果找到匹配的bean视图，则呈现它。如果没有，则下一个View Resolver即  <strong>InternalResourceViewResolver</strong>尝试解析，同样检查具有<strong>ModelAndView</strong>返回的视图名称的JSP 。如果找到，则呈现视图。但如果没有，并且层次结构中没有更多View Resolvers，则抛出适当的异常。</p>
<p>继续实现，我们先定义一个 <em>Employee</em> 实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String empId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmpId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> empId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpId</span><span class="params">(String empId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.empId = empId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是 <em>EmployeeController</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/Employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;name&#125;/&#123;empId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @PathVariable(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">            @<span class="title">PathVariable</span><span class="params">(<span class="string">"empId"</span>)</span> String empId) </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setEmpId(empId);</span><br><span class="line">        employee.setName(name);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"employeeDetails"</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">"employee"</span>, employee);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写一个JSP（<em>employeeDetails.jsp</em>）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span></span><br><span class="line">   <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=ISO-8859-1"</span>&gt;</span><br><span class="line">        &lt;title&gt;Via JSP View Resolver&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;!-- Retrieve the model data through JSTL --&gt;</span><br><span class="line">        &lt;p&gt;$&#123;employee.empId&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;$&#123;employee.name&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-运行验证"><a href="#4-运行验证" class="headerlink" title="4. 运行验证"></a>4. 运行验证</h2><p>当我们运行应用程序时，我们看到如下的界面：</p>
<p><img src="/images/pasted-113.png" alt="upload successful"></p>
<p>请注意，我们没有任何名为<strong>employeeDetails的</strong> bean，而是与实际的JSP视图文件<strong>employeeDetails.jsp</strong>匹配。因此，视图将作为JSP解析。</p>
<p>现在让我们将视图名称设置为 <em>jsonView</em> 返回（我们之前的 XML 配置中有一个 <em>jsonView</em> 的<br>Bean），修改 Controller 中的视图名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">modelAndView.setViewName(<span class="string">"jsonView"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>BeanNameViewResolver</strong> 优先级更高，所以这次查找到名为 <em>jsonView</em> 的Bean视图并完成解析，而不是呈现JSP视图，相同的URI现在返回一个<em>JSON</em>。</p>
<p><img src="/images/pasted-114.png" alt="upload successful"></p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注入之@Resource、@Autowired以及@Inject的区别</title>
    <url>/2016/01/11/spring-zhu-ru-zhi-resource-autowired-yi-ji-inject-de-qu-bie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>这篇文章将演示与依赖注入相关的注解的使用，即<em>@Resource</em>，<em>@Inject</em>和<em>@Autowired</em>注解。这些注解为类提供了解析依赖关系的声明方式，也是 Spring 最重要的特性之一。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ArbitraryClass arbObject;</span><br></pre></td></tr></table></figure>
<p>而不是直接实例化（必要的方式），例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArbitraryClass arbObject = <span class="keyword">new</span> ArbitraryClass();</span><br></pre></td></tr></table></figure>
<p>三个注解中的两个属于Java扩展包：<em>javax.annotation.Resource</em>和<em>javax.inject.Inject</em>，它们隶属于 J2EE 规范，<em>@Autowired</em> 注解属于<em>org.springframework.beans.factory.annotation</em> 包。</p>
<p>这些注解中的每一个都可以通过 <em>Field 注入</em> 或通过 <em> </em>Setter<em> 注入</em> 来解决依赖。我们将使用一个简化但实用的示例来演示三个注解之间的区别，这些示例将重点介绍如何在测试用例期间使用三个注入注解测试所需的依赖关系。</p>
<a id="more"></a>
<h2 id="2-Resource-注解"><a href="#2-Resource-注解" class="headerlink" title="2. @Resource 注解"></a>2. <em>@Resource</em> 注解</h2><p><em>@Resource</em>注解是 J2EE 规范的一部分，来自<a href="https://jcp.org/en/jsr/detail?id=250" target="_blank" rel="noopener">JSR-250</a>，该注解在选择候选 Bean 的时候，优先级顺序如下：</p>
<ol>
<li><em>byName</em></li>
<li><em>byType</em></li>
<li><em>@Qualifier</em> </li>
</ol>
<h3 id="2-1-Field-注入"><a href="#2-1-Field-注入" class="headerlink" title="2.1 Field 注入"></a>2.1 Field 注入</h3><p>通过使用<em>@Resource</em> 注解对实例变量进行注解来实现通过字段注入来解决依赖关系。</p>
<h3 id="2-1-1-byName-匹配"><a href="#2-1-1-byName-匹配" class="headerlink" title="2.1.1 byName 匹配"></a>2.1.1 <em>byName</em> 匹配</h3><p>用于演示按名称匹配字段注入的测试用例出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(</span></span><br><span class="line"><span class="class">  <span class="title">loader</span></span>=AnnotationConfigContextLoader<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">  <span class="title">classes</span></span>=ApplicationContextTestResourceNameType<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FieldResourceInjectionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"foobar"</span>)</span><br><span class="line">    <span class="keyword">private</span> Foobar foobar;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenResourceAnnotation_WhenOnField_ThenDependencyValid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(defaultFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看代码吧。在<em>FieldResourceInjectionTest</em> 测试中，在第7行，通过将 bean 名称作为属性值传递给<em>@Resource</em> 注解来实现依赖名称的解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"foobar"</span>)</span><br><span class="line"><span class="keyword">private</span> Foobar foobar;</span><br></pre></td></tr></table></figure>
<p>此配置将使用按名称匹配的执行路径解决依赖关系。必须在<em>ApplicationContext</em> 中定义 <em>名为 foobar</em> 的bean 。</p>
<p><strong>请注意，bean id 和相应的引用属性值必须匹配</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTestResourceNameType</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"foobar"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foobar <span class="title">foobar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Foobar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 <em>ApplicationContext</em> 中没有这个名字的 bean，将抛出<em>org.springframework.beans.factory.NoSuchBeanDefinitionException</em>，这个可以通过在用例中更改<em>@Resource</em>注解的 <em>name</em> 属性值来测试一下。</p>
<h4 id="2-1-2-byType"><a href="#2-1-2-byType" class="headerlink" title="2.1.2 byType"></a>2.1.2 <em>byType</em></h4><p>要演示按类型匹配，只需删除<em>FieldResourceInjectionTest</em>测试第7行的 <em>name</em> 属性值，使其如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> File defaultFile;</span><br></pre></td></tr></table></figure>
<p>并再次运行测试，测试仍然会通过，因为如果 <em>@Resource</em> 注解没有收到bean名称作为属性值，则Spring 将继续使用下一级优先级（按类型匹配），以尝试解析依赖项。</p>
<h4 id="2-1-3-Qualifier"><a href="#2-1-3-Qualifier" class="headerlink" title="2.1.3 @Qualifier"></a>2.1.3 <em>@Qualifier</em></h4><p>为了演示按 <em>@Qualifier</em> 匹配的选择过程，修改测试用例场景，以便在<em>ApplicationContextTestResourceQualifier</em>  中定义两个bean ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextTestResourceQualifier</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"defaultFile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">defaultFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File defaultFile = <span class="keyword">new</span> File(<span class="string">"defaultFile.txt"</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultFile;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"namedFile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">namedFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File namedFile = <span class="keyword">new</span> File(<span class="string">"namedFile.txt"</span>);</span><br><span class="line">        <span class="keyword">return</span> namedFile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(</span></span><br><span class="line"><span class="class">  <span class="title">loader</span></span>=AnnotationConfigContextLoader<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">  <span class="title">classes</span></span>=ApplicationContextTestResourceQualifier<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">QualifierResourceInjectionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> File dependency1;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> File dependency2;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenResourceAnnotation_WhenField_ThenDependency1Valid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(dependency1);</span><br><span class="line">        assertEquals(<span class="string">"defaultFile.txt"</span>, dependency1.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenResourceQualifier_WhenField_ThenDependency2Valid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(dependency2);</span><br><span class="line">        assertEquals(<span class="string">"namedFile.txt"</span>, dependency2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试用例，抛出<em>org.springframework.beans.factory.NoUniqueBeanDefinitionException</em>。抛出此异常是因为 <em>ApplicationContext</em> 找到了两个类型为<em>File</em> bean定义，并且对哪个bean应该解析依赖关系感到困惑。</p>
<p>要解决此问题，需要在依赖注入的字段上添加 <em>@Qualifier</em> 注解，来指定空间究竟想使用哪个依赖项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"defaultFile"</span>)</span><br><span class="line"><span class="keyword">private</span> File dependency1;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"namedFile"</span>)</span><br><span class="line"><span class="keyword">private</span> File dependency2;</span><br></pre></td></tr></table></figure>
<p>再次运行测试用例，这次它应该通过。此测试的目的是证明即使在 <em>ApplicationContext</em> 中定义了多个bean，也可以通过 <em>@Qualifier</em>  来告诉 Spring 该用哪一个。</p>
<h3 id="2-2-Setter-注入"><a href="#2-2-Setter-注入" class="headerlink" title="2.2 Setter  注入"></a>2.2 <em>Setter</em>  注入</h3><p>除了在字段上进行注解注入外，Spring 还支持在 <em>Setter</em> 上进行依赖注入。</p>
<h4 id="2-2-1-byName"><a href="#2-2-1-byName" class="headerlink" title="2.2.1 byName"></a>2.2.1 <em>byName</em></h4><p>唯一的区别是<em>MethodResourceInjectionTest</em>测试用例有一个 <em>Setter</em> 方法，我们在  <em>Setter</em>  方法上做注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(</span></span><br><span class="line"><span class="class">  <span class="title">loader</span></span>=AnnotationConfigContextLoader<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">  <span class="title">classes</span></span>=ApplicationContextTestResourceNameType<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MethodResourceInjectionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> File defaultFile;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"namedFile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDefaultFile</span><span class="params">(File defaultFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultFile = defaultFile;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> givenResourceAnnotation_When *Setter* _ThenDependencyValid()&#123;</span><br><span class="line">        assertNotNull(defaultFile);</span><br><span class="line">        assertEquals(<span class="string">"namedFile.txt"</span>, defaultFile.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <em>Setter</em> 注入来解决依赖关系是通过注解引用变量的相应 <em>Setter</em> 方法来完成的。</p>
<h4 id="2-2-2-byType"><a href="#2-2-2-byType" class="headerlink" title="2.2.2 byType"></a>2.2.2 <em>byType</em></h4><p>同样的，只是将 <em>@Resource</em> 注解从 <em>Field</em> 移到对应的  <em>Setter</em>  方法上（并去掉 <em>name</em> 属性）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(</span></span><br><span class="line"><span class="class">  <span class="title">loader</span></span>=AnnotationConfigContextLoader<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">  <span class="title">classes</span></span>=ApplicationContextTestResourceNameType<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MethodByTypeResourceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> File defaultFile;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDefaultFile</span><span class="params">(File defaultFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultFile = defaultFile;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> givenResourceAnnotation_When *Setter* _ThenValidDependency()&#123;</span><br><span class="line">        assertNotNull(defaultFile);</span><br><span class="line">        assertEquals(<span class="string">"namedFile.txt"</span>, defaultFile.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-Qualifier"><a href="#2-2-3-Qualifier" class="headerlink" title="2.2.3 @Qualifier"></a>2.2.3 <em>@Qualifier</em></h4><p>该<em>MethodByQualifierResourceTest</em>测试用例将被用来演示 <em>Qualifier</em> 的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(</span></span><br><span class="line"><span class="class">  <span class="title">loader</span></span>=AnnotationConfigContextLoader<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">  <span class="title">classes</span></span>=ApplicationContextTestResourceQualifier<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MethodByQualifierResourceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> File arbDependency;</span><br><span class="line">    <span class="keyword">private</span> File anotherArbDependency;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> givenResourceQualifier_When *Setter* _ThenValidDependencies()&#123;</span><br><span class="line">      assertNotNull(arbDependency);</span><br><span class="line">        assertEquals(<span class="string">"namedFile.txt"</span>, arbDependency.getName());</span><br><span class="line">        assertNotNull(anotherArbDependency);</span><br><span class="line">        assertEquals(<span class="string">"defaultFile.txt"</span>, anotherArbDependency.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"namedFile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArbDependency</span><span class="params">(File arbDependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arbDependency = arbDependency;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"defaultFile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnotherArbDependency</span><span class="params">(File anotherArbDependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.anotherArbDependency = anotherArbDependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Inject-注解"><a href="#3-Inject-注解" class="headerlink" title="3. @Inject 注解"></a>3. <em>@Inject</em> 注解</h2><p>该<em>@Inject</em>注解属于<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="noopener">JSR-330</a>规范，它挑选候选者的优先级如下：</p>
<ol>
<li><em>byType</em></li>
<li><em>@Qualifier</em></li>
<li><em>byName</em></li>
</ol>
<p>要启用 <em>@Inject</em> 注解，需要添加相应的Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个注解使用率相对较低，这里不再详细的介绍每个场景下的单元测试用例，基本上和前面的使用方式一样，除了将 <em>@Resource</em> 修改为 <em>@Inject</em> 即可。</p>
<h3 id="3-1-3-byName"><a href="#3-1-3-byName" class="headerlink" title="3.1.3 byName"></a>3.1.3 <em>byName</em></h3><p>这里单独把 <em>byName</em> 的场景拿出来是因为跟 <em>@Resource</em> 相比，它有一些不一样的地方，它并不是在 <em>@Inject</em> 中添加 <em>name</em> 属性来完成，而是需要另外一个注解（<em>@Named</em>）配合，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(</span></span><br><span class="line"><span class="class">  <span class="title">loader</span></span>=AnnotationConfigContextLoader<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">  <span class="title">classes</span></span>=ApplicationContextTestResourceNameType<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MethodResourceInjectionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> File defaultFile;</span><br><span class="line"> </span><br><span class="line"> 		<span class="comment">// 注意这里采用的是 *@Named* 注解而非 *@Inject* 的属性</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named</span>(<span class="string">"namedFile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDefaultFile</span><span class="params">(File defaultFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultFile = defaultFile;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> givenResourceAnnotation_When *Setter* _ThenDependencyValid()&#123;</span><br><span class="line">        assertNotNull(defaultFile);</span><br><span class="line">        assertEquals(<span class="string">"namedFile.txt"</span>, defaultFile.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Autowired-注解"><a href="#4-Autowired-注解" class="headerlink" title="4. @Autowired 注解"></a>4. <em>@Autowired</em> 注解</h2><p><em>@Autowired</em>注解的行为类似于<em>@Inject</em>注解。唯一的区别是<em>@Autowired</em>注解是Spring框架的一部分。此注解具有与<em>@Inject</em>注解相同候选者选择优先顺序：</p>
<ol>
<li><em>byType</em></li>
<li><em>@Qualifier</em></li>
<li><em>byName</em></li>
</ol>
<p>同样都适用于 <em>Setter</em>  和 <em>Field</em> 注入。<br><em>@Autowired</em>  对于候选者的选择优先级是和 <em>@Inject</em> 一致的，但是其使用方式又和 <em>@Resoure</em> 是一样的，大家都应该很熟悉了，这里也不再详细的列举测试用例。</p>
<h2 id="5-如何选择？"><a href="#5-如何选择？" class="headerlink" title="5. 如何选择？"></a>5. 如何选择？</h2><p>既然我们知道了有三种不同的注解都可以完成依赖注入，那么，在哪些场景应该使用哪种注解呢？这些问题的答案取决于相关应用程序所面临的设计方案，以及开发人员希望如何根据每个注解的默认执行路径。</p>
<h3 id="5-1-基于接口或抽象类的场景"><a href="#5-1-基于接口或抽象类的场景" class="headerlink" title="5.1 基于接口或抽象类的场景"></a>5.1 基于接口或抽象类的场景</h3><p>如果设计的组件是基于接口或抽象类的实现，并且这些行为在整个应用程序中使用，则优先使用<em>@Inject</em> 或<em>@Autowired</em> 注解。因为这两个注解对于候选者的选择优先级中：默认是 <em>byType</em> 的。</p>
<h3 id="5-2-拥有多个接口或抽象类实现的场景"><a href="#5-2-拥有多个接口或抽象类实现的场景" class="headerlink" title="5.2 拥有多个接口或抽象类实现的场景"></a>5.2 拥有多个接口或抽象类实现的场景</h3><p>如果设计是应用程序具有复杂行为，则每个行为都基于不同的接口/抽象类，且实现类都不止一种，那么应该优先使用<em>@Resource</em>注解。在此方案中，注解对于候选者的选择优先级中：默认是 <em>byName</em> 的。</p>
<h3 id="5-3-基于-Java-EE-平台的场景"><a href="#5-3-基于-Java-EE-平台的场景" class="headerlink" title="5.3 基于 Java EE 平台的场景"></a>5.3 基于 Java EE 平台的场景</h3><p>如果Java EE平台而不是Spring注入所有依赖项的时候，那么选择在<em>@Resource</em>注解和<em>@Inject</em>注解之间，同时应该根据前述的两种不同的场景来决策到底使用哪一种。</p>
<h3 id="5-4-基于-Spring-的场景"><a href="#5-4-基于-Spring-的场景" class="headerlink" title="5.4 基于 Spring 的场景"></a>5.4 基于 Spring 的场景</h3><p>这里是说完全基于 Spring 场景，而没有 J2EE 的耦合，则唯一的选择是 <em>@Autowired</em> 注解。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>根据前面的讲解，我们总结一下这三个注解对于候选者选择优先级顺序，以及其适用的场景。</p>
<h3 id="6-1-候选者选择优先级"><a href="#6-1-候选者选择优先级" class="headerlink" title="6.1 候选者选择优先级"></a>6.1 候选者选择优先级</h3><table>
<thead>
<tr>
<th>注解</th>
<th>第一顺位</th>
<th>第二顺位</th>
<th>第三顺位</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>@Resource</em></td>
<td><em>byName</em></td>
<td><em>byType</em></td>
<td><em>@Qualifier</em></td>
</tr>
<tr>
<td><em>@Inject</em></td>
<td><em>byType</em></td>
<td><em>@Qualifier</em></td>
<td><em>byName</em></td>
</tr>
<tr>
<td><em>@Autowired</em></td>
<td><em>byType</em></td>
<td><em>@Qualifier</em></td>
<td><em>byName</em></td>
</tr>
</tbody>
</table>
<h3 id="6-2-注解选择"><a href="#6-2-注解选择" class="headerlink" title="6.2 注解选择"></a>6.2 注解选择</h3><p>根据前面的讨论得出的注解选择方式如下表所示：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th><em>@Resource</em></th>
<th><em>@Inject</em></th>
<th><em>@Autowired</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>基于接口或抽象类</td>
<td>✗</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>接口或抽象类多实现</td>
<td>✔</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>基于 J2EE 平台</td>
<td>✔</td>
<td>✔</td>
<td>✗</td>
</tr>
<tr>
<td>基于 Spring 平台</td>
<td>✗</td>
<td>✗</td>
<td>✔</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解读——AOP</title>
    <url>/2012/02/25/spring-yuan-ma-fen-xi-aop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h3><h4 id="AOP基本概念"><a href="#AOP基本概念" class="headerlink" title="AOP基本概念"></a>AOP基本概念</h4><p><strong>Aspect-Oriented Programming</strong> 面向切面编程的简称，Aspect是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点(crosscutting concern)，从关注点中分离出横切关注点是面向方面程序设计的核心所在。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过方面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好地管理起来。</p>
<h4 id="AOP和OOP的区别"><a href="#AOP和OOP的区别" class="headerlink" title="AOP和OOP的区别"></a>AOP和OOP的区别</h4><p>面向方面编程AOP和面向对象编程OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。</p>
<p>OOP针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。</p>
<p>而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p>
<h4 id="AOP常用的技术以及实现"><a href="#AOP常用的技术以及实现" class="headerlink" title="AOP常用的技术以及实现"></a>AOP常用的技术以及实现</h4><p>常用的AOP技术有：</p>
<ul>
<li>AspectJ：源代码和字节码级别的方面编织器，用户需要使用不同于Java的新语言。</li>
<li>AspectWerkz：AOP框架，使用字节码动态编织器和XML配置。</li>
<li>JBoss-AOP：基于拦截器和元数据的AOP框架，运行在JBoss应用服务器上。</li>
</ul>
<p>AOP中使用的一些实现技术有：</p>
<ul>
<li>BCEL：Byte-Code Engineering Library，Java字节码操作类库。</li>
<li>CGLIB：CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为<a href="https://www.baidu.com/s?wd=JDK&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">JDK</a>的动态代理提供了很好的补充。</li>
<li>Javassist：Java字节码操作类库，JBoss的一个子项目。</li>
</ul>
<h4 id="面向方面编程-AOP-的常用术语"><a href="#面向方面编程-AOP-的常用术语" class="headerlink" title="面向方面编程(AOP)的常用术语"></a>面向方面编程(AOP)的常用术语</h4><ul>
<li>切面Aspect： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些切入点Pointcut 以及对切入点进行相应的操作的通知Advice。</li>
<li>连接点Joint point：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它连接点jointpoint。</li>
<li>切入点Pointcut：表示一组连接点jointpoint，这些连接点或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的操作处理通知Advice将要发生的地方。</li>
<li>通知Advice：Advice 定义了在切入点pointcut 里面定义的程序点具体要做的操作和处理，它通过 before、after 和 around 来区别是在每个切入点之前、之后还是代替执行的代码。</li>
<li>目标对象Target：代理的目标对象，即切面要被应用到的目标对象。</li>
<li>织入Weave：指将切面应用到目标对象，并导致代理对象创建的过程。</li>
</ul>
<h3 id="二、Advice通知"><a href="#二、Advice通知" class="headerlink" title="二、Advice通知"></a>二、Advice通知</h3><p>Advice通知是AOP联盟定义的一个接口，定义当拦截到连接点做相应的处理操作，为切面增强提供织入接口。在spring AOP中，通知主要描述Spring AOP围绕方法调用而注入切面的行为，Spring AOP的通知扩展了AOP联盟的通知接口，提供了前置通知 <code>BeforeAdvice</code>、后置通知 <code>AfterReturningAdvice</code> 、最终通知 <code>AfterAdvice</code> 和例外通知 <code>ThrowsAdvice</code>等。</p>
<p>AOP联盟定义的接口都只是类似一个标记，的接口方法还是要视具体的连接点的情况而定，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeforeAdvice</span> <span class="keyword">extends</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterAdvice</span> <span class="keyword">extends</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThrowsAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，都只有接口，而没有具体方法的定义，而真正要实现的方法都在具体的连接器指定后才有，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置增强接口，使用这个前置接口需要实现一个回调函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作为回调函数，该方法的实现在Advice中被配置到目标方法后，会调用目标方法时被回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method Method对象，是目标方法的反射对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 对象数组，包含目标方法的输入参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作为回调函数，该方法的实现在Advice中被配置到目标方法返回后，对目标返回结果进行增强</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnValue 返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method Method对象，是目标方法的反射对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 对象数组，包含目标方法的输入参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、Pointcut切点"><a href="#三、Pointcut切点" class="headerlink" title="三、Pointcut切点"></a>三、Pointcut切点</h3><p>Pointcut切入点决定通知Advice应该作用于哪个连接点，即通过Pointcut切入点来定义目标对象中需要使用AOP增强的方法集合，这些集合的选取可以按照一定的规则来完成。</p>
<p>Pointcut通常意味着标识方法，这些需要增强的方法可以被某个正则表达式进行标识，或者根据指定方法名进行匹配等。下面是Pointcut设计：</p>
<p><img src="/images/pasted-6.png" alt="Pointcut"></p>
<h4 id="Pointcut切入点源码"><a href="#Pointcut切入点源码" class="headerlink" title="Pointcut切入点源码"></a>Pointcut切入点源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//获取类过滤器  </span></span><br><span class="line">    <span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取匹配切入点的方法      </span></span><br><span class="line">    <span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//总匹配的标准切入点实例  </span></span><br><span class="line">    Pointcut TRUE = TruePointcut.INSTANCE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Pointcut的基本接口定义中可以看到，需要返回一个MethodMatcher。对于Point的匹配判断功能，具体是由这个返回的MethodMatcher来完成的，也就是说，由这个MethodMatcher来判断是否需要对当前方法调用进行增强，或者是否需要对当前调用方法应用配置好Advice通知。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在Pointcut的类继承关系中，以正则表达式切点JdkRegexpMethodPointcut的实现原理为例，来具体了解切点Pointcut的工作原理。该类完成通过正则表达式对方法名进行匹配的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkRegexpMethodPointcut</span> <span class="keyword">extends</span> <span class="title">AbstractRegexpMethodPointcut</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//要编译的正则表达式模式  </span></span><br><span class="line">    <span class="keyword">private</span> Pattern[] compiledPatterns = <span class="keyword">new</span> Pattern[<span class="number">0</span>];  </span><br><span class="line">    <span class="comment">//编译时要排除的正则表达式模式  </span></span><br><span class="line">    <span class="keyword">private</span> Pattern[] compiledExclusionPatterns = <span class="keyword">new</span> Pattern[<span class="number">0</span>];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的模式字符串数组初始化为编译的正则表达式模式  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPatternRepresentation</span><span class="params">(String[] patterns)</span> <span class="keyword">throws</span> PatternSyntaxException </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.compiledPatterns = compilePatterns(patterns);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的模式字符串数组初始化为编译时要排除的正则表达式模式  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initExcludedPatternRepresentation</span><span class="params">(String[] excludedPatterns)</span> <span class="keyword">throws</span> PatternSyntaxException </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.compiledExclusionPatterns = compilePatterns(excludedPatterns);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用正则表达式匹配给定的名称  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;  </span><br><span class="line">        Matcher matcher = <span class="keyword">this</span>.compiledPatterns[patternIndex].matcher(pattern);  </span><br><span class="line">        <span class="keyword">return</span> matcher.matches();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用要排除的正则表达式匹配给定的名称  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesExclusion</span><span class="params">(String candidate, <span class="keyword">int</span> patternIndex)</span> </span>&#123;  </span><br><span class="line">        Matcher matcher = <span class="keyword">this</span>.compiledExclusionPatterns[patternIndex].matcher(candidate);  </span><br><span class="line">        <span class="keyword">return</span> matcher.matches();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的字符串数组编译为正则表达的模式  </span></span><br><span class="line">    <span class="keyword">private</span> Pattern[] compilePatterns(String[] source) <span class="keyword">throws</span> PatternSyntaxException &#123;  </span><br><span class="line">        Pattern[] destination = <span class="keyword">new</span> Pattern[source.length];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;  </span><br><span class="line">            destination[i] = Pattern.compile(source[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> destination;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码分析中，我们可以看到，最简单的使用正则表达式匹配的Pointcut切入点基本功能就是根据正则表达式判断方法名等是否匹配。</p>
<h3 id="四、Advisor通知器："><a href="#四、Advisor通知器：" class="headerlink" title="四、Advisor通知器："></a>四、Advisor通知器：</h3><p>当完成对目标对象方法的增强行为操作 <strong>Advice</strong> 和切入点 <strong>Point</strong> 的设计开发之后，需要一个对象将目标对象、增强行为和切入点三者结合起来，通知器Advisor就是一个实现这个功能的对象，即通过Advisor通知器，可以定义那些目标对象的那些方法在什么地方使用这些增加的行为。</p>
<h4 id="Advisor通知器定义"><a href="#Advisor通知器定义" class="headerlink" title="Advisor通知器定义"></a>Advisor通知器定义</h4><p>Advisor通知器的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advisor</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//获取切面的通知Advice  </span></span><br><span class="line">    <span class="function">Advice <span class="title">getAdvice</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断这个通知是否和某个特定的实例对象相关  </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>查看Advisor通知器的继承体系，发现Advisor的实现类很多，我们以最常用的DefaultPointcutAdvisor为例，分析通知器的工作原理。</p>
<ol>
<li><p>DefaultPointcutAdvisor源码如下</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPointcutAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractGenericPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//默认切入点  — - - ——&gt;</span></span><br><span class="line">    <span class="comment">//Pointcut.TRUE在切入点中的定义为：Pointcut TRUE = TruePointcut.INSTANCE; </span></span><br><span class="line">    <span class="keyword">private</span> Pointcut pointcut = Pointcut.TRUE;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造方法，创建一个空的通知器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultPointcutAdvisor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个匹配所有方法的通知器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultPointcutAdvisor</span><span class="params">(Advice advice)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(Pointcut.TRUE, advice);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个指定切入点和通知的通知器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultPointcutAdvisor</span><span class="params">(Pointcut pointcut, Advice advice)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.pointcut = pointcut;  </span><br><span class="line">        setAdvice(advice);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//为通知设置切入点  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPointcut</span><span class="params">(Pointcut pointcut)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.pointcut = (pointcut != <span class="keyword">null</span> ? pointcut : Pointcut.TRUE);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取切入点  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pointcut;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">": pointcut ["</span> + getPointcut() + <span class="string">"]; advice ["</span> + getAdvice() + <span class="string">"]"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>其中默认切入点为TruePointcut，主要功能是配置默认的类过滤器和方法匹配器，即定义Spring AOP对于哪些类的哪些方法其作用，源码如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TruePointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span>, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//INSTANCE是TruePointcut类的一个常量单件，即整个应用中只有这个一个，  </span></span><br><span class="line">    <span class="comment">//不会创建第二个实例对象，确保该实例对象的唯一性，单例模型  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TruePointcut INSTANCE = <span class="keyword">new</span> TruePointcut();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//单态模式构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TruePointcut</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取切入点的类过滤器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> ClassFilter.TRUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//获取切入点的方法匹配器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> MethodMatcher.TRUE;  <span class="comment">//  ————&gt;</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单态模式对象的方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pointcut.TRUE"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//———————————————</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line">	MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从TruePointcut的源码我们看到，切入点使用TrueClassFilter作为类过滤器，匹配任意的类; 使用TrueMethodMatcher作为方法匹配器，匹配任意的方法。下面我们继续分析TrueClassFilter类过滤器和TrueMethodMatcher方法匹配器。</p>
</li>
<li><p>TrueClassFilter作为默认切入点的默认类过滤器，主要告诉切入点对哪些类进行增强，源码如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrueClassFilter</span> <span class="keyword">implements</span> <span class="title">ClassFilter</span>, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//单态模式  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrueClassFilter INSTANCE = <span class="keyword">new</span> TrueClassFilter();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//单态模式的构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TrueClassFilter</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//切入点过滤匹配类的方法，默认对所有的类都增强  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class clazz)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单态模式对象的方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ClassFilter.TRUE"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>TrueMethodMatcher作为默认切入点的默认方法匹配器，主要告诉切入点对哪些方法进行增强，源码如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrueMethodMatcher</span> <span class="keyword">implements</span> <span class="title">MethodMatcher</span>, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//单态模式  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrueMethodMatcher INSTANCE = <span class="keyword">new</span> TrueMethodMatcher();  </span><br><span class="line">    <span class="comment">//单态模式构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TrueMethodMatcher</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//不支持运行时调用  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//切入点匹配方法时调用，默认匹配所有的方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行时调用将抛出异常  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass, Object[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单态模式对象的方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MethodMatcher.TRUE"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从上面方法匹配器的源码，我们可以看出，切入点对方法进行匹配时不支持运行时的匹配，如果在运行时进行匹配将抛出异常。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解读——BeanFactory</title>
    <url>/2012/02/24/spring-yuan-ma-jie-du-beanfactory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Spring中，IOC容器的重要地位我们就不多说了，对于Spring的使用者而言，IOC容器实际上是什么呢？我们可以说BeanFactory就是我们看到的IoC容器，当然了Spring为我们准备了许多种IoC容器来使用，这样可以方便我们从不同的层面，不同的资源位置，不同的形式的定义信息来建立我们需要的IoC容器。<br>在Spring中，最基本的IOC容器接口是BeanFactory - 这个接口为具体的IOC容器的实现作了最基本的功能规定 - 不管怎么着，作为IOC容器，这些接口你必须要满足应用程序的最基本要求： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里是对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，  </span></span><br><span class="line">    <span class="comment">//如果需要得到工厂本身，需要转义         </span></span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里根据bean的名字，在IOC容器中得到bean实例，这个IOC容器就是一个大的抽象工厂。  </span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里根据bean的名字和Class类型来得到bean实例，和上面的方法不同在于它会抛出异常：如果根据名字取得的bean实例的Class类型和需要的不同的话。  </span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里提供对bean的检索，看看是否在IOC容器有这个名字的bean  </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里根据bean名字得到bean实例，并同时判断这个bean是不是单件  </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里对得到bean实例的Class类型  </span></span><br><span class="line">    <span class="function">Class <span class="title">getType</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里得到bean的别名，如果根据别名检索，那么其原名也会被检索出来  </span></span><br><span class="line">    String[] getAliases(String name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的bean是怎样定义怎样加载的 - 就像我们只关心从这个工厂里我们得到到什么产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心这些。如果要关心工厂是怎样产生对象的，应用程序需要使用具体的IOC容器实现- 当然你可以自己根据这个BeanFactory来实现自己的IOC容器，但这个没有必要，因为Spring已经为我们准备好了一系列工厂来让我们使用。比如XmlBeanFactory就是针对最基础的BeanFactory的IOC容器的实现 - 这个实现使用xml来定义IOC容器中的bean。<br>Spring提供了一个BeanFactory的基本实现，XmlBeanFactory同样的通过使用模板模式来得到对IOC容器的抽象- AbstractBeanFactory,DefaultListableBeanFactory这些抽象类为其提供模板服务。其中通过resource 接口来抽象bean定义数据，对Xml定义文件的解析通过委托给XmlBeanDefinitionReader来完成。下面我们根据书上的例子，简单的演示IOC容器的创建过程： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>);  </span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();  </span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);  </span><br><span class="line">reader.loadBeanDefinitions(res);</span><br></pre></td></tr></table></figure>
<p>这些代码演示了以下几个步骤： </p>
<ol>
<li>创建IOC配置文件的抽象资源 </li>
<li>创建一个BeanFactory </li>
<li>把读取配置信息的BeanDefinitionReader,这里是XmlBeanDefinitionReader配置给BeanFactory </li>
<li>从定义好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader来完成，这样完成整个载入bean定义的过程。我们的IoC容器就建立起来了。在BeanFactory的源代码中我们可以看到： </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这里为容器定义了一个默认使用的bean定义读取器  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在初始化函数中使用读取器来对资源进行读取，得到bean定义信息。  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);  </span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们在后面会看到读取器读取资源和注册bean定义信息的整个过程，基本上是和上下文的处理是一样的，从这里我们可以看到上下文和 XmlBeanFactory这两种IOC容器的区别，BeanFactory往往不具备对资源定义的能力，而上下文可以自己完成资源定义，从这个角度上看上下文更好用一些。<br>仔细分析Spring BeanFactory的结构，我们来看看在BeanFactory基础上扩展出的ApplicationContext - 我们最常使用的上下文。除了具备BeanFactory的全部能力，上下文为应用程序又增添了许多便利： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 可以支持不同的信息源，我们看到ApplicationContext扩展了MessageSource </span><br><span class="line">* 访问资源 , 体现在对ResourceLoader和Resource的支持上面，这样我们可以从不同地方得到bean定义资源 </span><br><span class="line">* 支持应用事件，继承了接口ApplicationEventPublisher,这样在上下文中引入了事件机制而BeanFactory是没有的。</span><br></pre></td></tr></table></figure>
<p>ApplicationContext允许上下文嵌套 - 通过保持父上下文可以维持一个上下文体系 - 这个体系我们在以后对Web容器中的上下文环境的分析中可以清楚地看到。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。这个我们在分析Web容器中的上下文环境时也能看到。<br>ApplicationContext提供IoC容器的主要接口，在其体系中有许多抽象子类比如AbstractApplicationContext为具体的BeanFactory的实现，比如FileSystemXmlApplicationContext和 ClassPathXmlApplicationContext提供上下文的模板，使得他们只需要关心具体的资源定位问题。当应用程序代码实例化 FileSystemXmlApplicationContext的时候，得到IoC容器的一种具体表现 - ApplicationContext，从而应用程序通过ApplicationContext来管理对bean的操作。<br>BeanFactory 是一个接口，在实际应用中我们一般使用ApplicationContext来使用IOC容器，它们也是IOC容器展现给应用开发者的使用接口。对应用程序开发者来说，可以认为BeanFactory和ApplicationFactory在不同的使用层面上代表了SPRING提供的IOC容器服务。<br>下面我们具体看看通过FileSystemXmlApplicationContext是怎样建立起IOC容器的, 显而易见我们可以通过new来得到IoC容器： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(xmlPath);</span><br></pre></td></tr></table></figure>
<p>调用的是它初始化代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>(parent);  </span><br><span class="line">    <span class="keyword">this</span>.configLocations = configLocations;  </span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;  </span><br><span class="line">      　<span class="comment">//这里是IoC容器的初始化过程，其初始化过程的大致步骤由AbstractApplicationContext来定义  </span></span><br><span class="line">        refresh();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refresh的模板在AbstractApplicationContext: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeMonitor) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.active = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 这里需要子类来协助完成资源位置定义,bean载入和向IOC容器注册的过程  </span></span><br><span class="line">        refreshBeanFactory();  </span><br><span class="line">        ............  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法包含了整个BeanFactory初始化的过程，对于特定的FileSystemXmlBeanFactory,我们看到定位资源位置由refreshBeanFactory()来实现：<br>在AbstractXmlApplicationContext中定义了对资源的读取过程，默认由XmlBeanDefinitionReader来读取： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="comment">// 这里使用XMLBeanDefinitionReader来载入bean定义信息的XML文件  </span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里配置reader的环境，其中ResourceLoader是我们用来定位bean定义信息资源位置的  </span></span><br><span class="line">    <span class="comment">///因为上下文本身实现了ResourceLoader接口，所以可以直接把上下文作为ResourceLoader传递给XmlBeanDefinitionReader  </span></span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);  </span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));  </span><br><span class="line">  </span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);  </span><br><span class="line">    <span class="comment">//这里转到定义好的XmlBeanDefinitionReader中对载入bean信息进行处理  </span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转到beanDefinitionReader中进行处理： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;  </span><br><span class="line">    Resource[] configResources = getConfigResources();  </span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="comment">//调用XmlBeanDefinitionReader来载入bean定义信息。  </span></span><br><span class="line">        reader.loadBeanDefinitions(configResources);  </span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();  </span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        reader.loadBeanDefinitions(configLocations);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在作为其抽象父类的AbstractBeanDefinitionReader中来定义载入过程： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line"> <span class="comment">//这里得到当前定义的ResourceLoader,默认的我们使用DefaultResourceLoader  </span></span><br><span class="line"> ResourceLoader resourceLoader = getResourceLoader();  </span><br><span class="line"> .........<span class="comment">//如果没有找到我们需要的ResourceLoader，直接抛出异常  </span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;  </span><br><span class="line">        <span class="comment">// 这里处理我们在定义位置时使用的各种pattern,需要ResourcePatternResolver来完成  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);  </span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);  </span><br><span class="line">            <span class="keyword">return</span> loadCount;  </span><br><span class="line">        &#125;</span><br><span class="line">      ........  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 这里通过ResourceLoader来完成位置定位  </span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);  </span><br><span class="line">        <span class="comment">// 这里已经把一个位置定义转化为Resource接口，可以供XmlBeanDefinitionReader来使用了  </span></span><br><span class="line">        <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);  </span><br><span class="line">        <span class="keyword">return</span> loadCount;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们通过ResourceLoader来载入资源，别忘了了我们的GenericApplicationContext也实现了ResourceLoader接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//这里调用当前的loader也就是DefaultResourceLoader来完成载入  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader.getResource(location);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResource(location);  </span><br><span class="line">    &#125;</span><br><span class="line">.......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们的FileSystemXmlApplicationContext就是一个DefaultResourceLoader - GenericApplicationContext()通过DefaultResourceLoader: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//如果是类路径的方式，那需要使用ClassPathResource来得到bean文件的资源对象  </span></span><br><span class="line">    <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 如果是URL方式，使用UrlResource作为bean文件的资源对象  </span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(location);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (MalformedURLException ex) &#123;  </span><br><span class="line">            <span class="comment">// 如果都不是，那我们只能委托给子类由子类来决定使用什么样的资源对象了  </span></span><br><span class="line">            <span class="keyword">return</span> getResourceByPath(location);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的FileSystemXmlApplicationContext本身就是是DefaultResourceLoader的实现类，他实现了以下的接口： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) &#123;  </span><br><span class="line">        path = path.substring(<span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里使用文件系统资源对象来定义bean文件  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样代码就回到了FileSystemXmlApplicationContext中来，他提供了FileSystemResource来完成从文件系统得到配置文件的资源定义。这样，就可以从文件系统路径上对IOC配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方加载，在Spring中我们看到它提供的各种资源抽象，比如ClassPathResource, URLResource,FileSystemResource等来供我们使用。上面我们看到的是定位Resource的一个过程，而这只是加载过程的一部分 - 我们回到AbstractBeanDefinitionReaderz中的loadDefinitions(resource)来看看得到代表bean文件的资源定义以后的载入过程,默认的我们使用XmlBeanDefinitionReader： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">    .......  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">//这里通过Resource得到InputStream的IO流  </span></span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//从InputStream中得到XML的解析源  </span></span><br><span class="line">            InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);  </span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里是具体的解析和注册过程  </span></span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="comment">//关闭从Resource中得到的IO流  </span></span><br><span class="line">            inputStream.close();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       .........  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">int</span> validationMode = getValidationModeForResource(resource);  </span><br><span class="line">        <span class="comment">//通过解析得到DOM，然后完成bean在IOC容器中的注册  </span></span><br><span class="line">        Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(  </span><br><span class="line">                inputSource, <span class="keyword">this</span>.entityResolver, <span class="keyword">this</span>.errorHandler, validationMode, <span class="keyword">this</span>.namespaceAware);  </span><br><span class="line">        <span class="keyword">return</span> registerBeanDefinitions(doc, resource);  </span><br><span class="line">    &#125;</span><br><span class="line">.......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到先把定义文件解析为DOM对象，然后进行具体的注册过程： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">    <span class="comment">// 这里定义解析器，使用XmlBeanDefinitionParser来解析xml方式的bean定义文件 - 现在的版本不用这个解析器了，使用的是XmlBeanDefinitionReader  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parserClass != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        XmlBeanDefinitionParser parser =  </span><br><span class="line">                (XmlBeanDefinitionParser) BeanUtils.instantiateClass(<span class="keyword">this</span>.parserClass);  </span><br><span class="line">        <span class="keyword">return</span> parser.registerBeanDefinitions(<span class="keyword">this</span>, doc, resource);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体的注册过程,首先得到XmlBeanDefinitionReader,来处理xml的bean定义文件  </span></span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();  </span><br><span class="line">    <span class="keyword">int</span> countBefore = getBeanFactory().getBeanDefinitionCount();  </span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));  </span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBeanDefinitionCount() - countBefore;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的在BeanDefinitionDocumentReader中完成对，下面是一个简要的注册过程来完成bean定义文件的解析和IOC容器中bean的初始化 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;  </span><br><span class="line">  </span><br><span class="line">    logger.debug(<span class="string">"Loading bean definitions"</span>);  </span><br><span class="line">    Element root = doc.getDocumentElement();  </span><br><span class="line">  </span><br><span class="line">    BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);  </span><br><span class="line">  </span><br><span class="line">    preProcessXml(root);  </span><br><span class="line">    parseBeanDefinitions(root, delegate);  </span><br><span class="line">    postProcessXml(root);  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root.getNamespaceURI())) &#123;  </span><br><span class="line">        <span class="comment">//这里得到xml文件的子节点，比如各个bean节点           </span></span><br><span class="line">        NodeList nl = root.getChildNodes();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//这里对每个节点进行分析处理  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;  </span><br><span class="line">            Node node = nl.item(i);  </span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;  </span><br><span class="line">                Element ele = (Element) node;  </span><br><span class="line">                String namespaceUri = ele.getNamespaceURI();  </span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(namespaceUri)) &#123;  </span><br><span class="line">                    <span class="comment">//这里是解析过程的调用，对缺省的元素进行分析比如bean元素  </span></span><br><span class="line">                    parseDefaultElement(ele, delegate);  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;  </span><br><span class="line">                    delegate.parseCustomElement(ele);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        delegate.parseCustomElement(root);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这里对元素Import进行处理  </span></span><br><span class="line">    <span class="keyword">if</span> (DomUtils.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;  </span><br><span class="line">        importBeanDefinitionResource(ele);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DomUtils.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;  </span><br><span class="line">        String name = ele.getAttribute(NAME_ATTRIBUTE);  </span><br><span class="line">        String alias = ele.getAttribute(ALIAS_ATTRIBUTE);  </span><br><span class="line">        getReaderContext().getReader().getBeanFactory().registerAlias(name, alias);  </span><br><span class="line">        getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里对我们最熟悉的bean元素进行处理  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DomUtils.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;  </span><br><span class="line">        <span class="comment">//委托给BeanDefinitionParserDelegate来完成对bean元素的处理，这个类包含了具体的bean解析的过程。  </span></span><br><span class="line">        <span class="comment">// 把解析bean文件得到的信息放到BeanDefinition里，他是bean信息的主要载体，也是IOC容器的管理对象。  </span></span><br><span class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);  </span><br><span class="line">        <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);  </span><br><span class="line">            <span class="comment">// 这里是向IOC容器注册，实际上是放到IOC容器的一个map里  </span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 这里向IOC容器发送事件，表示解析和注册完成。  </span></span><br><span class="line">            getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在parseBeanDefinition中对具体bean元素的解析式交给BeanDefinitionParserDelegate来完成的，下面我们看看解析完的bean是怎样在IOC容器中注册的：<br>在BeanDefinitionReaderUtils调用的是： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder bdHolder, BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里得到需要注册bean的名字；  </span></span><br><span class="line">    String beanName = bdHolder.getBeanName();  </span><br><span class="line">    <span class="comment">//这是调用IOC来注册的bean的过程，需要得到BeanDefinition  </span></span><br><span class="line">    beanFactory.registerBeanDefinition(beanName, bdHolder.getBeanDefinition());  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 别名也是可以通过IOC容器和bean联系起来的进行注册  </span></span><br><span class="line">    String[] aliases = bdHolder.getAliases();  </span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aliases.length; i++) &#123;  </span><br><span class="line">            beanFactory.registerAlias(beanName, aliases[i]);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看XmlBeanFactory中的注册实现： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------  </span></span><br><span class="line"><span class="comment">// 这里是IOC容器对BeanDefinitionRegistry接口的实现  </span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    .....<span class="comment">//这里省略了对BeanDefinition的验证过程  </span></span><br><span class="line">    <span class="comment">//先看看在容器里是不是已经有了同名的bean,如果有抛出异常。  </span></span><br><span class="line">    Object oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);  </span><br><span class="line">    <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.allowBeanDefinitionOverriding) &#123;  </span><br><span class="line">        ...........  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//把bean的名字加到IOC容器中去  </span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames.add(beanName);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里把bean的名字和Bean定义联系起来放到一个HashMap中去,IOC容器通过这个Map来维护容器里的Bean定义信息。  </span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);  </span><br><span class="line">    removeSingleton(beanName);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完成了Bean定义在IOC容器中的注册，就可被IOC容器进行管理和使用了。<br>从上面的代码来看，我们总结一下IOC容器初始化的基本步骤： </p>
<ul>
<li>初始化的入口在容器实现中的refresh()调用来完成 </li>
<li>对bean 定义载入IOC容器使用的方法是loadBeanDefinition,其中的大致过程如下：通过ResourceLoader来完成资源文件位置的定位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了ResourceLoader的实现，可以从类路径，文件系统, URL等方式来定为资源位置。如果是XmlBeanFactory作为IOC容器，那么需要为它指定bean定义的资源，也就是说bean定义文件时通过抽象成Resource来被IOC容器处理的，容器通过BeanDefinitionReader来完成定义信息的解析和Bean信息的注册,往往使用的是XmlBeanDefinitionReader来解析bean的xml定义文件 - 实际的处理过程是委托给BeanDefinitionParserDelegate来完成的，从而得到bean的定义信息，这些信息在Spring中使用BeanDefinition对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition这些相关的方法 - 他们都是为处理BeanDefinitin服务的，IoC容器解析得到BeanDefinition以后，需要把它在IOC容器中注册，这由IOC实现 BeanDefinitionRegistry接口来实现。注册过程就是在IOC容器内部维护的一个HashMap来保存得到的 BeanDefinition的过程。这个HashMap是IoC容器持有bean信息的场所，以后对bean的操作都是围绕这个HashMap来实现的。 </li>
<li>然后我们就可以通过BeanFactory和ApplicationContext来享受到Spring IOC的服务了. </li>
</ul>
<p>在使用IOC容器的时候，我们注意到除了少量粘合代码，绝大多数以正确IoC风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring本身提供了对声明式载入web应用程序用法的应用程序上下文，并将其存储在ServletContext中的框架实现。具体可以参见以后的文章。<br>在使用Spring IOC容器的时候我们还需要区别两个概念：<br>Beanfactory 和Factory bean，其中BeanFactory指的是IOC容器的编程抽象，比如ApplicationContext， XmlBeanFactory等，这些都是IOC容器的具体表现，需要使用什么样的容器由客户决定但Spring为我们提供了丰富的选择。而 FactoryBean只是一个可以在IOC容器中被管理的一个bean,是对各种处理过程和资源使用的抽象,Factory bean在需要时产生另一个对象，而不返回FactoryBean本省，我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean都实现特殊的org.springframework.beans.factory.FactoryBean接口，当使用容器中factory bean的时候，该容器不会返回factory bean本身，而是返回其生成的对象。Spring包括了大部分的通用资源和服务访问抽象的Factory bean的实现，其中包括：<br>对JNDI查询的处理，对代理对象的处理，对事务性代理的处理，对RMI代理的处理等，这些我们都可以看成是具体的工厂，看成是SPRING为我们建立好的工厂。也就是说Spring通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象，免除我们手工重复的工作，我们要使用时只需要在IOC容器里配置好就能很方便的使用了。<br>现在我们来看看在Spring的事件机制，Spring中有3个标准事件，ContextRefreshEvent, ContextCloseEvent,RequestHandledEvent他们通过ApplicationEvent接口，同样的如果需要自定义时间也只需要实现ApplicationEvent接口，参照ContextCloseEvent的实现可以定制自己的事件实现： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextClosedEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextClosedEvent</span><span class="params">(ApplicationContext source)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(source);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> (ApplicationContext) getSource();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过显现ApplicationEventPublishAware接口，将事件发布器耦合到ApplicationContext这样可以使用 ApplicationContext框架来传递和消费消息,然后在ApplicationContext中配置好bean就可以了，在消费消息的过程中，接受者通过实现ApplicationListener接收消息。 </p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解读——Bean的加载</title>
    <url>/2012/02/21/spring-yuan-ma-jie-du-bean-de-jia-zai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    Spring给我们构建了一个IoC的容器<code>BeanFactory</code>，从容器中加载某个一Bean的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestBean bean = (TestBean)beanFactory.getBean(<span class="string">"testBean"</span>)</span><br></pre></td></tr></table></figure>
<p>​    今天就来分析一下这个 <code>getBean</code> 的调用过程。</p>
<a id="more"></a>
<h3 id="SpringBean的加载"><a href="#SpringBean的加载" class="headerlink" title="SpringBean的加载"></a>SpringBean的加载</h3><p>​    这段调用的落脚点最终是在 <code>AbstractBeanFactory.doGetBean</code> 方法中，这是一个重载方法，有多种不同的签名方式，可以根据需要进行调用，终于都会统一到如下的方法中，我们今天就来分析这个方法，看看Spring是如何管理及初始化Bean的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//提取对应的beanName</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *检查缓存中或者实例工厂中是否有对应的实例</span></span><br><span class="line"><span class="comment">     *为什么首先会使用这段代码呢，因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，</span></span><br><span class="line"><span class="comment">     *Spring创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光，</span></span><br><span class="line"><span class="comment">     *也就是将ObjectFactory加入到缓存中，一旦下个bean创建时候需要依赖上个bean则直接使用ObjectFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//直接尝试从缓存获取或者singletonFactories中的ObjectFactory中获取</span></span><br><span class="line">    Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">    Object bean;</span><br><span class="line">    <span class="keyword">if</span>(sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean \'"</span> + beanName + <span class="string">"\' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Returning cached instance of singleton bean \'"</span> + beanName + <span class="string">"\'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回对应的实例，有时候存在诸如BeanFactory的情况并不是直接返回实例本身而是返回指定方法返回的实例</span></span><br><span class="line">        bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//只有在单例情况下才会尝试解决循环依赖，原型模式情况下，如果存在</span></span><br><span class="line">        <span class="comment">//A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为</span></span><br><span class="line">        <span class="comment">//对于B的创建再次返回创建A，造成循环依赖，也就是下面的情况</span></span><br><span class="line">        <span class="comment">//isPrototypeCurrentlyInCreation(beanName)为true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">        <span class="comment">//如果BeanDefinitionMap中也就是在所有已经加载的类中不包括beanName则尝试从parentBeanFactory中检测</span></span><br><span class="line">        <span class="keyword">if</span>(parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            String var19 = <span class="keyword">this</span>.originalBeanName(name);</span><br><span class="line">            <span class="comment">//递归到BeanFactory中寻找</span></span><br><span class="line">            <span class="keyword">if</span>(args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(var19, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(var19, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不是仅仅做类型检查则是创建bean，这里要进行记录</span></span><br><span class="line">        <span class="keyword">if</span>(!typeCheckOnly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition，如果指定BeanName是子Bean的话同时会合并父类的相关属性</span></span><br><span class="line">        <span class="keyword">final</span> RootBeanDefinition mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        String scopeName;</span><br><span class="line">        <span class="comment">//若存在依赖则需要递归实例化依赖的bean</span></span><br><span class="line">        <span class="keyword">if</span>(dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] var14 = dependsOn;</span><br><span class="line">            <span class="keyword">int</span> ex = dependsOn.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> scope = <span class="number">0</span>; scope &lt; ex; ++scope) &#123;</span><br><span class="line">                scopeName = var14[scope];</span><br><span class="line">                <span class="keyword">this</span>.getBean(scopeName);</span><br><span class="line">                <span class="comment">//缓存依赖调用</span></span><br><span class="line">                 <span class="keyword">this</span>.registerDependentBean(scopeName, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化依赖的bean后便可以实例化mbd本身了</span></span><br><span class="line">        <span class="comment">//singleton模式的创建</span></span><br><span class="line">        <span class="keyword">if</span>(mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> AbstractBeanFactory.<span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeansException var2) &#123;</span><br><span class="line">                        AbstractBeanFactory.<span class="keyword">this</span>.destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> var2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">//prototype模式的创建(new)</span></span><br><span class="line">            scopeName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            Object var20;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                var20 = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bean = <span class="keyword">this</span>.getObjectForBeanInstance(var20, name, beanName, mbd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//指定的scope上实例化bean</span></span><br><span class="line">            scopeName = mbd.getScope();</span><br><span class="line">            Scope var21 = (Scope)<span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span>(var21 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope \'"</span> + scopeName + <span class="string">"\'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object var22 = var21.get(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                        AbstractBeanFactory.<span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line"></span><br><span class="line">                        Object var2;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            var2 = AbstractBeanFactory.<span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            AbstractBeanFactory.<span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> var2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = <span class="keyword">this</span>.getObjectForBeanInstance(var22, name, beanName, mbd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException var18) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Scope \'"</span> + scopeName + <span class="string">"\' is not active for the current thread; "</span> + <span class="string">"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>, var18);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查需要的类型是否符合bean的实际类型</span></span><br><span class="line">    <span class="keyword">if</span>(requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    从源码可以看出，SpringBean的加载过程主要分以下几个步骤：</p>
<ol>
<li><p><strong>转换对应beanName</strong>：这里传入的参数name不一定就是beanName，有可能是别名或FactoryBean，所以需要进行一系列的解析，这些解析内容包括如下内容：</p>
<ul>
<li>去除FactoryBean的修饰符，也就是如果<code>name=&quot;&amp;aa&quot;</code>，那么会首先去除&amp;而使<code>name=&quot;aa&quot;</code></li>
<li>取指定alias所表示的最终beanName，例如别名A指向名称为B的bean则返回B；若别名A指向别名B，别名B又指向名称为C的bean则返回C</li>
</ul>
</li>
<li><p><strong>尝试从缓存中加载单例</strong></p>
<p> ​    单例在Spring的同一个容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了。这里只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从singletonFactories中加载，因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，在Spring中创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦下一个bean创建时候需要依赖上一个bean则直接使用ObjectFactory。</p>
</li>
<li><p><strong>bean的实例化</strong></p>
<p> ​    如果从缓存中得到了bean的原始状态，则需要对bean进行实例化，这里有必要强调一下，在缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean。</p>
</li>
<li><p><strong>原型模式的依赖检查</strong></p>
<p> ​    只有在单例情况下才会尝试解决循环依赖，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次返回创建A，造成循环依赖，也就是情况：<code>isPrototypeCurrentlyInCreation(beanName)</code>判断true。</p>
</li>
<li><p><strong>检测parentBeanFactory</strong></p>
<p> ​    从代码上来看，如果缓存没有数据的话直接转到父类工厂上去加载，<code>!this.containsBeanDefinition(beanName)</code>检测如果当前加载的XML配置文件中不包含beanName所对应的配置，就只能到parentBeanFactory去尝试，然后再去递归的调用<code>getBean</code>方法。</p>
</li>
<li><p><strong>将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition</strong></p>
<p> ​    因为从XML配置文件中读取到的Bean信息是存储在GernericBeanDefinition中的，但是所有的Bean后续处理都是针对于RootBeanDefinition的，所以这里需要进行一个转换，转换的同时如果父类bean不为空的话，则会一并合并父类属性。</p>
</li>
<li><p><strong>寻找依赖</strong></p>
<p> ​    因为bean的初始化过程很可能会用到某些属性，而某些属性很可能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以，在Spring的加载顺寻中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖。</p>
</li>
<li><p><strong>针对不同的scope进行bean的创建</strong></p>
<p> ​    在Spring中存在着不同的scope，其中默认的是singleton，但是还有些其他的配置诸如prototype、request之类的，在这个步骤中，Spring会根据不同的配置进行不同的初始化策略。</p>
</li>
<li><p><strong>类型转换</strong></p>
<p> ​    程序到这里返回bean后已经基本结束了，通常对该方法的调用参数requiredType是为空的，但是可能会存在这样的情况，返回的bean其实是个String，但是requiredType却传入Integer类型，那么这时候本步骤就会起作用了，它的功能是将返回的bean转换为requiredType所指定的类型，当然，String转换为Integer是最简单的一种转换，在Spring中提供了各种各样的转换器，用户也可以自己扩展转换器来满足需求。</p>
</li>
</ol>
<h3 id="FactoryBean-的作用"><a href="#FactoryBean-的作用" class="headerlink" title="FactoryBean 的作用"></a>FactoryBean 的作用</h3><p>​    一般情况下， Spring通过反射机制利用bean的class属性指定实现类来实例化bean，在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案</bean></p>
<p>​    Spring为此提供了一个<code>org.Springframework.bean.factory.FactoryBean</code>的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑</p>
<p>​    FactoryBean接口对于Spring框架来说占有重要的地位，Spring自身就提供了70多个FactoryBean的实现，它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利，从Spring 3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<t>的形式：</t></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在该接口中还定义了以下3个方法：</p>
<ol>
<li><code>T getObject()</code>：返回由FactoryBean创建的bean实例，如果<code>isSingleton()</code>返回true，则该实例会放到Spring容器中单实例缓存池中。</li>
<li><code>boolean isSingleton()</code>：返回由FactoryBean创建的bean实例的作用域是singleton还是prototype。</li>
<li><code>Class&lt;T&gt; getObjectType()</code>：返回FactoryBean创建的bean类型。</li>
</ol>
<p>​    当配置文件中<bean>的class属性配置的实现类是FactoryBean时，通过<code>getBean()</code>方法返回的不是FactoryBean本身，而是<code>FactoryBean#getObject()</code>方法所返回的对象，相当于<code>FactoryBean#getObject()</code>代理了<code>getBean()</code>方法。</bean></p>
<h3 id="缓存中获取单例-bean"><a href="#缓存中获取单例-bean" class="headerlink" title="缓存中获取单例 bean"></a>缓存中获取单例 bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数true设置标识允许早期依赖</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查缓存中是否存在实例</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span>(singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果为空，则锁定全局变量并进行处理</span></span><br><span class="line">        Map var4 = <span class="keyword">this</span>.singletonObjects;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//如果此bean正在加载则不处理</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span>(singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">//当某些方法需要提前初始化的时候则会调用addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories</span></span><br><span class="line">                ObjectFactory singletonFactory = (ObjectFactory)<span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span>(singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//调用预先设定的getObject方法</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">//记录在缓存中，earlySingletonObjects和singletonFactories互斥</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> singletonObject != NULL_OBJECT?singletonObject:<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这个方法首先尝试从<code>singletonObjects</code>里面获取实例，如果获取不到再从<code>earlySingletonObjects</code>里面获取，如果还获取不到，再尝试从<code>singletonFactories</code>里面获取<strong>beanName</strong>对应的<strong>ObjectFactory</strong>，然后调用这个<strong>ObjectFactory</strong>的<code>getObject</code>来创建bean，并放到<code>earlySingletonObjects</code>里面去，并且从<code>singletonFactories</code>里面remove掉这个<strong>ObjectFactory</strong>，而对于后续的所有内存操作都只为了循环依赖检测时候使用，也就是在<code>allowEarlyReference</code>为true的情况下才会使用。</p>
<p>​    这里涉及用于存在bean的不同map，说明如下：</p>
<ol>
<li><strong>singletonObjects</strong>：用于保存BeanName和创建bean实例之间的关系，bean name-&gt;bean instance。</li>
<li><strong>singletonFactories</strong>：用于保存BeanName和创建bean的工厂之间的关系，bean name-&gt;ObjectFactory。</li>
<li><strong>earlySingletonObjects</strong>：也是保存BeanName和创建bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例bean被放到这里面后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其目的是用来检测循环引用。</li>
<li><strong>registeredSingletons</strong>：用来保存当前所有已注册的bean。</li>
</ol>
<h3 id="从bean的实例中获取对象"><a href="#从bean的实例中获取对象" class="headerlink" title="从bean的实例中获取对象"></a>从bean的实例中获取对象</h3><p>​    在<code>getBean</code>方法中，<code>getObjectForBeanInstance</code>是个高频率使用的方法，无论是从缓存中获得bean还是根据不同的scope策略加载bean。总之，得到bean的实例后要做的第一步就是调用这个方法来检测一下正确性，其实就是用于检测当前bean是否是FactoryBean类型的bean，如果是，那么需要调用该bean对应的FactoryBean实例中的<code>getObject()</code>作为返回值。</p>
<p>​    无论是从缓存中获取到的bean还是通过不同的scope策略加载的bean都只是最原始的bean状态，并不一定是最终想要的bean，如需要对工厂bean进行处理，那么这里得到的其实是工厂bean的初始状态， 但是我们真正需要的是工厂bean中定义的<strong>factory-method</strong>方法中返回的bean，而<code>getObjectForBeanInstance</code>方法就是完成这个工作的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果指定的name是工厂相关(以&amp;为前缀)且beanInstance又不是FactoryBean类型则验证不通过</span></span><br><span class="line">    <span class="keyword">if</span>(BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(<span class="keyword">this</span>.transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(beanInstance <span class="keyword">instanceof</span> FactoryBean &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="comment">//加载FactoryBean</span></span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//尝试从缓存中加载bean</span></span><br><span class="line">            object = <span class="keyword">this</span>.getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里已经明确知道beanInstance一定是FactoryBean类型</span></span><br><span class="line">        <span class="keyword">if</span>(object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            FactoryBean factory = (FactoryBean)beanInstance;</span><br><span class="line">            <span class="comment">//containsBeanDefinition检测BeanDefinitionMap中也就是在所有已经加载的类中检测是否定义beanName</span></span><br><span class="line">            <span class="keyword">if</span>(mbd == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                <span class="comment">//将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition，如果指定BeanName是子Bean的话同时会合并父类的相关属性</span></span><br><span class="line">                mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//是否是用户定义的而不是应用程序本身定义的</span></span><br><span class="line">            <span class="keyword">boolean</span> synthetic = mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic();</span><br><span class="line">            object = <span class="keyword">this</span>.getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>getObjectForBeanInstance</code>中所做的工作如下：</p>
<ol>
<li>对FactoryBean正确性的验证。</li>
<li>对非FactoryBean不做任何处理。</li>
<li>对bean进行转换。</li>
<li>将从Factory中解析bean的工作委托给<code>getObjectFromFactoryBean</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(factory.isSingleton() &amp;&amp; <span class="keyword">this</span>.containsSingleton(beanName)) &#123;</span><br><span class="line">        <span class="comment">//如果是单例模式</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.getSingletonMutex()) &#123;</span><br><span class="line">            Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            <span class="keyword">if</span>(object == <span class="keyword">null</span>) &#123;</span><br><span class="line">                object = <span class="keyword">this</span>.doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">                <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object != <span class="keyword">null</span>?object:NULL_OBJECT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> object != NULL_OBJECT?object:<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这个方法中只做了一件事情，就是返回的bean如果是单例的，那就必须保证全局唯一，同时，也因为是单例的，所以不必重复创建，可以使用缓存来提高性能，也就是说已经加载过就要记录下来以便于下次复用， 否则的话就直接获取了。<code>doGetObjectFromFactoryBean</code>方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//需要权限验证</span></span><br><span class="line">        <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessControlContext ex = <span class="keyword">this</span>.getAccessControlContext();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                object = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException var8) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var8.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接调用getObject方法</span></span><br><span class="line">            object = factory.getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FactoryBeanNotInitializedException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, var9.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"FactoryBean threw exception on object creation"</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(object == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, <span class="string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(object != <span class="keyword">null</span> &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用ObjectFactory的后处理器</span></span><br><span class="line">                object = <span class="keyword">this</span>.postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of the FactoryBean\'s object failed"</span>, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>doGetObjectFromFactoryBean</code>实现了从FactoryBean中对应的getObject方法得到bean，但是得到后并没有立即返回，而是做了些后处理的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">postProcessObjectFromFactoryBean</span><span class="params">(Object object, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    Iterator var5 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">        BeanPostProcessor beanProcessor = (BeanPostProcessor)var5.next();</span><br><span class="line">        result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在Spring获取bean的规则中有这样一条：尽可能保证所有bean初始化后都会调用注册的BeanPostProcessor的<code>postProcessAfterInitialization</code>方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑</p>
<h3 id="获取单例"><a href="#获取单例" class="headerlink" title="获取单例"></a>获取单例</h3><p>​    如果缓存中不存在已经加载的单例bean就需要从头开始bean的加载过程了，而Spring中使用getSingleton的重载方法实现bean的加载过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"\'beanName\' must not be null"</span>);</span><br><span class="line">    Map var3 = <span class="keyword">this</span>.singletonObjects;</span><br><span class="line">    <span class="comment">//全局变量需要同步</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">//首先检查对应的bean是否已经加载过，因为singleton模式其实就是复用以前创建的bean，所以这一步是必须的</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//如果为null才可以进行singleton的bean的初始化</span></span><br><span class="line">        <span class="keyword">if</span>(singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName, <span class="string">"Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Creating shared instance of singleton bean \'"</span> + beanName + <span class="string">"\'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = <span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//初始化bean</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeanCreationException var13) &#123;</span><br><span class="line">                BeanCreationException ex = var13;</span><br><span class="line">                <span class="keyword">if</span>(recordSuppressedExceptions) &#123;</span><br><span class="line">                    Iterator var8 = <span class="keyword">this</span>.suppressedExceptions.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                        Exception suppressedException = (Exception)var8.next();</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入缓存</span></span><br><span class="line">            <span class="keyword">this</span>.addSingleton(beanName, singletonObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonObject != NULL_OBJECT?singletonObject:<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上述代码中其实是使用了回调方法，使得程序可以在单例创建的前后做一些准备及处理操作，而真正获取单例bean的方法其实并不是再此方法中实现的，其实现逻辑是在ObjectFactory类型的实例singletonFactory中实现的，而这些准备及处理操作包括如下内容。</p>
<ol>
<li><p>检查缓存是否已经加载过。</p>
</li>
<li><p>若没有加载，则记录beanName的正在加载状态。</p>
</li>
<li><p>加载单例前记录加载状态</p>
<p> <code>beforeSingletonCreation</code>方法是个空实现，其目的是：记录加载状态，也就是通过<code>this.singletonsCurrentlyInCreation.add(beanName)</code>将当前正在创建的bean记录在缓存中，这样便可以对循环依赖进行检测。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过调用参数传入的ObjectFactory的个体Object方法实例化bean。</p>
</li>
<li><p>加载单例后的处理方法调用。</p>
<p> 当bean加载结束后需要移除缓存中对该bean的正在加载状态的记录：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Singleton \'"</span> + beanName + <span class="string">"\' isn\'t currently in creation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">    Map var3 = <span class="keyword">this</span>.singletonObjects;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject != <span class="keyword">null</span>?singletonObject:NULL_OBJECT);</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回处理结果。</p>
<p> bean的加载逻辑其实是在传入的ObjectFactory类型的参数singletonFactory中定义的，反推参数的获取，得到如下代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(BeansException ex) &#123;</span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>ObjectFactory的核心部分其实只是调用了createBean的方法</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解读——容器体系</title>
    <url>/2012/02/22/spring-yuan-ma-jie-du-rong-qi-ti-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IoC和AOP是 Spring 提供的两个非常核心的概念，特别是 IoC 是建立起整个 Spring 架构的基础，Spring 提供了一个非常强大完整的容器体系，今天我们先看看整体体系结构的架构图：</p>
<p><img src="/images/pasted-7.png" alt="容器体系结构"></p>
<p>可以看到最顶层的是 BeanFactory ，往下有许多的针对不同场景的实现，分别是：</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BeanFactory</code></td>
<td>Spring的Bean容器最顶层的接口，定义了Ioc容器的基本规范。实现这个接口的Ioc容器都会持有一些BeanDefinition和一个唯一的字符串形式的名字。</td>
</tr>
<tr>
<td><code>HierarchicalBeanFactory</code></td>
<td>继承BeanFactory并扩展使其支持层级结构。getParentBeanFactory()方法或者父级BeanFactory，containsLocalBean(String name)方法查看当前BeanFactory是否包含给定名字的Bean，不会递归想父级查找。</td>
</tr>
<tr>
<td><code>ListableBeanFactory</code></td>
<td>同样扩展BeanFactory使其支持迭代Ioc容器持有的Bean对象。注意如果ListableBeanFactory同时也是HierarchicalBeanFactory，那么大多数情况下，只迭代当前Ioc容器持有的Bean对象，不会在体系结构中想父级递归迭代。具体情况请看API说明。</td>
</tr>
<tr>
<td><code>ResourceLoader</code></td>
<td>Spring提供资源的根接口。在Spring Ioc中，资源被Resource引用，获得Resource对象，说明获得了资源的访问。Resource提供资源的抽象，具体资源可是从URL，classpath,file等地方获得。</td>
</tr>
<tr>
<td><code>ResourcePatternResolver</code></td>
<td>ResourcePatternResolver是对ResourceLoader的扩展，其支持模式匹配的资源。如：classpath*:表示匹配路径下所有的资源。</td>
</tr>
<tr>
<td><code>DefaultResourceLoader</code></td>
<td>ResourceLoader的默认实现，可以单独使用，也可以通过扩展使其支持特殊的资源，如：FileSystemResourceLoader，ClassPathXmlApplicationContext等。</td>
</tr>
<tr>
<td><code>ApplicationEventPublisher</code></td>
<td>封装事件发布，通知事件监听者此Application的事件。 <code>MessageSource：</code>处理Spring 中的消息，支持i18n和参数化消息。另外其子类ReloadableResourceBundleMessageSource支持不重启JVM刷新消息。</td>
</tr>
<tr>
<td><code>EnvironmentCapable</code></td>
<td>实现此接口的容器将支持上下文环境。在Spring Ioc容器中，都是支持上下文环境的。</td>
</tr>
<tr>
<td><code>ApplicationContext</code></td>
<td>从上图来看，ApplicationContext继承了上面描述的所有接口，因此ApplicationContext是一个接口集合，提供所继承接口的功能。另外，ApplicationContext在启动后是只读的，但是如果ApplicationContext实现类支持reload，也可以刷新这个ApplicationContext。 <code>Lifecycle：</code>对BeanFactory提供生命周期支持。另外其他任何对象都可以实现Lifecycle接口开支持开始/结束控制。注意Lifecycle接口只支持顶层对象，其他的Lifecycle将被忽略。</td>
</tr>
<tr>
<td><code>DisposableBean</code></td>
<td>DisposableBean提供了在销毁Ioc容器的时候释放资源。</td>
</tr>
<tr>
<td><code>ConfigurableApplicationContext</code></td>
<td>提供对Ioc容器的配置的支持。包括设置父级容器，设置上下文环境，刷新容器，注册关闭容器钩子等。</td>
</tr>
<tr>
<td><code>AbstractApplicationContext</code></td>
<td>AbstractApplicationContext是Ioc容器的抽象实现，这里实现了大部分的功能：消息，事件，刷新容器，生命周期等。AbstractApplicationContext采用模板方法模式，把一部分实现推迟到子类。</td>
</tr>
<tr>
<td><code>AbstractRefreshableApplicationContext</code></td>
<td>提供多线程同时刷新容器支持，每次刷新都会产生一个内部BeanFactory(DefaultListableBeanFactory)。另外，子类要实现loadBeanDefinitions方法来正确加载Bean定义。</td>
</tr>
<tr>
<td><code>Aware</code></td>
<td>标记接口，实现这个接口的对象提供通知Spring容器功能。具体个通知动作来子类中定义。</td>
</tr>
<tr>
<td><code>BeanNameAware</code></td>
<td>Aware的子接口，当设置BeanName的时候，创建通知。</td>
</tr>
<tr>
<td><code>InitializingBean</code></td>
<td>这个接口作用是当Bean对象的属性都被设置完成或，可以立即做一些自定义的动作。令一个替代方案是设置init-method。</td>
</tr>
<tr>
<td><code>AbstractRefreshableConfigApplicationContext</code></td>
<td>提供对容器的一些特殊设置：setConfigLocation，setBeanName，setId等。</td>
</tr>
<tr>
<td><code>AbstractXmlApplicationContext</code></td>
<td>从XML读取Bean定义的容器，这个容器实现了loadBeanDefinitions方法，从XML资源中获得Bean定义。</td>
</tr>
<tr>
<td><code>FileSystemXmlApplicationContext</code></td>
<td>标准的从文件系统读XML的Bean定义容器。getResourceByPath方法返回文件系统资源。</td>
</tr>
</tbody>
</table>
<p>还有一个重量级的实现：<code>DefaultListableBeanFactory</code></p>
<p><code>DefaultListableBeanFactory</code>包含了Ioc容器的重要内容，很多容器都会用的它。如AbstractApplicationContext.refersh()方法就会销毁内部的容器并重新创建一个DefaultListableBeanFactory作为起内部表示。DefaultListableBeanFactory则直接继承它成为从XML读取资源的Ioc容器。</p>
<p>在DefaultListableBeanFactory有一个ConcurrentHashMap保存了Bean的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map of bean definition objects, keyed by bean name</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br></pre></td></tr></table></figure>
<p>DefaultListableBeanFactory的层级结构图如下所示：</p>
<p><img src="/images/pasted-8.png" alt="DefaultListableBeanFactory的层级结构图如下所示"></p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger2的集成</title>
    <url>/2016/01/07/swagger2-de-ji-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a><strong>1.概述</strong></h2><p>在创建REST API时，良好的文档能极大地提升对外交互的效率。同时，文档必须详细的记录API中的每个细节。这是一项繁琐的工作，好在已经有人提供了各类非常好的自动化工具，Swagger就是其中非常优秀的一款。</p>
<p>今天我们将看一下如何将<strong>Swagger 2集成到我们的 Spring REST 服务中</strong>在本文中，我们将使用Swagger 2规范的<strong>Springfox</strong>实现。</p>
<p>如果您不熟悉Swagger，在继续阅读本文之前，您可以到<a href="http://swagger.io/" target="_blank" rel="noopener">Swagger官方站点</a>了解一下（或者Google一些相关的简介，<strong>不</strong>推荐百度，你懂的）。</p>
<a id="more"></a>
<h2 id="2-添加Maven依赖项"><a href="#2-添加Maven依赖项" class="headerlink" title="2. 添加Maven依赖项"></a>2. 添加Maven依赖项</h2><p>如上所述，我们将使用Swagger规范的Springfox实现。最新版本可<a href="https://search.maven.org/classic/#search%7Cga%7C1%7C%22Springfox%20Swagger2%22" target="_blank" rel="noopener">在Maven Central</a>上找到  。</p>
<p>要将它添加到我们的Maven项目中，我们需要<em>pom.xml</em>文件中的依赖项。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-将Swagger-2集成到项目中"><a href="#3-将Swagger-2集成到项目中" class="headerlink" title="3. 将Swagger 2集成到项目中"></a>3. 将Swagger 2集成到项目中</h2><h3 id="3-1-Java配置"><a href="#3-1-Java配置" class="headerlink" title="3.1 Java配置"></a>3.1 Java配置</h3><p>Swagger的配置主要围绕<strong><em>Docket</em></strong> 来创建，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration</span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;                                    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)  </span><br><span class="line">          .select()                                  </span><br><span class="line">          .apis(RequestHandlerSelectors.any())              </span><br><span class="line">          .paths(PathSelectors.any())                          </span><br><span class="line">          .build();                                           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过@ EnableSwagger2注解启用Swagger 2 </strong></p>
<p>定义<em>Docket</em> bean 之后，其<em>select()</em>方法返回<em>ApiSelectorBuilder的</em>一个实例，它提供了一种控制Swagger公开的端点的方法。</p>
<p>可以在<em>RequestHandlerSelectors</em>和<em>PathSelectors</em>的帮助下配置选择<em>RequestHandler</em>的断言，示例中的<em>any()法</em>将通过Swagger提供整个API的文档。</p>
<p><strong>这种配置足以将Swagger 2集成到现有的Spring Boot项目中</strong>，对于其他Spring项目，需要进行一些额外的调整。</p>
<h3 id="3-2-非Spring-Boot环境下的配置"><a href="#3-2-非Spring-Boot环境下的配置" class="headerlink" title="3.2 非Spring Boot环境下的配置"></a>3.2 非Spring Boot环境下的配置</h3><p>如果你的项目中没有使用Spring Boot，Swagger UI添加了一组资源，您必须将这些资源配置为扩展<em>WebMvcConfigurerAdapter</em>的类的一部分，并使用<em>@EnableWebMvc</em>进行注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"swagger-ui.html"</span>)</span><br><span class="line">      .addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>);</span><br><span class="line"> </span><br><span class="line">    registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">      .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-验证"><a href="#3-3-验证" class="headerlink" title="3.3 验证"></a>3.3 验证</h3><p>要验证Springfox是否正常工作，您可以在浏览器中访问以下URL：</p>
<p><em>HTTP://本地主机:8080/demo/API/V1/API-文档</em></p>
<p>结果是具有大量键值对的JSON响应，当然，对于人来说，可读性还是太差，为此 Swagger 为此提供了<strong>Swagger UI</strong>。</p>
<h2 id="4-Swagger-UI"><a href="#4-Swagger-UI" class="headerlink" title="4. Swagger UI"></a>4. Swagger UI</h2><p>Swagger UI是一个内置的解决方案，使用户与Swagger生成的API文档的交互更加容易。</p>
<h3 id="4-1-启用Springfox的Swagger-UI"><a href="#4-1-启用Springfox的Swagger-UI" class="headerlink" title="4.1 启用Springfox的Swagger UI"></a>4.1 启用Springfox的Swagger UI</h3><p>要使用Swagger UI，需要一个额外的Maven依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在，您可以通过访问<em><a href="http://localhost:8080/your-app-root/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/your-app-root/swagger-ui.html</a></em> 在浏览器中对其进行测试。</p>
<p>结果应如下所示：</p>
<p><img src="/images/pasted-102.png" alt="upload successful"></p>
<h3 id="4-2-浏览-Swagger-文档"><a href="#4-2-浏览-Swagger-文档" class="headerlink" title="4.2 浏览 Swagger 文档"></a>4.2 浏览 Swagger 文档</h3><p>在Swagger中返回的是应用程序中定义<strong>的所有控制器的列表</strong>。单击其中任何一个将列出有效的HTTP方法（<em>DELETE</em>，<em>GET</em>，<em>HEAD</em>，<em>OPTIONS</em>，<em>PATCH</em>，<em>POST</em>，<em>PUT</em>）。</p>
<p>扩展每个方法可提供其他有用的数据，例如响应状态，内容类型和参数列表。也可以使用U提供的 <em>try</em> 功能去测试每种方法。</p>
<p>同时Swagger能与您的应用代码实时同步，动态地去获取你所有的 Controller 接口，比如我们添加一个新的 Controller ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/custom"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">custom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"custom"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果刷新Swagger文档，您将在控制器列表中看到<strong>CustomController</strong>。同时根据 <em>@RequestMapping(value = “/custom”, method = RequestMethod.POST)</em> 定义，Swagger的响应中只显示了一种方法（<em>POST</em>）。</p>
<h2 id="5-高级配置"><a href="#5-高级配置" class="headerlink" title="5. 高级配置"></a>5. 高级配置</h2><p>可以配置应用程序的<em>Docket</em> bean，以便更好地控制API文档生成过程。</p>
<h3 id="5-1-过滤Swagger响应的API"><a href="#5-1-过滤Swagger响应的API" class="headerlink" title="5.1 过滤Swagger响应的API"></a>5.1 过滤Swagger响应的API</h3><p>有时候你并不希望公开整个API的文档，那么您可以通过将参数传递给<em>Docket</em>类的<strong><em>apis()</em></strong>和<strong><em>paths()</em></strong>方法来限制Swagger的响应输出。</p>
<p>如上所示，<em>RequestHandlerSelectors</em>允许使用<em>any</em>或<em>none</em> 断言，但也可以用于根据基础包，类注解和方法注解过滤API。</p>
<p><strong><em>PathSelectors</em></strong>使用断言提供额外的过滤，这些断言扫描应用程序的请求路径。您可以使用 <em>any()</em>， <em>none()</em>，<em>regex()</em>或 <em>ant()</em>。</p>
<p>在下面的示例中，我们将使用<em>ant()</em>断言指示Swagger仅包含特定包中的控制器和特定路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)          </span><br><span class="line">      .select()                                       </span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.doleje.web.controller"</span>))</span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/foos/*"</span>))                     </span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-自定义信息"><a href="#5-2-自定义信息" class="headerlink" title="5.2 自定义信息"></a>5.2 自定义信息</h3><p>Swagger还在其响应中提供了一些默认值，您可以自定义它们，例如“Api文档”，“由联系人电子邮件创建”，“Apache 2.0”，要更改这些值，可以使用<strong>apiInfo（ApiInfo apiInfo）</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)          </span><br><span class="line">      .select()</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.example.controller"</span>))</span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/foos/*"</span>))</span><br><span class="line">      .build()</span><br><span class="line">      .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">      <span class="string">"My REST API"</span>, </span><br><span class="line">      <span class="string">"Some custom description of API."</span>, </span><br><span class="line">      <span class="string">"API TOS"</span>, </span><br><span class="line">      <span class="string">"Terms of service"</span>, </span><br><span class="line">      <span class="keyword">new</span> Contact(<span class="string">"John Doe"</span>, <span class="string">"www.example.com"</span>, <span class="string">"myeaddress@company.com"</span>), </span><br><span class="line">      <span class="string">"License of API"</span>, <span class="string">"API license URL"</span>, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-自定义方法响应消息"><a href="#5-3-自定义方法响应消息" class="headerlink" title="5.3 自定义方法响应消息"></a>5.3 自定义方法响应消息</h3><p>Swagger允许通过<em>Docket</em>的<strong>globalResponseMessage()</strong>方法<strong>全局覆盖HTTP方法的响应消息</strong>，要启用这个功能必须指示Swagger不要使用默认响应消息。</p>
<p>假设您希望覆盖所有<em>GET</em>方法的<strong>500</strong>和<strong>403</strong>响应消息。为此，必须将一些代码添加到<em>Docket</em>的初始化块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.useDefaultResponseMessages(<span class="keyword">false</span>)                                   </span><br><span class="line">.globalResponseMessage(RequestMethod.GET,                     </span><br><span class="line">  newArrayList(<span class="keyword">new</span> ResponseMessageBuilder()   </span><br><span class="line">    .code(<span class="number">500</span>)</span><br><span class="line">    .message(<span class="string">"500 message"</span>)</span><br><span class="line">    .responseModel(<span class="keyword">new</span> ModelRef(<span class="string">"Error"</span>))</span><br><span class="line">    .build(),</span><br><span class="line">    <span class="keyword">new</span> ResponseMessageBuilder() </span><br><span class="line">      .code(<span class="number">403</span>)</span><br><span class="line">      .message(<span class="string">"Forbidden!"</span>)</span><br><span class="line">      .build()));</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-103.png" alt="upload successful"></p>
<h2 id="6-使用OAuth保护的API-Swagger-UI"><a href="#6-使用OAuth保护的API-Swagger-UI" class="headerlink" title="6. 使用OAuth保护的API Swagger UI"></a>6. 使用OAuth保护的API Swagger UI</h2><p>Swagger UI提供了许多非常有用的功能。但是，如果我们的API受到保护且无法访问，我们就无法真正使用其中的大多数。实际上 Swagger 支持采用OAuth 来保护和授权我们API的安全。</p>
<p>我们将使用<em>SecurityScheme</em>和<em>SecurityContext</em>支持配置Swagger来访问我们的安全API ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).select()</span><br><span class="line">        .apis(RequestHandlerSelectors.any())</span><br><span class="line">        .paths(PathSelectors.any())</span><br><span class="line">        .build()</span><br><span class="line">        .securitySchemes(Arrays.asList(securityScheme()))</span><br><span class="line">        .securityContexts(Arrays.asList(securityContext()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-ecurity-Configuration"><a href="#6-1-ecurity-Configuration" class="headerlink" title="6.1 ecurity Configuration"></a>6.1 ecurity Configuration</h3><p>我们将在Swagger配置中定义一个<em>SecurityConfiguration</em> bean 并设置一些默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityConfiguration <span class="title">security</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SecurityConfigurationBuilder.builder()</span><br><span class="line">        .clientId(CLIENT_ID)</span><br><span class="line">        .clientSecret(CLIENT_SECRET)</span><br><span class="line">        .scopeSeparator(<span class="string">" "</span>)</span><br><span class="line">        .useBasicAuthenticationWithAccessCodeGrant(<span class="keyword">true</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-SecurityScheme"><a href="#6-2-SecurityScheme" class="headerlink" title="6.2 SecurityScheme"></a>6.2 SecurityScheme</h3><p>接下来，定义<em>SecurityScheme</em>，这用于描述我们的API如何受到保护（比如基本身份验证，OAuth2或等 ）。代码如下所示（这里要用到 OAuth 的相关技术，大家可以参考我其它的关于 SpringSecurity OAuth 的博客）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SecurityScheme <span class="title">securityScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GrantType grantType = <span class="keyword">new</span> AuthorizationCodeGrantBuilder()</span><br><span class="line">        .tokenEndpoint(<span class="keyword">new</span> TokenEndpoint(AUTH_SERVER + <span class="string">"/token"</span>, <span class="string">"oauthtoken"</span>))</span><br><span class="line">        .tokenRequestEndpoint(</span><br><span class="line">          <span class="keyword">new</span> TokenRequestEndpoint(AUTH_SERVER + <span class="string">"/authorize"</span>, CLIENT_ID, CLIENT_ID))</span><br><span class="line">        .build();</span><br><span class="line"> </span><br><span class="line">    SecurityScheme oauth = <span class="keyword">new</span> OAuthBuilder().name(<span class="string">"spring_oauth"</span>)</span><br><span class="line">        .grantTypes(Arrays.asList(grantType))</span><br><span class="line">        .scopes(Arrays.asList(scopes()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> oauth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，我们使用了授权代码授权类型 - 我们需要为其提供令牌端点和OAuth2授权服务器的授权URL。以下是我们需要定义的范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AuthorizationScope[] scopes() &#123;</span><br><span class="line">    AuthorizationScope[] scopes = &#123; </span><br><span class="line">      <span class="keyword">new</span> AuthorizationScope(<span class="string">"read"</span>, <span class="string">"for read operations"</span>), </span><br><span class="line">      <span class="keyword">new</span> AuthorizationScope(<span class="string">"write"</span>, <span class="string">"for write operations"</span>), </span><br><span class="line">      <span class="keyword">new</span> AuthorizationScope(<span class="string">"foo"</span>, <span class="string">"Access foo API"</span>) &#125;;</span><br><span class="line">    <span class="keyword">return</span> scopes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些与<em>/ foos</em> API 在我们的应用程序中实际定义的范围保持一致。</p>
<h3 id="6-3-Security-Context"><a href="#6-3-Security-Context" class="headerlink" title="6.3 Security Context"></a>6.3 Security Context</h3><p>最后，我们需要为示例API定义安全上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SecurityContext <span class="title">securityContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SecurityContext.builder()</span><br><span class="line">      .securityReferences(</span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> SecurityReference(<span class="string">"spring_oauth"</span>, scopes())))</span><br><span class="line">      .forPaths(PathSelectors.regex(<span class="string">"/foos.*"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意我们在这里使用的名称 - <em>spring_oauth</em> - 与<em>SecurityScheme中</em>我们之前使用的名称保持一致。</p>
<h3 id="6-4-测试"><a href="#6-4-测试" class="headerlink" title="6.4 测试"></a>6.4 测试</h3><p>好了，现在我们已经准备好了所有内容，让我们看看我们的Swagger UI并尝试访问Foo API：</p>
<p>我们可以在本地访问Swagger UI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8082/spring-security-oauth-resource/swagger-ui.html</span><br></pre></td></tr></table></figure>
<p>我们可以看到由于我们的安全配置，现在存在一个新的“Authorize”按钮：</p>
<p><img src="/images/pasted-104.png" alt="upload successful"></p>
<p>当我们点击“Authorize”按钮时，我们可以看到以下弹出窗口 - 授权我们的Swagger UI访问安全API：</p>
<p><img src="/images/pasted-105.png" alt="upload successful"></p>
<p>注意：</p>
<ul>
<li>我们已经可以看到CLIENT_ID和CLIENT_SECRET - 因为我们之前已经预先配置了它们（但我们仍然可以更改它们）</li>
<li>我们现在可以选择我们需要的范围</li>
</ul>
<p>如下图所示受保护的API标记：</p>
<p><img src="/images/pasted-106.png" alt="upload successful"></p>
<p>现在，最后，我们可以点击我们的API！</p>
]]></content>
      <tags>
        <tag>Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解读——MVC</title>
    <url>/2012/03/02/spring-yuan-ma-jie-du-mvc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面我们对Spring MVC框架代码进行分析,对于webApplicationContext的相关分析可以参见以前的文档，我们这里着重分析Spring Web MVC框架的实现.我们从分析DispatcherServlet入手：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是对DispatcherServlet的初始化方法，根据名字我们很方面的看到对各个Spring MVC主要元素的初始化  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFrameworkServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException, BeansException </span>&#123;  </span><br><span class="line">    initMultipartResolver();  </span><br><span class="line">    initLocaleResolver();  </span><br><span class="line">    initThemeResolver();  </span><br><span class="line">    initHandlerMappings();  </span><br><span class="line">    initHandlerAdapters();  </span><br><span class="line">    initHandlerExceptionResolvers();  </span><br><span class="line">    initRequestToViewNameTranslator();  </span><br><span class="line">    initViewResolvers();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到注解我们知道，这是DispatcherSerlvet的初始化过程，它是在WebApplicationContext已经存在的情况下进行的，也就意味着在初始化它的时候，IOC容器应该已经工作了，这也是我们在web.xml中配置Spring的时候，需要把DispatcherServlet的 load-on-startup的属性配置为2的原因。<br>对于具体的初始化过程，很容易理解，我们拿initHandlerMappings（）来看看：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;  </span><br><span class="line">         <span class="comment">// 这里找到所有在上下文中定义的HandlerMapping,同时把他们排序  </span></span><br><span class="line">         <span class="comment">// 因为在同一个上下文中可以有不止一个handlerMapping,所以我们把他们都载入到一个链里进行维护和管理  </span></span><br><span class="line">        Map matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(  </span><br><span class="line">                getWebApplicationContext(), HandlerMapping<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;  </span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList(matchingBeans.values());  </span><br><span class="line">            <span class="comment">// 这里通过order属性来对handlerMapping来在list中排序  </span></span><br><span class="line">            Collections.sort(<span class="keyword">this</span>.handlerMappings, <span class="keyword">new</span> OrderComparator());  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Object hm = getWebApplicationContext().getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;  </span><br><span class="line">            <span class="comment">// Ignore, we'll add a default HandlerMapping later.  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果在上下文中没有定义的话，那么我们使用默认的BeanNameUrlHandlerMapping  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(HandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">    ........  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎样获得上下文环境，可以参见我们前面的对IOC容器在web环境中加载的分析。 DispatcherServlet把定义了的所有HandlerMapping都加载了放在一个List里待以后进行使用,这个链的每一个元素都是一个handlerMapping的配置，而一般每一个handlerMapping可以持有一系列从URL请求到 Spring Controller的映射，比如SimpleUrl<br>HandlerMaaping中就定义了一个map来持有这一系列的映射关系。<br>DisptcherServlet通过HandlerMapping使得Web应用程序确定一个执行路径，就像我们在HanderMapping中看到的那样，HandlerMapping只是一个借口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE =  </span><br><span class="line">                    Conventions.getQualifiedAttributeName(HandlerMapping.class, "pathWithinHandlerMapping");  </span><br><span class="line">      <span class="comment">//实际上维护一个HandlerExecutionChain,这是典型的Command的模式的使用，这个执行链里面维护handler和拦截器  </span></span><br><span class="line">    <span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他的具体实现只需要实现一个接口方法，而这个接口方法返回的是一个HandlerExecutionChain,实际上就是一个执行链，就像在Command模式描述的那样，这个类很简单，就是一个持有一个Interceptor链和一个Controller：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Object handler;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;  </span><br><span class="line">     </span><br><span class="line">    ........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而这些Handler和Interceptor需要我们定义HandlerMapping的时候配置好，比如对具体的 SimpleURLHandlerMapping,他要做的就是根据URL映射的方式注册Handler和Interceptor，自己维护一个放映映射的handlerMap，当需要匹配Http请求的时候需要使用这个表里的信息来得到执行链。这个注册的过程在IOC容器初始化 SimpleUrlHandlerMapping的时候就被完成了，这样以后的解析才可以用到map里的映射信息，这里的信息和bean文件的信息是等价的，下面是具体的注册过程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">(Map urlMap)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (urlMap.isEmpty()) &#123;  </span><br><span class="line">        logger.warn(<span class="string">"Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//这里迭代在SimpleUrlHandlerMapping中定义的所有映射元素  </span></span><br><span class="line">        Iterator it = urlMap.keySet().iterator();  </span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">            <span class="comment">//这里取得配置的url  </span></span><br><span class="line">            String url = (String) it.next();  </span><br><span class="line">            <span class="comment">//这里根据url在bean定义中取得对应的handler  </span></span><br><span class="line">            Object handler = urlMap.get(url);  </span><br><span class="line">            <span class="comment">// Prepend with slash if not already present.  </span></span><br><span class="line">            <span class="keyword">if</span> (!url.startsWith(<span class="string">"/"</span>)) &#123;  </span><br><span class="line">                url = <span class="string">"/"</span> + url;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里调用AbstractHandlerMapping中的注册过程  </span></span><br><span class="line">            registerHandler(url, handler);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在AbstractMappingHandler中的注册代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;  </span><br><span class="line">    <span class="comment">//试图从handlerMap中取handler,看看是否已经存在同样的Url映射关系  </span></span><br><span class="line">    Object mappedHandler = <span class="keyword">this</span>.handlerMap.get(urlPath);  </span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;  </span><br><span class="line">    ........  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果是直接用bean名做映射那就直接从容器中取handler  </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;  </span><br><span class="line">        String handlerName = (String) handler;  </span><br><span class="line">        <span class="keyword">if</span> (getApplicationContext().isSingleton(handlerName)) &#123;  </span><br><span class="line">            handler = getApplicationContext().getBean(handlerName);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者使用默认的handler.  </span></span><br><span class="line">    <span class="keyword">if</span> (urlPath.equals(<span class="string">"/*"</span>)) &#123;  </span><br><span class="line">        setDefaultHandler(handler);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="comment">//把url和handler的对应关系放到handlerMap中去  </span></span><br><span class="line">        <span class="keyword">this</span>.handlerMap.put(urlPath, handler);  </span><br><span class="line">        ........  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>handlerMap是持有的一个HashMap,里面就保存了具体的映射信息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map handlerMap = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure></p>
<p>而SimpleUrlHandlerMapping对接口HandlerMapping的实现是这样的，这个getHandler根据在初始化的时候就得到的映射表来生成DispatcherServlet需要的执行链<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    <span class="comment">//这里根据request中的参数得到其对应的handler,具体处理在AbstractUrlHandlerMapping中  </span></span><br><span class="line">    Object handler = getHandlerInternal(request);  </span><br><span class="line">    <span class="comment">//如果找不到对应的，就使用缺省的handler  </span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        handler = <span class="keyword">this</span>.defaultHandler;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果缺省的也没有，那就没办法了  </span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果handler不是一个具体的handler,那我们还要到上下文中取  </span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;  </span><br><span class="line">        String handlerName = (String) handler;  </span><br><span class="line">        handler = getApplicationContext().getBean(handlerName);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成一个HandlerExecutionChain,其中放了我们匹配上的handler和定义好的拦截器，就像我们在HandlerExecutionChain中看到的那样，它持有一个handler和一个拦截器组。  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HandlerExecutionChain(handler, <span class="keyword">this</span>.adaptedInterceptors);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看看具体的handler查找过程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    <span class="comment">//这里的HTTP Request传进来的参数进行分析，得到具体的路径信息。  </span></span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);  </span><br><span class="line">    .......<span class="comment">//下面是根据请求信息的查找  </span></span><br><span class="line">    <span class="keyword">return</span> lookupHandler(lookupPath, request);  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果能够直接能在SimpleUrlHandlerMapping的映射表中找到，那最好。  </span></span><br><span class="line">    Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);  </span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 这里使用模式来对map中的所有handler进行匹配，调用了Jre中的Matcher类来完成匹配处理。  </span></span><br><span class="line">        String bestPathMatch = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">for</span> (Iterator it = <span class="keyword">this</span>.handlerMap.keySet().iterator(); it.hasNext();) &#123;  </span><br><span class="line">            String registeredPath = (String) it.next();  </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.pathMatcher.match(registeredPath, urlPath) &amp;&amp;  </span><br><span class="line">                            (bestPathMatch == <span class="keyword">null</span> || bestPathMatch.length() &lt;= registeredPath.length())) &#123;  </span><br><span class="line">                <span class="comment">//这里根据匹配路径找到最象的一个  </span></span><br><span class="line">                handler = <span class="keyword">this</span>.handlerMap.get(registeredPath);  </span><br><span class="line">                bestPathMatch = registeredPath;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            exposePathWithinMapping(<span class="keyword">this</span>.pathMatcher.extractPathWithinPattern(bestPathMatch, urlPath), request);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        exposePathWithinMapping(urlPath, request);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  </span></span><br><span class="line">    <span class="keyword">return</span> handler;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，总是在handlerMap这个HashMap中找，当然如果直接找到最好，如果找不到，就看看是不是能通过Match Pattern的模式找，我们一定还记得在配置HnaderMapping的时候是可以通过ANT语法进行配置的，其中的处理就在这里。<br>这样可以清楚地看到整个HandlerMapping的初始化过程 - 同时，我们也看到了一个具体的handler映射是怎样被存储和查找的 - 这里生成一个ExecutionChain来储存我们找到的handler和在定义bean的时候定义的Interceptors.<br>让我们回到DispatcherServlet，初始化完成以后，实际的对web请求是在doService()方法中处理的，我们知道DispatcherServlet只是一个普通的Servlet:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    .......  </span><br><span class="line">    <span class="comment">//这里把属性信息进行保存  </span></span><br><span class="line">    Map attributesSnapshot = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;  </span><br><span class="line">        logger.debug(<span class="string">"Taking snapshot of request attributes before include"</span>);  </span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap();  </span><br><span class="line">        Enumeration attrNames = request.getAttributeNames();  </span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;  </span><br><span class="line">            String attrName = (String) attrNames.nextElement();  </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DispatcherServlet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;  </span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.  </span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());  </span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);  </span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);  </span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="comment">//这里使实际的处理入口  </span></span><br><span class="line">        doDispatch(request, response);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="comment">// Restore the original attribute snapshot, in case of an include.  </span></span><br><span class="line">        <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            restoreAttributesAfterInclude(request, attributesSnapshot);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到，对于请求的处理实际上是让doDispatch()来完成的 - 这个方法很长，但是过程很简单明了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(<span class="keyword">final</span> HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    HttpServletRequest processedRequest = request;  </span><br><span class="line">    <span class="comment">//这是从handlerMapping中得到的执行链  </span></span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;  </span><br><span class="line">     </span><br><span class="line">    ........  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">//我们熟悉的ModelAndView开始出现了。  </span></span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            processedRequest = checkMultipart(request);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 这是我们得到handler的过程  </span></span><br><span class="line">            mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                noHandlerFound(processedRequest, response);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 这里取出执行链中的Interceptor进行前处理  </span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler.getInterceptors() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappedHandler.getInterceptors().length; i++) &#123;  </span><br><span class="line">                    HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];  </span><br><span class="line">                    <span class="keyword">if</span> (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) &#123;  </span><br><span class="line">                        triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, <span class="keyword">null</span>);  </span><br><span class="line">                        <span class="keyword">return</span>;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    interceptorIndex = i;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//在执行handler之前，用HandlerAdapter先检查一下handler的合法性：是不是按Spring的要求编写的。  </span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());  </span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 这里取出执行链中的Interceptor进行后处理  </span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler.getInterceptors() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = mappedHandler.getInterceptors().length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">                    HandlerInterceptor interceptor = mappedHandler.getInterceptors()[i];  </span><br><span class="line">                    interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        ........  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Did the handler return a view to render?  </span></span><br><span class="line">        <span class="comment">//这里对视图生成进行处理  </span></span><br><span class="line">        <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;  </span><br><span class="line">            render(mv, processedRequest, response);  </span><br><span class="line">        &#125;</span><br><span class="line">        .......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们很清楚的看到和MVC框架紧密相关的代码,比如如何得到和http请求相对应的执行链，怎样执行执行链和怎样把模型数据展现到视图中去。<br>先看怎样取得Command对象，对我们来说就是Handler - 下面是getHandler的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request, <span class="keyword">boolean</span> cache)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">  <span class="comment">//在ServletContext取得执行链 - 实际上第一次得到它的时候，我们把它放在ServletContext进行了缓存。  </span></span><br><span class="line">  HandlerExecutionChain handler =  </span><br><span class="line">            (HandlerExecutionChain) request.getAttribute(HANDLER_EXECUTION_CHAIN_ATTRIBUTE);  </span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!cache) &#123;  </span><br><span class="line">            request.removeAttribute(HANDLER_EXECUTION_CHAIN_ATTRIBUTE);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的迭代器迭代的时在initHandlerMapping中载入的上下文所有的HandlerMapping  </span></span><br><span class="line">    Iterator it = <span class="keyword">this</span>.handlerMappings.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">        HandlerMapping hm = (HandlerMapping) it.next();  </span><br><span class="line">        .......  </span><br><span class="line">        <span class="comment">//这里是实际取得handler的过程,在每个HandlerMapping中建立的映射表进行检索得到请求对应的handler  </span></span><br><span class="line">        handler = hm.getHandler(request);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//然后把handler存到ServletContext中去进行缓存  </span></span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (cache) &#123;  </span><br><span class="line">                request.setAttribute(HANDLER_EXECUTION_CHAIN_ATTRIBUTE, handler);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在ServletContext中可以取得handler则直接返回，实际上这个handler是缓冲了上次处理的结果 - 总要有第一次把这个handler放到ServletContext中去：<br>如果在ServletContext中找不到handler,那就通过持有的handlerMapping生成一个，我们看到它会迭代当前持有的所有的 handlerMapping,因为可以定义不止一个，他们在定义的时候也可以指定顺序，直到找到第一个，然后返回。先找到一个 handlerMapping,然后通过这个handlerMapping返回一个执行链，里面包含了最终的Handler和我们定义的一连串的 Interceptor。具体的我们可以参考上面的SimpleUrlHandlerMapping的代码分析知道getHandler是怎样得到一个 HandlerExecutionChain的。<br>得到HandlerExecutionChain以后，我们通过HandlerAdapter对这个Handler的合法性进行判断：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;  </span><br><span class="line">    Iterator it = <span class="keyword">this</span>.handlerAdapters.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">        <span class="comment">//同样对持有的所有adapter进行匹配  </span></span><br><span class="line">        HandlerAdapter ha = (HandlerAdapter) it.next();  </span><br><span class="line">        <span class="keyword">if</span> (ha.supports(handler)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> ha;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过判断，我们知道这个handler是不是一个Controller接口的实现，比如对于具体的HandlerAdapter - SimpleControllerHandlerAdapter:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);  </span><br><span class="line">    &#125;</span><br><span class="line">    .......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的判断一下handler是不是实现了Controller接口。这也体现了一种对配置文件进行验证的机制。<br>让我们再回到DispatcherServlet看到代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  </span><br><span class="line"></span><br><span class="line">这个就是对handle的具体调用！相当于Command模式里的Command.execute();理所当然的返回一个ModelAndView，下面就是一个对View进行处理的过程： </span><br><span class="line">```java</span><br><span class="line"><span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;  </span><br><span class="line">    render(mv, processedRequest, response);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的是render方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> Exception </span>&#123;response.setLocale(locale);  </span><br><span class="line">  </span><br><span class="line">     View view = <span class="keyword">null</span>;  </span><br><span class="line">     <span class="comment">//这里把默认的视图放到ModelAndView中去。  </span></span><br><span class="line">     <span class="keyword">if</span> (!mv.hasView()) &#123;  </span><br><span class="line">         mv.setViewName(getDefaultViewName(request));  </span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">if</span> (mv.isReference()) &#123;  </span><br><span class="line">         <span class="comment">// 这里对视图名字进行解析  </span></span><br><span class="line">         view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);  </span><br><span class="line">     .......  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;  </span><br><span class="line">         <span class="comment">// 有可能在ModelAndView里已经直接包含了View对象，那我们就直接使用。  </span></span><br><span class="line">         view = mv.getView();  </span><br><span class="line">     ........  </span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">//得到具体的View对象以后，我们用它来生成视图。  </span></span><br><span class="line">     view.render(mv.getModelInternal(), request, response);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>从整个过程我们看到先在ModelAndView中寻找视图的逻辑名，如果找不到那就使用缺省的视图，如果能够找到视图的名字，那就对他进行解析得到实际的需要使用的视图对象。还有一种可能就是在ModelAndView中已经包含了实际的视图对象，这个视图对象是可以直接使用的。<br>不管怎样，得到一个视图对象以后，通过调用视图对象的render来完成数据的显示过程，我们可以看看具体的JstlView是怎样实现的，我们在JstlView的抽象父类 AbstractView中找到render方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">    <span class="comment">// 这里把所有的相关信息都收集到一个Map里  </span></span><br><span class="line">    Map mergedModel = <span class="keyword">new</span> HashMap(<span class="keyword">this</span>.staticAttributes.size() + (model != <span class="keyword">null</span> ? model.size() : <span class="number">0</span>));  </span><br><span class="line">    mergedModel.putAll(<span class="keyword">this</span>.staticAttributes);  </span><br><span class="line">    <span class="keyword">if</span> (model != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        mergedModel.putAll(model);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Expose RequestContext?  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.requestContextAttribute != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        mergedModel.put(<span class="keyword">this</span>.requestContextAttribute, createRequestContext(request, mergedModel));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是实际的展现模型数据到视图的调用。  </span></span><br><span class="line">    renderMergedOutputModel(mergedModel, request, response);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解写的很清楚了，先把所有的数据模型进行整合放到一个Map - mergedModel里，然后调用renderMergedOutputModel();这个renderMergedOutputModel是一个模板方法，他的实现在InternalResourceView也就是JstlView的父类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">       Map model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Expose the model object as request attributes.  </span></span><br><span class="line">   exposeModelAsRequestAttributes(model, request);  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Expose helpers as request attributes, if any.  </span></span><br><span class="line">   exposeHelpers(request);  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里得到InternalResource定义的内部资源路径。  </span></span><br><span class="line">   String dispatcherPath = prepareForRendering(request, response);  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">//这里把请求转发到前面得到的内部资源路径中去。  </span></span><br><span class="line">   RequestDispatcher rd = request.getRequestDispatcher(dispatcherPath);  </span><br><span class="line">   <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(  </span><br><span class="line">               <span class="string">"Could not get RequestDispatcher for ["</span> + getUrl() + <span class="string">"]: check that this file exists within your WAR"</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">   .......</span><br></pre></td></tr></table></figure></p>
<p>首先对模型数据进行处理，exposeModelAsRequestAttributes是在AbstractView中实现的，这个方法把 ModelAndView中的模型数据和其他request数据统统放到ServletContext当中去，这样整个模型数据就通过 ServletContext暴露并得到共享使用了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exposeModelAsRequestAttributes</span><span class="params">(Map model, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      Iterator it = model.entrySet().iterator();  </span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">          Map.Entry entry = (Map.Entry) it.next();  </span><br><span class="line">          ..........  </span><br><span class="line">          String modelName = (String) entry.getKey();  </span><br><span class="line">          Object modelValue = entry.getValue();  </span><br><span class="line">          <span class="keyword">if</span> (modelValue != <span class="keyword">null</span>) &#123;  </span><br><span class="line">              request.setAttribute(modelName, modelValue);  </span><br><span class="line">          ...........  </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;  </span><br><span class="line">              request.removeAttribute(modelName);  </span><br><span class="line">              .......  </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们回到数据处理部分的exposeHelper();这是一个模板方法，其实现在JstlView中实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JstlView</span> <span class="keyword">extends</span> <span class="title">InternalResourceView</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> MessageSource jstlAwareMessageSource;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.initApplicationContext();  </span><br><span class="line">        <span class="keyword">this</span>.jstlAwareMessageSource =  </span><br><span class="line">                JstlUtils.getJstlAwareMessageSource(getServletContext(), getApplicationContext());  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exposeHelpers</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        JstlUtils.exposeLocalizationContext(request, <span class="keyword">this</span>.jstlAwareMessageSource);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在JstlUtils中包含了对于其他而言jstl特殊的数据处理和设置。<br>过程是不是很长？我们现在在哪里了？呵呵，我们刚刚完成的事MVC中View的render，对于InternalResourceView的render 过程比较简单只是完成一个资源的重定向处理。需要做的就是得到实际view的internalResource路径，然后转发到那个资源中去。怎样得到资源的路径呢通过调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">prepareForRendering</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> getUrl();</span><br></pre></td></tr></table></figure></p>
<p>那这个url在哪里生成呢？我们在View相关的代码中没有找到，实际上，他在ViewRosolve的时候就生成了，在UrlBasedViewResolver中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(getViewClass());  </span><br><span class="line">    view.setUrl(getPrefix() + viewName + getSuffix());  </span><br><span class="line">    String contentType = getContentType();  </span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        view.setContentType(contentType);  </span><br><span class="line">    &#125;</span><br><span class="line">    view.setRequestContextAttribute(getRequestContextAttribute());  </span><br><span class="line">    view.setAttributesMap(getAttributesMap());  </span><br><span class="line">    <span class="keyword">return</span> view;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是生成View的地方，自然也把生成的url和其他一些和view相关的属性也配置好了。<br>那这个ViewResolve是什么时候被调用的呢？哈哈，我们这样又要回到DispatcherServlet中去看看究竟，在DispatcherServlet中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">  </span><br><span class="line">     ........  </span><br><span class="line">     View view = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 这里设置视图名为默认的名字  </span></span><br><span class="line">     <span class="keyword">if</span> (!mv.hasView()) &#123;  </span><br><span class="line">         mv.setViewName(getDefaultViewName(request));  </span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">if</span> (mv.isReference()) &#123;  </span><br><span class="line">         <span class="comment">//这里对视图名进行解析，在解析的过程中根据需要生成实际需要的视图对象。  </span></span><br><span class="line">         view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);  </span><br><span class="line">        ..........  </span><br><span class="line">     &#125;</span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是对视图名进行解析的具体过程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, Map model, Locale locale, HttpServletRequest request)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">         <span class="comment">//我们有可能不止一个视图解析器  </span></span><br><span class="line">        <span class="keyword">for</span> (Iterator it = <span class="keyword">this</span>.viewResolvers.iterator(); it.hasNext();) &#123;  </span><br><span class="line">            ViewResolver viewResolver = (ViewResolver) it.next();  </span><br><span class="line">            <span class="comment">//这里是视图解析器进行解析并生成视图的过程。  </span></span><br><span class="line">            View view = viewResolver.resolveViewName(viewName, locale);  </span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> view;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用具体的ViewResolver对视图的名字进行解析 - 除了单纯的解析之外，它还根据我们的要求生成了我们实际需要的视图对象。具体的viewResolver在bean定义文件中进行定义同时在 initViewResolver()方法中被初始化到viewResolver变量中，我们看看具体的 InternalResourceViewResolver是怎样对视图名进行处理的并生成V视图对象的：对resolveViewName的调用模板在 AbstractCachingViewResolver中,<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    <span class="comment">//如果没有打开缓存设置，那创建需要的视图  </span></span><br><span class="line">    <span class="keyword">if</span> (!isCache()) &#123;  </span><br><span class="line">        logger.warn(<span class="string">"View caching is SWITCHED OFF -- DEVELOPMENT SETTING ONLY: This can severely impair performance"</span>);  </span><br><span class="line">        <span class="keyword">return</span> createView(viewName, locale);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        Object cacheKey = getCacheKey(viewName, locale);  </span><br><span class="line">        <span class="comment">// No synchronization, as we can live with occasional double caching.  </span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.viewCache) &#123;  </span><br><span class="line">            <span class="comment">//这里查找缓存里的视图对象  </span></span><br><span class="line">            View view = (View) <span class="keyword">this</span>.viewCache.get(cacheKey);  </span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">//如果在缓存中没有找到，创建一个并把创建的放到缓存中去  </span></span><br><span class="line">                view = createView(viewName, locale);  </span><br><span class="line">                <span class="keyword">this</span>.viewCache.put(cacheKey, view);  </span><br><span class="line">            ........  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> view;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于这些createView(),loadView(),buildView()的关系，我们看看Eclipse里的call hiearchy<br>然后我们回到view.render中完成数据的最终对httpResponse的写入，比如在AbstractExcelView中的实现:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        Map model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    .........  </span><br><span class="line">    <span class="comment">// response.setContentLength(workbook.getBytes().length);  </span></span><br><span class="line">    response.setContentType(getContentType());  </span><br><span class="line">    ServletOutputStream out = response.getOutputStream();  </span><br><span class="line">    workbook.write(out);  </span><br><span class="line">    out.flush();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就和我们前面的分析一致起来了:DispatcherServlet在解析视图名的时候就根据要求生成了视图对象,包括在InternalResourceView中需要使用的url和其他各种和HTTP response相关的属性都会写保持在生成的视图对象中，然后就直接调用视图对象的render来完成数据的展示。<br>这就是整个Spring Web MVC框架的大致流程，整个MVC流程由DispatcherServlet来控制。MVC的关键过程包括：<br>配置到handler的映射关系和怎样根据请求参数得到对应的handler,在Spring中，这是由handlerMapping通过执行链来完成的，而具体的映射关系我们在bean定义文件中定义并在HandlerMapping载入上下文的时候就被配置好了。然后 DispatcherServlet调用HandlerMapping来得到对应的执行链，最后通过视图来展现模型数据，但我们要注意的是视图对象是在解析视图名的时候生成配置好的。这些作为核心类的HanderMapping,ViewResolver,View,Handler的紧密协作实现了MVC的功能。 </p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring和Hibernate的自定义审计</title>
    <url>/2016/02/09/spring-he-hibernate-de-zi-ding-yi-shen-ji/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>通常我们在应用中会需要对于数据库的操作进行日志的审计，以保存当时的数据操作者及时间等相关信息，为今后的数据变化跟踪作铺垫，在需要时可以追踪到具体修改数据的人。这个时候可以使用<a href="http://hibernate.org/orm/envers/" target="_blank" rel="noopener">Envers</a>或<a href="http://docs.spring.io/spring-data/jpa/docs/1.10.2.RELEASE/reference/html/#auditing" target="_blank" rel="noopener">spring数据jpa审计</a>，我的这篇博客记录了一些常用的<a href="/2016/04/19/spring-cache-xing-neng-fen-xi/">JPA,Hibernate及SpringDataJPA 的审计</a>方案。如果由于某些原因你不能使用Envers和Spring JPA的审计，那么还有一个方法，就是实现与hibernate事件监听器，并和spring事务资源同步进行绑定，然后在事务提交的时候进行处理。</p>
<a id="more"></a>
<h2 id="2-事件监听"><a href="#2-事件监听" class="headerlink" title="2. 事件监听"></a>2. 事件监听</h2><p>首先，从事件监听器开始。捕获所有插入，更新和删除操作。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditLogEventListener</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">PostUpdateEventListener</span>, <span class="title">PostInsertEventListener</span>, <span class="title">PostDeleteEventListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostDelete</span><span class="params">(PostDeleteEvent event)</span> </span>&#123;</span><br><span class="line">        AuditedEntity audited = event.getEntity().getClass().getAnnotation(AuditedEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (audited != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AuditLogServiceData.getHibernateEvents().add(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostInsert</span><span class="params">(PostInsertEvent event)</span> </span>&#123;</span><br><span class="line">        AuditedEntity audited = event.getEntity().getClass().getAnnotation(AuditedEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (audited != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AuditLogServiceData.getHibernateEvents().add(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostUpdate</span><span class="params">(PostUpdateEvent event)</span> </span>&#123;</span><br><span class="line">        AuditedEntity audited = event.getEntity().getClass().getAnnotation(AuditedEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (audited != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AuditLogServiceData.getHibernateEvents().add(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requiresPostCommitHanding</span><span class="params">(EntityPersister persister)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Envers sets this to true only if the entity is versioned. So figure out for yourself if that's needed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意<code>AuditedEntity</code>- 它是一个自定义标记注解（retention = runtime，target = type），注解在实体类上，用来标识这个实体是需要被审计的。</p>
<h2 id="3-事务绑定"><a href="#3-事务绑定" class="headerlink" title="3. 事务绑定"></a>3. 事务绑定</h2><p>同时，在捕获到这些事件后，将事件信息填充到 <em><code>AuditLogServiceData</code></em> 中去，<em><code>AuditLogServiceData</code></em> 是我们自己定义的一个数据结构，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditLogServiceData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HIBERNATE_EVENTS = <span class="string">"hibernateEvents"</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title">getHibernateEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TransactionSynchronizationManager.hasResource(HIBERNATE_EVENTS)) &#123;</span><br><span class="line">            TransactionSynchronizationManager.bindResource(HIBERNATE_EVENTS, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;Object&gt;) TransactionSynchronizationManager.getResource(HIBERNATE_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getActorId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Long) TransactionSynchronizationManager.getResource(AUDIT_LOG_ACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setActor</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TransactionSynchronizationManager.bindResource(AUDIT_LOG_ACTOR, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// unbind all resources</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了存储事件之外，我们还需要存储正在执行操作的用户。为了得到它，我们需要提供一个方法参数级注解来指定一个参数。我的案例中的注解被称为<code>AuditLogActor</code>（retention = runtime，type = parameter）。</p>
<p>这里模拟了 <em><code>OpenSessionInViewInterceptor</code></em> 的实现方式，将这些事件及操作者信息绑定到当前的事务上，这样就可以在进行事务提交的时候获取到这些事件及操作者的相关信息，并填充到审计字段上。</p>
<h2 id="4-事件拦截与审计处理"><a href="#4-事件拦截与审计处理" class="headerlink" title="4. 事件拦截与审计处理"></a>4. 事件拦截与审计处理</h2><p>现在剩下的是处理事件的代码。我们希望在提交当前事务之前执行此操作。如果事务在提交时失败，则审计条目插入也将失败。我们用一点AOP来做到这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuditLogStoringAspect</span> <span class="keyword">extends</span> <span class="title">TransactionSynchronizationAdapter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx; </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* *.*(..)) &amp;&amp; @annotation(transactional)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerTransactionSyncrhonization</span><span class="params">(JoinPoint jp, Transactional transactional)</span> </span>&#123;</span><br><span class="line">        Logger.log(<span class="keyword">this</span>).debug(<span class="string">"Registering audit log tx callback"</span>);</span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(<span class="keyword">this</span>);</span><br><span class="line">        MethodSignature signature = (MethodSignature) jp.getSignature();</span><br><span class="line">        <span class="keyword">int</span> paramIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取参数列表中注解了 AuditLogActor 的参数，来作为操作者信息保存在 AuditLogServiceData 中</span></span><br><span class="line">        <span class="keyword">for</span> (Parameter param : signature.getMethod().getParameters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (param.isAnnotationPresent(AuditLogActor<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                AuditLogServiceData.setActor((Long) jp.getArgs()[paramIdx]);</span><br><span class="line">            &#125;</span><br><span class="line">            paramIdx ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCommit</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> </span>&#123;</span><br><span class="line">        Logger.log(<span class="keyword">this</span>).debug(<span class="string">"tx callback invoked. Readonly= "</span> + readOnly);</span><br><span class="line">        <span class="keyword">if</span> (readOnly) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Object event : AuditLogServiceData.getHibernateEvents()) &#123;</span><br><span class="line">           <span class="comment">// 这里就是遍历之前捕获的所有的 Hibernate 事件，</span></span><br><span class="line">           <span class="comment">// 并根据需要进行审计处理，比如日志、DB存储等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we have to unbind all resources as spring does not do that automatically</span></span><br><span class="line">        AuditLogServiceData.clear();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们采用实现 <em><code>TransactionSynchronizationAdapter</code></em> 的方式来拦截事务的处理过程，在事务提交前对当前的操作进行审计，代码中的注解已经说明得很清楚了。</p>
<h2 id="5-实际的调用"><a href="#5-实际的调用" class="headerlink" title="5. 实际的调用"></a>5. 实际的调用</h2><p>如同第2节撰述，首先我们的 <em><code>FooBar</code></em> 实体需要添加 <em><code>AuditedEntity</code></em>注解，然后在我们进行保存的地方添加我们的 <em><code>@AuditLogActor</code></em> 来标记我们当前的操作者信息，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveFoo</span><span class="params">(FooBar foobar, @AuditLogActor Long actorId)</span> </span>&#123; .. &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>总结一下：整个过程其实就是监听hibernate事件，将所有insert，update和delete事件存储为spring事务同步资源，然后通过 AOP 注册 Spring 事务 <em>“callback”</em>，该事务在每个事务提交之前调用，处理所有事件并插入相应的审核日志条目。</p>
<p>当然，这个方案还是比较烦琐和有一定的局限性的，比如需要在各个事务操作的地方传递  <em><code>@AuditLogActor</code></em> ，所以如第1章所述，我们还是应该尽量使用<a href="http://hibernate.org/orm/envers/" target="_blank" rel="noopener">Envers</a>或<a href="http://docs.spring.io/spring-data/jpa/docs/1.10.2.RELEASE/reference/html/#auditing" target="_blank" rel="noopener">spring数据jpa审计</a>，只有在这两个方案不适用时才考虑使用本文介绍的案例。</p>
]]></content>
      <tags>
        <tag>数据审计</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat中使用Favicon</title>
    <url>/2008/02/18/tomcat-zhong-shi-yong-favicon/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IE7中每个页面都有一个自己的图标，如果不自己制定的话，会变成tomcat的小猫咪。下面说一下怎么改掉这个小猫咪。 </p>
<ol>
<li><p>在每个页面的<code>&lt;head&gt;&lt;/head&gt;</code>里加入以下两行代码。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&#123;contextPath&#125;/favicon.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"&#123;contextPath&#125;/favicon.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>{contextPath}</code> 是你的站点的名字，所以这里是绝对路径，如果我没有记错的话，在jsp中相对路径好像是不好用的。比如，网易的话，就应该是 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"http://www.163.com/favicon.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"http://www.163.com/favicon.ico"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>在WebRoot下面，也就是网站的根目录下面放一个favicon.ico文件，这个文件必须是标准的ico文件。可以通过<a href="http://www.chami.com/html-kit/services/favicon/" target="_blank" rel="noopener">http://www.chami.com/html-kit/services/favicon/ </a>这个网站生成一个 ，大小是32x32的，如果你希望可以在IE6里表示出来的话，最好是16X16的，在5K以下，因为我们遇到如果用一个15k的文件，IE不能自动下载，必须手动键入favicon.ico的地址后，它才能表示出来。颜色的话，16色，256色都可以。保险一点就是16色，我用的是256色的。 </p>
<p>有的网站说，这个文件必须叫”favicon.ico”，必须放在根目录下，要不然IE认不出来（别的浏览器可以），这个我没有试验过。 </p>
<p>这个时候你在你的浏览器里敲入 <a href="http://localhost:8080/siteName/favicon.ico" target="_blank" rel="noopener">http://localhost:8080/siteName/favicon.ico</a>  的时候看到的将是一个小红叉。 </p>
</li>
</ol>
<ol start="3">
<li><p>要想摆脱小红叉就得靠这一步啦，在自己应用的web.xml或者tomcat的Conf下的web.xml中加入一下代码，然后重起tomcat。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mime-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span>ico<span class="tag">&lt;/<span class="name">extension</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mime-type</span>&gt;</span>image/x-icon<span class="tag">&lt;/<span class="name">mime-type</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mime-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li>如果你还用了什么登陆的过滤，就是filter之类，别忘了把这个文件给解放出来。</li>
</ol>
<ol start="5">
<li>这个时候你在输入，<a href="http://localhost:8080/siteName/favicon.ico，应该可以看到对应的图片，如果看不到，找找是不是什么地方错了。" target="_blank" rel="noopener">http://localhost:8080/siteName/favicon.ico，应该可以看到对应的图片，如果看不到，找找是不是什么地方错了。</a> </li>
</ol>
<ol start="6">
<li>清空IE的缓存，就清空文件就可以了。然后输入你的网址，当然这个时候你还看不见图标。关掉浏览器，在重新打开，在地址栏里，你就可以看到你的图标了。我们这里所指的浏览器是IE7，因为IE6必须得添加入收藏夹议后才能看到图标，而且只有添加的那个网址能看到，网站的其他页面都没有图标。查了一些资料，也没有解决这个问题。以后有时间在解决吧。 </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Spring源码解读——声明式事务处理</title>
    <url>/2012/02/26/spring-yuan-ma-jie-du-sheng-ming-shi-shi-wu-chu-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们看看Spring中的事务处理的代码，使用Spring管理事务有声明式和编程式两种方式，声明式事务处理通过AOP的实现把事物管理代码作为方面封装来横向插入到业务代码中，使得事务管理代码和业务代码解藕。在这种方式我们结合IoC容器和Spirng已有的FactoryBean来对事务管理进行属性配置，比如传播行为，隔离级别等。其中最简单的方式就是通过配置TransactionProxyFactoryBean来实现声明式事物； </p>
<a id="more"></a>
<p>在整个源代码分析中，我们可以大致可以看到Spring实现声明式事物管理有这么几个部分： </p>
<ul>
<li>对在上下文中配置的属性的处理，这里涉及的类是TransactionAttributeSourceAdvisor，这是一个通知器，用它来对属性值进行处理，属性信息放在TransactionAttribute中来使用,而这些属性的处理往往是和对切入点的处理是结合起来的。对属性的处理放在类TransactionAttributeSource中完成。 </li>
<li>创建事物的过程，这个过程是委托给具体的事物管理器来创建的，但Spring通过TransactionStatus来传递相关的信息。 </li>
<li>对事物的处理通过对相关信息的判断来委托给具体的事物管理器完成。 </li>
</ul>
<p>我们下面看看具体的实现，在TransactionFactoryBean中： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title">AbstractSingletonProxyFactoryBean</span>  </span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">BeanFactoryAware</span> </span>&#123;  </span><br><span class="line"><span class="comment">//这里是Spring事务处理而使用的AOP拦截器，中间封装了Spring对事务处理的代码来支持声明式事务处理的实现  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionInterceptor transactionInterceptor = <span class="keyword">new</span> TransactionInterceptor();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Pointcut pointcut;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//这里Spring把TransactionManager注入到TransactionInterceptor中去  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(PlatformTransactionManager transactionManager)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.transactionInterceptor.setTransactionManager(transactionManager);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//这里把在bean配置文件中读到的事务管理的属性信息注入到TransactionInterceptor中去  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionAttributes</span><span class="params">(Properties transactionAttributes)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.transactionInterceptor.setTransactionAttributes(transactionAttributes);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    .........中间省略了其他一些方法.......  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里创建Spring AOP对事务处理的Advisor  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createMainInterceptor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.transactionInterceptor.afterPropertiesSet();  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pointcut != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//这里使用默认的通知器  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(<span class="keyword">this</span>.pointcut, <span class="keyword">this</span>.transactionInterceptor);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 使用上面定义好的TransactionInterceptor作为拦截器，同时使用TransactionAttributeSourceAdvisor  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TransactionAttributeSourceAdvisor(<span class="keyword">this</span>.transactionInterceptor);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那什么时候Spring的TransactionInterceptor被注入到Spring AOP中成为Advisor中的一部分呢？我们看到在TransactionProxyFactoryBean中，这个方法在IOC初始化bean的时候被执行： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    .......  </span><br><span class="line">    <span class="comment">//TransactionProxyFactoryBean实际上使用ProxyFactory完成AOP的基本功能。  </span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.preInterceptors != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.preInterceptors.length; i++) &#123;  </span><br><span class="line">            proxyFactory.addAdvisor(<span class="keyword">this</span>.advisorAdapterRegistry.wrap(<span class="keyword">this</span>.preInterceptors[i]));  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里是Spring加入通知器的地方  </span></span><br><span class="line">    <span class="comment">//有两种通知器可以被加入DefaultPointcutAdvisor或者TransactionAttributeSourceAdvisor  </span></span><br><span class="line">    <span class="comment">//这里把Spring处理声明式事务处理的AOP代码都放到ProxyFactory中去，怎样加入advisor我们可以参考ProxyFactory的父类AdvisedSupport()  </span></span><br><span class="line">    <span class="comment">//由它来维护一个advice的链表，通过这个链表的增删改来抽象我们对整个通知器配置的增删改操作。  </span></span><br><span class="line">    proxyFactory.addAdvisor(<span class="keyword">this</span>.advisorAdapterRegistry.wrap(createMainInterceptor()));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.postInterceptors != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.postInterceptors.length; i++) &#123;  </span><br><span class="line">            proxyFactory.addAdvisor(<span class="keyword">this</span>.advisorAdapterRegistry.wrap(<span class="keyword">this</span>.postInterceptors[i]));  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//这里创建AOP的目标源  </span></span><br><span class="line">    TargetSource targetSource = createTargetSource(<span class="keyword">this</span>.target);  </span><br><span class="line">    proxyFactory.setTargetSource(targetSource);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.proxyInterfaces != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        proxyFactory.setInterfaces(<span class="keyword">this</span>.proxyInterfaces);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!isProxyTargetClass()) &#123;  </span><br><span class="line">        proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetSource.getTargetClass()));  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.proxy = getProxy(proxyFactory);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 已经定义了一个transctionInterceptor作为拦截器或者AOP advice的实现，在IOC容器中定义的其他属性比如transactionManager和事务管理的属性都会传到已经定义好的 TransactionInterceptor那里去进行处理。以上反映了基本的Spring AOP的定义过程，其中pointcut和advice都已经定义好，同时也通过通知器配置到ProxyFactory中去了。<br>下面让我们回到TransactionProxyFactoryBean中看看TransactionAttributeSourceAdvisor是怎样定义的，这样我们可以理解具体的属性是怎样起作用，这里我们分析一下类TransactionAttributeSourceAdvisor: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//和其他Advisor一样，同样需要定义AOP中的用到的Interceptor和Pointcut  </span></span><br><span class="line">    <span class="comment">//Interceptor使用传进来的TransactionInterceptor  </span></span><br><span class="line">    <span class="comment">//而对于pointcut,这里定义了一个内部类，参见下面的代码    </span></span><br><span class="line">    <span class="keyword">private</span> TransactionInterceptor transactionInterceptor;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut();  </span><br><span class="line">     </span><br><span class="line">    .........  </span><br><span class="line">    <span class="comment">//定义的PointCut内部类  </span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourcePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">       .......  </span><br><span class="line">      <span class="comment">//方法匹配的实现，使用了TransactionAttributeSource类  </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;  </span><br><span class="line">            TransactionAttributeSource tas = getTransactionAttributeSource();  </span><br><span class="line">            <span class="comment">//这里使用TransactionAttributeSource来对配置属性进行处理  </span></span><br><span class="line">            <span class="keyword">return</span> (tas != <span class="keyword">null</span> &amp;&amp; tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">    ........省略了equal,hashcode,tostring的代码  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看看属性值是怎样被读入的：AbstractFallbackTransactionAttributeSource负责具体的属性读入任务，我们可以有两种读入方式，比如annotation和直接配置.我们下面看看直接配置的读入方式，在Spring中同时对读入的属性值进行了缓存处理，这是一个decorator模式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这里先查一下缓存里有没有事务管理的属性配置，如果有从缓存中取得TransactionAttribute  </span></span><br><span class="line">    Object cacheKey = getCacheKey(method, targetClass);  </span><br><span class="line">    Object cached = <span class="keyword">this</span>.cache.get(cacheKey);  </span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> (TransactionAttribute) cached;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 这里通过对方法和目标对象的信息来计算事务缓存属性  </span></span><br><span class="line">        TransactionAttribute txAtt = computeTransactionAttribute(method, targetClass);  </span><br><span class="line">        <span class="comment">//把得到的事务缓存属性存到缓存中，下次可以直接从缓存中取得。  </span></span><br><span class="line">        <span class="keyword">if</span> (txAtt == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.cache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            ...........  </span><br><span class="line">            <span class="keyword">this</span>.cache.put(cacheKey, txAtt);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> txAtt;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别急，基本的处理在computeTransactionAttribute（）中： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这里检测是不是public方法  </span></span><br><span class="line">    <span class="keyword">if</span>(allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// First try is the method in the target class.  </span></span><br><span class="line">    TransactionAttribute txAtt = findTransactionAttribute(findAllAttributes(specificMethod));  </span><br><span class="line">    <span class="keyword">if</span> (txAtt != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> txAtt;  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Second try is the transaction attribute on the target class.  </span></span><br><span class="line">    txAtt = findTransactionAttribute(findAllAttributes(specificMethod.getDeclaringClass()));  </span><br><span class="line">    <span class="keyword">if</span> (txAtt != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> txAtt;  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (specificMethod != method) &#123;  </span><br><span class="line">        <span class="comment">// Fallback is to look at the original method.  </span></span><br><span class="line">        txAtt = findTransactionAttribute(findAllAttributes(method));  </span><br><span class="line">        <span class="keyword">if</span> (txAtt != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> txAtt;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Last fallback is the class of the original method.  </span></span><br><span class="line">        <span class="keyword">return</span> findTransactionAttribute(findAllAttributes(method.getDeclaringClass()));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过一系列的尝试我们可以通过findTransactionAttribute（）通过调用findAllAttribute()得到TransactionAttribute的对象，如果返回的是null,这说明该方法不是我们需要事务处理的方法。<br>在完成把需要的通知器加到ProxyFactory中去的基础上，我们看看具体的看事务处理代码怎样起作用，在TransactionInterceptor中： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">    <span class="comment">//这里得到目标对象  </span></span><br><span class="line">    Class targetClass = (invocation.getThis() != <span class="keyword">null</span> ? invocation.getThis().getClass() : <span class="keyword">null</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里同样的通过判断是否能够得到TransactionAttribute来决定是否对当前方法进行事务处理，有可能该属性已经被缓存，  </span></span><br><span class="line">    <span class="comment">//具体可以参考上面对getTransactionAttribute的分析，同样是通过TransactionAttributeSource  </span></span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr =  </span><br><span class="line">            getTransactionAttributeSource().getTransactionAttribute(invocation.getMethod(), targetClass);  </span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(invocation.getMethod());  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里判断我们使用了什么TransactionManager  </span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(getTransactionManager() <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;  </span><br><span class="line">        <span class="comment">// 这里创建事务，同时把创建事务过程中得到的信息放到TransactionInfo中去  </span></span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(txAttr, joinpointIdentification);  </span><br><span class="line">        Object retVal = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">              retVal = invocation.proceed();  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">            <span class="comment">// target invocation exception  </span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);  </span><br><span class="line">            <span class="keyword">throw</span> ex;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;  </span><br><span class="line">            cleanupTransactionInfo(txInfo);  </span><br><span class="line">        &#125;</span><br><span class="line">        commitTransactionAfterReturning(txInfo);  </span><br><span class="line">        <span class="keyword">return</span> retVal;  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 使用的是Spring定义的PlatformTransactionManager同时实现了回调接口,我们通过其回调函数完成事务处理，就像我们使用编程式事务处理一样。  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Object result = ((CallbackPreferringPlatformTransactionManager) getTransactionManager()).execute(txAttr,  </span><br><span class="line">                    <span class="keyword">new</span> TransactionCallback() &#123;  </span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;  </span><br><span class="line">                            <span class="comment">//同样的需要一个TransactonInfo  </span></span><br><span class="line">                            TransactionInfo txInfo = prepareTransactionInfo(txAttr, joinpointIdentification, status);  </span><br><span class="line">                            <span class="keyword">try</span> &#123;  </span><br><span class="line">                                <span class="keyword">return</span> invocation.proceed();  </span><br><span class="line">                            &#125;</span><br><span class="line">                         .....这里省去了异常处理和事务信息的清理代码  </span><br><span class="line">                    &#125;);  </span><br><span class="line">         ...........  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面涉及到事务的创建，我们可以在TransactionAspectSupport实现的事务管理代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If no name specified, apply method identification as transaction name.  </span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    TransactionStatus status = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="comment">//这里使用了我们定义好的事务配置信息,有事务管理器来创建事务，同时返回TransactionInfo  </span></span><br><span class="line">        status = getTransactionManager().getTransaction(txAttr);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(txAttr, joinpointIdentification, status);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过TransactionManager得到需要的事务，事务的创建根据我们定义的事务配置决定，在 AbstractTransactionManager中给出一个标准的创建过程，当然创建什么样的事务还是需要具体的 PlatformTransactionManager来决定，但这里给出了创建事务的模板： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;  </span><br><span class="line">    Object transaction = doGetTransaction();  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="comment">//如果事务信息没有被配置，我们使用Spring默认的配置方式  </span></span><br><span class="line">        definition = <span class="keyword">new</span> DefaultTransactionDefinition();  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;  </span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.  </span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Check definition settings for new transaction.  </span></span><br><span class="line">    <span class="comment">//下面就是使用配置信息来创建我们需要的事务;比如传播属性和同步属性等  </span></span><br><span class="line">    <span class="comment">//最后把创建过程中的信息收集起来放到TransactionStatus中返回；    </span></span><br><span class="line">    <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, definition.getTimeout());  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to behave.  </span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(  </span><br><span class="line">                <span class="string">"Transaction propagation 'mandatory' but no existing transaction found"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||  </span><br><span class="line">            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||  </span><br><span class="line">        definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;  </span><br><span class="line">        <span class="comment">//这里是事务管理器创建事务的地方，并将创建过程中得到的信息放到TransactionStatus中去，包括创建出来的事务  </span></span><br><span class="line">        doBegin(transaction, definition);  </span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);  </span><br><span class="line">        <span class="keyword">return</span> newTransactionStatus(definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);  </span><br><span class="line">        <span class="keyword">return</span> newTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着通过调用prepareTransactionInfo完成事务创建的准备，创建过程中得到的信息存储在TransactionInfo对象中进行传递同时把信息和当前线程绑定； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">prepareTransactionInfo</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    TransactionInfo txInfo = <span class="keyword">new</span> TransactionInfo(txAttr, joinpointIdentification);  </span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;  </span><br><span class="line">    .....  </span><br><span class="line">        <span class="comment">// 同样的需要把在getTransaction中得到的TransactionStatus放到TransactionInfo中来。  </span></span><br><span class="line">        txInfo.newTransactionStatus(status);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">    .......  </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 绑定事务创建信息到当前线程  </span></span><br><span class="line">    txInfo.bindToThread();  </span><br><span class="line">    <span class="keyword">return</span> txInfo;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将创建事务的信息返回，然后看到其他的事务管理代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(TransactionInfo txInfo)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Invoking commit for transaction on "</span> + txInfo.getJoinpointIdentification());  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager.commit(txInfo.getTransactionStatus());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过transactionManager对事务进行处理，包括异常抛出和正常的提交事务，具体的事务管理器由用户程序设定。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(TransactionInfo txInfo, Throwable ex)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute.rollbackOn(ex)) &#123;  </span><br><span class="line">            ......  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">this</span>.transactionManager.rollback(txInfo.getTransactionStatus());  </span><br><span class="line">            &#125;</span><br><span class="line">            ..........  </span><br><span class="line">  &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            .........  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">this</span>.transactionManager.commit(txInfo.getTransactionStatus());  </span><br><span class="line">            &#125;</span><br><span class="line">   ...........  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(TransactionInfo txInfo)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">this</span>.transactionManager.commit(txInfo.getTransactionStatus());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring通过以上代码对transactionManager进行事务处理的过程进行了AOP包装，到这里我们看到为了方便客户实现声明式的事务处理，Spring还是做了许多工作的。如果说使用编程式事务处理，过程其实比较清楚，我们可以参考书中的例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionDefinition td = <span class="keyword">new</span> DefaultTransactionDefinition();  </span><br><span class="line">TransactionStatus status = transactionManager.getTransaction(td);  </span><br><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line">      ......<span class="comment">//这里是我们的业务方法  </span></span><br><span class="line">&#125;<span class="keyword">catch</span> (ApplicationException e) &#123;  </span><br><span class="line">   transactionManager.rollback(status);  </span><br><span class="line">   <span class="keyword">throw</span> e  </span><br><span class="line">&#125;</span><br><span class="line">transactionManager.commit(status);  </span><br><span class="line"> ........</span><br></pre></td></tr></table></figure>
<p>我们看到这里选取了默认的事务配置DefaultTransactionDefinition，同时在创建事物的过程中得到TransactionStatus,然后通过直接调用事务管理器的相关方法就能完成事务处理。<br>声明式事务处理也同样实现了类似的过程，只是因为采用了声明的方法，需要增加对属性的读取处理，并且需要把整个过程整合到Spring AOP框架中和IoC容器中去的过程。<br>下面我们选取一个具体的transactionManager - DataSourceTransactionManager来看看其中事务处理的实现：<br>同样的通过使用AbstractPlatformTransactionManager使用模板方法，这些都体现了对具体平台相关的事务管理器操作的封装，比如commit： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;  </span><br><span class="line">    <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        processRollback(defStatus);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">         .......  </span><br><span class="line">        processRollback(defStatus);  </span><br><span class="line">    ......  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    processCommit(defStatus);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过对TransactionStatus的具体状态的判断，来决定具体的事务处理： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            triggerBeforeCommit(status);  </span><br><span class="line">            triggerBeforeCompletion(status);  </span><br><span class="line">            beforeCompletionInvoked = <span class="keyword">true</span>;  </span><br><span class="line">            <span class="keyword">boolean</span> globalRollbackOnly = <span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">if</span> (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;  </span><br><span class="line">                globalRollbackOnly = status.isGlobalRollbackOnly();  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (status.hasSavepoint()) &#123;  </span><br><span class="line">            ........  </span><br><span class="line">               status.releaseHeldSavepoint();  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;  </span><br><span class="line">            ......  </span><br><span class="line">                doCommit(status);  </span><br><span class="line">            &#125;</span><br><span class="line">        .........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些模板方法的实现由具体的transactionManager来实现，比如在DataSourceTransactionManager: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这里得到存在TransactionInfo中已经创建好的事务  </span></span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里得到和事务绑定的数据库连接  </span></span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();  </span><br><span class="line">    ........  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">//这里通过数据库连接来提交事务  </span></span><br><span class="line">        con.commit();  </span><br><span class="line">    &#125;</span><br><span class="line">   .......  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;  </span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();  </span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();  </span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;  </span><br><span class="line">        logger.debug(<span class="string">"Rolling back JDBC transaction on Connection ["</span> + con + <span class="string">"]"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">//这里通过数据库连接来回滚事务  </span></span><br><span class="line">        con.rollback();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not roll back JDBC transaction"</span>, ex);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在DataSourceTransactionManager中最后还是交给connection来实现事务的提交和rollback。整个声明式事务处理是事务处理在Spring AOP中的应用，我们看到了一个很好的使用Spring AOP的例子，在Spring声明式事务处理的源代码中我们可以看到： </p>
<ol>
<li>怎样封装各种不同平台下的事务处理代码 </li>
<li>怎样读取属性值和结合事务处理代码来完成既定的事务处理策略 </li>
<li>怎样灵活的使用SpringAOP框架。 </li>
</ol>
<p>如果能够结合前面的Spring AOP的源代码来学习，理解可能会更深刻些。 </p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal的设计与使用（原理篇)</title>
    <url>/2008/02/18/threadlocal-de-she-ji-yu-shi-yong-yuan-li-pian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在jdk1.2推出时开始支持java.lang.ThreadLocal。在J2SE5.0中的声明为：public class ThreadLocal<t> extends ObjectThreadLocal是什么呢？其实ThreadLocal并非是一个线程的本地实现版本，它并不是一个Thread，而是thread local variable（线程局部变量），也许把它命名为ThreadLocalVar更加合适。 </t></p>
<a id="more"></a>
<p>线程局部变量（ThreadLocal）其实的功用非常简单，就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。 </p>
<p>首先我们看一下ThreadLocal类的接口和设计思路。在J2SE5.0中，该类有1个默认构造函数，4个普通函数。</p>
<ul>
<li><p><code>protected ThreadLocal initialValue()</code>显然是为了子类重写而特意实现的。该方法返回当前线程在该线程局部变量的初始值，这个方法是一个延迟调用方法，在一个线程第1次调用<code>get()</code>或者<code>set(Object)</code>时才执行，并且仅执行1次；</p>
</li>
<li><p><code>public ThreadLocal get()</code>返回当前线程的线程局部变量副本；</p>
</li>
<li><p><code>public void set(ThreadLocal value)</code>，设置当前线程的线程局部变量副本的值；</p>
</li>
<li><p><code>public void remove()</code>移除当前线程的线程局部变量副本的值以释放存储空间。 </p>
</li>
</ul>
<p>从下面这个参考实现，我们可以看出ThreadLocal的工作原理： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Map values = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        Object o = values.get(curThread);</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> &amp;&amp; !values.containsKey(curThread)) &#123;</span><br><span class="line">            o = initialValue();</span><br><span class="line">            values.put(curThread, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object newValue)</span> </span>&#123;</span><br><span class="line">        values.put(Thread.currentThread(), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK中的ThreadLocal的实现总体思路也类似于此，但这并不是一个工业强度的实现。首先，每个 get() 和 set() 操作都需要 values 映射表上的同步，而且如果多个线程同时访问同一个ThreadLocal，那么将发生冲突。此外，这个实现也是不切实际的，因为用 Thread 对象做 values 映射表中的key将导致无法在线程退出后对 Thread 进行垃圾回收，而且也无法对死线程的 ThreadLocal的特定于线程的值进行垃圾回收。从j2sdk5.0的src来看，并非在ThreadLocal中有一个Map,而是在每个Thread中存在这样一个Map，具体是ThreadLocal.ThreadLocalMap。当用set时候，往当前线程里面的Map里 put 的key是当前的ThreadLocal对象。而不是把当前Thread作为Key值put到ThreadLocal中的Map里。 </p>
<p>ThreadLocal的使用。如果希望线程局部变量初始化其它值，那么需要自己实现ThreadLocal的子类并重写该方法，通常使用一个inner anonymous class对ThreadLocal进行子类化，比如下面的例子，SerialNum类为每一个类分配一个序号： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNum</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The next serial number to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextSerialNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal serialNum = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(nextSerialNum++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) (serialNum.get())).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线程是活动的并且ThreadLocal对象是可访问的时，该线程就持有一个到该线程局部变量副本的隐含引用，当该线程运行结束后，该线程拥有的所有线程局部变量的副本都将失效，并等待垃圾收集器收集。 </p>
<p>由于ThreadLocal中可以持有任何类型的对象，所以使用ThreadLocal获取当前线程的值是需要进行强制类型转换。但随着J2SE5.0将模版引入，新的支持模版参数的ThreadLocal<t>类将从中受益。也可以减少强制类型转换，并将一些错误检查提前到了编译期，将一定程度地简化ThreadLocal的使用。 </t></p>
<p>ThreadLocal和其它同步机制相比有什么优势呢？ThreadLocal和其它所有的同步机制都是为了解决多线程中的对同一变量的访问冲突，在普通的同步机制中，是通过对象加锁来实现多个线 程对同一变量的安全访问的。这时该变量是多个线程共享的，使用这种同步机制需要很细致地分析在什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放该对象的锁等等很多。所有这些都是因为多个线程共享了资源造成的。ThreadLocal就从另一个角度来解决多线程的并发访问，ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本，从而隔离了多个线程的数据，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的整个变量封装进ThreadLocal，或者把该对象的特定于线程的状态封装进ThreadLocal。 </p>
<p>当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal，这将极大地简化我们的程序，使程序更加易读、简洁。ThreadLocal类为各线程提供了存放局部变量的场所。 </p>
<p>本质上，每个当前运行的Thread都会持有一个Map，ThreadLocal类对这个Map的访问进行了封装，因此在线程中可以把一个新生成的对象通过ThreadLocal放入这个Map，这样可以保证该线程在以后每次从ThreadLocal对象即这个Map中取得的对象都只是在该线程中可用，不会被其它线程访问到。 </p>
<p>文章《ThreadLocal的设计与使用》中提到ThreadLocal使用类似下面的实现其实是不对: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map values = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread curThread = Thread.currentThread();</span><br><span class="line">        Object o = values.get(curThread);</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> &amp;&amp; !values.containsKey(curThread)) &#123;</span><br><span class="line">            o = initialValue();</span><br><span class="line">            values.put(curThread, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object newValue)</span> </span>&#123;</span><br><span class="line">        values.put(Thread.currentThread(), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上并不是由ThreadLocal保持这个Map，而是每个Thread。这样做的好处是每次线程死亡，所有Map中引用到的对象都会随着这个Thread的死亡而被垃圾收集器一起收集（当然前提是没有别处引用它）<br>这个Map的key则是对ThreadLocal对象的弱引用，当要抛弃掉ThreadLocal对象时，垃圾收集器会忽略这个key的引用而清理掉ThreadLocal对象。</p>
]]></content>
      <tags>
        <tag>TheadLocal</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 源码解读——启动篇</title>
    <url>/2016/11/10/tomcat-yuan-ma-jie-du-qi-dong-pian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>The Apache Tomcat® software is an open source implementation of the Java Servlet, JavaServer Pages, Java Expression Language and Java WebSocket technologies. The Java Servlet, JavaServer Pages, Java Expression Language and Java WebSocket specifications are developed under the Java Community Process.<br>The Apache Tomcat software is developed in an open and participatory environment and released under the Apache License version 2. The Apache Tomcat project is intended to be a collaboration of the best-of-breed developers from around the world. We invite you to participate in this open development project. To learn more about getting involved, click here.<br>Apache Tomcat software powers numerous large-scale, mission-critical web applications across a diverse range of industries and organizations. Some of these users and their stories are listed on the PoweredBy wiki page.<br>Apache Tomcat, Tomcat, Apache, the Apache feather, and the Apache Tomcat project logo are trademarks of the Apache Software Foundation.</p>
<p>以上的简介自来 Apache Tomcat 官网，Tomcat服务器是一个免费的开放源代码的Web应用服务器。Tomcat是Apache软件基金会（Apache Software Foundation）的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。由于有了Sun的参与和支持，最新的Servlet 和JSP规范总是能在Tomcat中得到体现，因为Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，是目前比较流行的Web应用服务器。</p>
</blockquote>
<a id="more"></a>
<p>​    本文基于<strong>Tomcat9</strong>的源码进行解读，不同的版本实现之间可能会有一些差异，请注意区分。</p>
<h3 id="启动脚本-startup-sh"><a href="#启动脚本-startup-sh" class="headerlink" title="启动脚本 startup.sh"></a>启动脚本 <code>startup.sh</code></h3><p>​    Tomcat 支持不同的平台，其启动方式都大同小异，都提供了相应的启动脚本，windows 平台下是 <code>startup.bat</code>，而在 linux 环境下则是 <code>startup.sh</code>，接下来的介绍都将以 linux 平台为主进行介绍。如下是 linux 平台下的 <code>startup.sh</code> 节选：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PRGDIR=`dirname "$PRG"`</span><br><span class="line">EXECUTABLE=catalina.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Check that target executable exists</span><br><span class="line">if $os400; then</span><br><span class="line"><span class="meta">  #</span> -x will Only work on the os400 if the files are:</span><br><span class="line"><span class="meta">  #</span> 1. owned by the user</span><br><span class="line"><span class="meta">  #</span> 2. owned by the PRIMARY group of the user</span><br><span class="line"><span class="meta">  #</span> this will not work if the user belongs in secondary groups</span><br><span class="line">  eval</span><br><span class="line">else</span><br><span class="line">  if [ ! -x "$PRGDIR"/"$EXECUTABLE" ]; then</span><br><span class="line">    echo "Cannot find $PRGDIR/$EXECUTABLE"</span><br><span class="line">    echo "The file is absent or does not have execute permission"</span><br><span class="line">    echo "This file is needed to run this program"</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec "$PRGDIR"/"$EXECUTABLE" start "$@"</span><br></pre></td></tr></table></figure>
<p>​    显然，<code>startup.sh</code>只是去调用了<code>catalina.sh</code>而已，所以我们再来看看<code>catalina.sh</code>的内容（为什么叫 catalina，我特意去查了一下词典和相关的资料，我们知道一个著名的 web 服务器就叫 apache，apache 有一个中文名称是：<strong>武装直升机</strong>，牛吧。但是，请再看看 catalina 的另外一个中文名称：<strong>远程轰炸机</strong>，哈哈，是不是更牛！当然，也许 tomcat 的作者并不是取此意，但具体的原因网上已经查不到了。）:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set _EXECJAVA=%_RUNJAVA%</span><br><span class="line">set MAINCLASS=org.apache.catalina.startup.Bootstrap</span><br><span class="line">set ACTION=start</span><br><span class="line">set SECURITY_POLICY_FILE=</span><br><span class="line">set DEBUG_OPTS=</span><br><span class="line">set JPDA=</span><br></pre></td></tr></table></figure>
<p>​    Tomcat 是一个由 java 语言编写的开源服务器，从脚本中我们可以看主，其启动类是 Bootstrap ，而且指定了调用的方法为<code>start()</code>，因此我们就从这个类开始深入，一步步来看看整个启动的过程。</p>
<p>​    <code>Catalina.sh</code>的脚本超过 <strong><em>600</em></strong> 行，包括了平时我们在使用Tomcat时的各种命令实现（比如<strong>start</strong>, <strong>stop</strong>, <strong>run</strong> 等），其启动的主要流程如下（同时对于 CYGWIN 进行了支持）：</p>
<ul>
<li><p>设置各类环境变量</p>
</li>
<li><p>设置<code>classpath</code></p>
</li>
<li><p>解析各个配置属性</p>
</li>
<li><p>设置安全管理器</p>
</li>
<li><p>调用<code>org.apache.catalina.startup.Bootstrap.start</code>开始整个启动过程</p>
<p>启动时的主要脚本如下：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch "$CATALINA_OUT"</span><br><span class="line">if [ "$1" = "-security" ] ; then</span><br><span class="line">if [ $have_tty -eq 1 ]; then</span><br><span class="line">  echo "Using Security Manager"</span><br><span class="line">fi</span><br><span class="line">shift</span><br><span class="line">eval $_NOHUP "\"$_RUNJAVA\"" "\"$LOGGING_CONFIG\"" $LOGGING_MANAGER $JAVA_OPTS $CATALINA_OPTS \</span><br><span class="line"><span class="meta">  -D$</span>ENDORSED_PROP="\"$JAVA_ENDORSED_DIRS\"" \</span><br><span class="line">  -classpath "\"$CLASSPATH\"" \</span><br><span class="line">  -Djava.security.manager \</span><br><span class="line">  -Djava.security.policy=="\"$CATALINA_BASE/conf/catalina.policy\"" \</span><br><span class="line">  -Dcatalina.base="\"$CATALINA_BASE\"" \</span><br><span class="line">  -Dcatalina.home="\"$CATALINA_HOME\"" \</span><br><span class="line">  -Djava.io.tmpdir="\"$CATALINA_TMPDIR\"" \</span><br><span class="line">  org.apache.catalina.startup.Bootstrap "$@" start \</span><br><span class="line"><span class="meta">  &gt;</span>&gt; "$CATALINA_OUT" 2&gt;&amp;1 "&amp;"</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">eval $_NOHUP "\"$_RUNJAVA\"" "\"$LOGGING_CONFIG\"" $LOGGING_MANAGER $JAVA_OPTS $CATALINA_OPTS \</span><br><span class="line"><span class="meta">  -D$</span>ENDORSED_PROP="\"$JAVA_ENDORSED_DIRS\"" \</span><br><span class="line">  -classpath "\"$CLASSPATH\"" \</span><br><span class="line">  -Dcatalina.base="\"$CATALINA_BASE\"" \</span><br><span class="line">  -Dcatalina.home="\"$CATALINA_HOME\"" \</span><br><span class="line">  -Djava.io.tmpdir="\"$CATALINA_TMPDIR\"" \</span><br><span class="line">  org.apache.catalina.startup.Bootstrap "$@" start \</span><br><span class="line"><span class="meta">  &gt;</span>&gt; "$CATALINA_OUT" 2&gt;&amp;1 "&amp;"</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -z "$CATALINA_PID" ]; then</span><br><span class="line">echo $! &gt; "$CATALINA_PID"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "Tomcat started."</span><br></pre></td></tr></table></figure>
<p>​    Tomcat 是一个由 java 语言编写的开源服务器，从脚本中我们可以看主，其启动类是 Bootstrap ，而且指定了调用的参数<code>start</code>，因此我们就从这个类开始深入，一步步来看看整个启动的过程。</p>
<h3 id="启动入口Bootstrap-main"><a href="#启动入口Bootstrap-main" class="headerlink" title="启动入口Bootstrap.main()"></a>启动入口<code>Bootstrap.main()</code></h3><p>​    从上一节我们知道，Tomcat 的启动入口在 <code>Bootstrap.main()</code>，我们进入这个方法看看（<strong><em>注意：省略了很多非关注点的代码</em></strong>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化 bootstrap</span></span><br><span class="line">            bootstrap.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    		<span class="comment">// 省略非关注点代码 ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        daemon = bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">            daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 开始启动</span></span><br><span class="line">            daemon.start();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    	<span class="comment">// 省略非关注点代码 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bootstrp-init-gt-Catalina-init"><a href="#Bootstrp-init-gt-Catalina-init" class="headerlink" title="Bootstrp.init() -&gt; Catalina.init()"></a>Bootstrp.init() -&gt; Catalina.init()</h3><p>​    主要过程的代码还是比较简洁的，这利益于Tomcat采用的 <strong>Lifecycle</strong> 模式，将整个过程封装到组件的各个生命周期中去了。关于 <strong>Lifecycle</strong> 设计模式的讲解可以关注我的另外一篇文章<a href="#">Tomcat对于Lifecycle的精妙使用</a>。从源码看，先是初始化了<code>bootstrap.init</code>，之后将加载参数后进入到了<code>bootstrap.start</code>过程，下面我们先看看<code>bootstrap.init</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize daemon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception Fatal initialization error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    initClassLoaders();</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Loading startup class"</span>);</span><br><span class="line">    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>);</span><br><span class="line">    Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Setting startup class properties"</span>);</span><br><span class="line">    String methodName = <span class="string">"setParentClassLoader"</span>;</span><br><span class="line">    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">    paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</span><br><span class="line">    Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">    Method method = startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">    method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">    catalinaDaemon = startupInstance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到，所做的一切就是初始化一个<code>org.apache.catalina.startup.Catalina</code>实例，并设置其<code>classLoader</code>，过程如下：</p>
<ol>
<li>初始化路径</li>
<li>初始化类加载器：初始化Tomcat类加载器：commonLoader、catalinaLoader、sharedLoader<br>commonLoader无父加载器，catalinaLoader和sharedLoader的父加载器都是commonLoader，其中若tomcat的配置文件没有配置：<code>server.loader</code>则catalinaLoader=commonLoader，同理，没配置shared.loader……,这三种都是URLClassLoader，使用Java 中的安全模型；</li>
<li>初始化Boostrap的Catalina对象：通过反射生成Catalina对象，并通过反射调用<code>setParentClassLoader</code>方法设置其父 ClassLoader为sharedLoader。为什么要用反射，不直接在声明的时候生成对象？使用反射来生成实例的原因是因为在tomcat的发展历史中可能不止Catalina一种启动方式，现在看代码已经没必要了。</li>
<li>其他：主线程的classLoader设置为catalinaLoader，安全管理的ClassLoad设置为catalineLoader。</li>
</ol>
<p>​    其<code>start</code>方法同样简单，刚刚不是初始化了一个<code>Catalina</code>实例吗，那么现在的<code>start</code>方法就是被代理到<code>Catalina#start()</code>方法上去了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (catalinaDaemon == <span class="keyword">null</span>) init();</span><br><span class="line"></span><br><span class="line">    Method method = catalinaDaemon.getClass().getMethod(<span class="string">"start"</span>, (Class[]) <span class="keyword">null</span>);</span><br><span class="line">    method.invoke(catalinaDaemon, (Object[]) <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    所以，整个启动过程其实是在<code>Catalina#start()</code>中。</p>
<h3 id="Bootstrap-start-gt-Catalina-start"><a href="#Bootstrap-start-gt-Catalina-start" class="headerlink" title="Bootstrap.start() -&gt; Catalina.start()"></a>Bootstrap.start() -&gt; Catalina.start()</h3><p>​    接下来的初始化过程就交由到 <code>Catalina.start</code> 方法了，看看主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start a new server instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.fatal(<span class="string">"Cannot start server. Server instance is not configured."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(<span class="string">"Server startup in "</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register shutdown hook</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">        LogManager logManager = LogManager.getLogManager();</span><br><span class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这是整个启动过程的重头戏，我们将分段讲解其各个环节。</p>
<h4 id="初始化-Server-load"><a href="#初始化-Server-load" class="headerlink" title="初始化 Server.load()"></a>初始化 <code>Server.load()</code></h4><p>​    从源码中可以看到，当 <code>server == null</code>时，将会执行 Server 的初始化工作，调用其 <code>load()</code> 方法设置 Server的各个参数（<strong>我们经常打交道的 <code>server.xml</code> 解析与设计工作在此完成</strong>）。我们看看这个方法的主要执行过程（省略非关注点代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	initDirs();</span><br><span class="line">	initNaming();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Create and execute our Digester</span></span><br><span class="line">	Digester digester = createStartDigester();</span><br><span class="line">	...</span><br><span class="line">	InputSource inputSource = <span class="keyword">null</span>;</span><br><span class="line">	InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">	File file = <span class="keyword">null</span>;</span><br><span class="line">	...</span><br><span class="line">	file = configFile();</span><br><span class="line">	inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">	inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">	...</span><br><span class="line">	inputSource.setByteStream(inputStream);</span><br><span class="line">	digester.push(<span class="keyword">this</span>);</span><br><span class="line">	digester.parse(inputSource);</span><br><span class="line">	...</span><br><span class="line">	getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line"> 	...</span><br><span class="line">	getServer().init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    整个过程如下：</p>
<ol>
<li>初始化各类目录结构</li>
<li>初始化命名空间，为XML解析铺垫</li>
<li>初始化 <code>Digester</code>，开始解析<code>server.xml</code>并将解析后的内容设置到<code>Server</code>对象中（默认的配置文件定义：<code>protected String configFile = &quot;conf/server.xml&quot;;</code>）。</li>
<li>获取<code>Server</code>并执行其<code>init</code>方法。</li>
</ol>
<blockquote>
<p>关于<code>Digester</code>的用法可以去参考我另外的文章：<a href="#">Digester：将XML转换为Java对象</a></p>
</blockquote>
<h4 id="初始化-Server-init"><a href="#初始化-Server-init" class="headerlink" title="初始化 Server.init()"></a>初始化 <code>Server.init()</code></h4><p>​    Server 同时实现了<strong>Lifecycle</strong>接口，其具体的<code>init</code>过程我们可以从<code>StandardServer.initInternal</code>方法进行研究：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="keyword">null</span>);</span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    globalNamingResources.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our defined Services</span></span><br><span class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">            services[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    除了设置状态，触发相应的事件之外，这里还启动了 JNDI 的生命周期，用于完成 JNDI 的配置和初始化过程，JNDI 是 J2EE 规范的组件，有兴趣的同学可以参考我的另外一篇文章：<a href="#">有趣的 JNDI</a>。</p>
<p>​    紧接着就是循环的启动所有的<code>Service</code>组件，<strong>注意，这里是<code>Service</code>而不是<code>Server</code>，<code>Service</code>和<code>Connector</code>，<code>Engine</code>，<code>Host</code>一样，是Tomcat的核心组件，后面会详细的讲解。</strong></p>
<blockquote>
<p><code>StandardServer</code> 只是 Tomcat Server 的一个标准实现，相较于标准实现，它还有另外一个版本：<code>EmbeddedTomcat</code>，即内嵌的Tomcat。</p>
</blockquote>
<h4 id="初始化-Service-init"><a href="#初始化-Service-init" class="headerlink" title="初始化 Service.init()"></a>初始化 <code>Service.init()</code></h4><p>​    跟<code>Server</code>一样，<code>Service的</code>实现也叫<code>StandardService</code>，其初始化过程也是<code>StandardService.initInternal()</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">        engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any Executors</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">            ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize mapper listener</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize our defined Connectors</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">            connector.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    过程包括如下的几个核心点：</p>
<ol>
<li><p>初始化 <code>Engine</code>，<code>Engine</code>在整个Tomcat源码框架中的戏份不多，当用户的请求到来时，到<code>MapperData</code>中获取对应的<code>Host</code>，并让请求通过<code>Host</code>的<code>Pipeline</code>。</p>
</li>
<li><p>初始化 <code>Executor</code>，这是线程池的配置，在<code>server.xml</code>的中配置如下所示：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"</span></span><br><span class="line"><span class="comment">    maxThreads="150" minSpareThreads="4"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 <code>MapperListener</code>，这一步非常的简单，很容易就被忽略，但其实 <strong>非常非常</strong> 的重要，如果想要弄清楚Tomcat是如何分发路由请求，一定要了解这个组件。我的另外一篇文章<a href="#">Tomcat的路由游戏</a>对这个有详细的讲解。</p>
</li>
<li><p>初始化各个<code>Connector</code>，这个组件非常重要，这个我们单独用一节来讲解。</p>
</li>
</ol>
<h4 id="初始化-Connector-init"><a href="#初始化-Connector-init" class="headerlink" title="初始化 Connector.init()"></a>初始化 <code>Connector.init()</code></h4><p>​    <code>Connector</code>是整个Tomcat中比较重要的一个组件，甚至说是最核心的组件都不为过，它的主要任务是负责接收浏览器发过来的TCP连接请求，创建 <strong>Request</strong> 和 <strong>Response</strong> 对象来封装接收、发送数据，然后把数据交给Container进行处理。</p>
<p>​    如果你仔细查看过<code>server.xml</code>的话，会发现一个<code>Service</code>节点下可以有很多的<code>Connector</code>，每个<code>Connector</code>都可以监听不同的端口，采用不同的协议来和用户交互。如下所示（我们在<strong><em>8080</em></strong>端口监听普通的请求，在 <strong><em>8443</em></strong> 监听 SSL 请求）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8443"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SSLHostConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Certificate</span> <span class="attr">certificateKeystoreFile</span>=<span class="string">"conf/localhost-rsa.jks"</span> <span class="attr">type</span>=<span class="string">"RSA"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">SSLHostConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Connector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    当然以上这些工作都是在它启动之后，它的初始化过程其实是比较简单的，代码同样也是在<code>Connector.initInternal()</code>中，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">        setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">"coyoteConnector.protocolHandlerNoApr"</span>,</span><br><span class="line">                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">            protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">        AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">                (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">        <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">                jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">            jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    就是根据不同的<code>Connector</code>配置进行必要的设置（如<code>SSL</code>的支持等），之后就交给各个<code>ProtocolHandler</code>去根据不同的协议进行相应的初始化，常见的如<code>Http11NioProtocol</code>，<code>AjpNioProtocol</code>等。</p>
<h4 id="服务启动-Server-start（）"><a href="#服务启动-Server-start（）" class="headerlink" title="服务启动 Server.start（）"></a>服务启动 <code>Server.start（）</code></h4><p>​    随着<code>Connector</code>的初始化完成，<code>Server.load()</code>过程也结束，接下来就是<code>Server.start()</code>过程。</p>
<p>​    分析过<code>init()</code>方法后再来看其<code>start()</code>就简单得多了，几乎是整个<code>init()</code>过程的复制粘贴，只不过将过程中的<code>init()</code>方法换成了<code>start()</code>方法，<code>start()</code>方法让各个组件正式启动开始服役，为用户提供服务，各个<code>ProtocolHandler</code>开始监听网络端口，接收用户的请求并作出响应。</p>
<blockquote>
<p> 从这个过程中可以看到，Tomcat的整个容器构成是非常有层次的，分别是 <code>Server</code> -&gt; <code>Service</code> -&gt; <code>Connector</code>/ <code>Engine</code> -&gt;  <code>Host</code>。我有另外一篇文章专门讲解了这些组件之间的关系：<a href="#">Tomcat源码解读：组件</a>。</p>
</blockquote>
<p>​    这里要提一下我们的<code>Servlet</code>的注册入口，其实是隐藏在<code>Context.start()</code>过程中的，在这个过程中发布了一个事件<code>fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null);</code>，而这个事件会被<code>ContextConfig</code>捕获，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Identify the context we are associated with</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        context = (Context) event.getLifecycle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"contextConfig.cce"</span>, event.getLifecycle()), e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process the event that has occurred</span></span><br><span class="line">    <span class="keyword">if</span> (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里开始进行配置</span></span><br><span class="line">        configureStart();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) &#123;</span><br><span class="line">        beforeStart();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.AFTER_START_EVENT)) &#123;</span><br><span class="line">        <span class="comment">// Restore docBase for management tools</span></span><br><span class="line">        <span class="keyword">if</span> (originalDocBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">            context.setDocBase(originalDocBase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.CONFIGURE_STOP_EVENT)) &#123;</span><br><span class="line">        configureStop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.AFTER_INIT_EVENT)) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.AFTER_DESTROY_EVENT)) &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    一路跟踪的路径如下：<code>webConfig()</code> -&gt; <code>configureContext(webXml)</code> -&gt; <code>context.addServletMappingDecoded(urlPattern, jspServletName, true);</code> 这就是我们在<code>web.xml</code>中配置的所有的<code>Servlet</code>注册过程。</p>
<h3 id="优雅的关闭：ShutdownHook"><a href="#优雅的关闭：ShutdownHook" class="headerlink" title="优雅的关闭：ShutdownHook"></a>优雅的关闭：<code>ShutdownHook</code></h3><p>​    回过头去看<code>Catalina.start()</code>知道，在完成 <code>Server.start()</code> 后还有一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register shutdown hook</span></span><br><span class="line"><span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">        shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">    <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">    <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">    LogManager logManager = LogManager.getLogManager();</span><br><span class="line">    <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">        ((ClassLoaderLogManager) logManager).setUseShutdownHook(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这是一段标准的Java钩子函数的注册过程，<code>Runtime.getRuntime().addShutdownHook</code>注册的钩子将会在JVM退出时执行。</p>
<p>​    Tomcat在这里注册的钩子用于保证优雅的关闭Tomcat容器，包括关闭打开的JNDI资源，数据库驱动，关闭线程池，清理fork出来的子线程等等。部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clear references.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the JVM is shutting down, skip the memory leak checks</span></span><br><span class="line">    <span class="keyword">if</span> (skipMemoryLeakChecksOnJvmShutdown</span><br><span class="line">        &amp;&amp; !resources.getContext().getParent().getState().isAvailable()) &#123;</span><br><span class="line">        <span class="comment">// During reloading / redeployment the parent is expected to be</span></span><br><span class="line">        <span class="comment">// available. Parent is not available so this might be a JVM</span></span><br><span class="line">        <span class="comment">// shutdown.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread dummyHook = <span class="keyword">new</span> Thread();</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(dummyHook);</span><br><span class="line">            Runtime.getRuntime().removeShutdownHook(dummyHook);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException ise) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// De-register any remaining JDBC drivers</span></span><br><span class="line">    clearReferencesJdbc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop any threads the web application started</span></span><br><span class="line">    clearReferencesThreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear any references retained in the serialization caches</span></span><br><span class="line">    <span class="keyword">if</span> (clearReferencesObjectStreamClassCaches) &#123;</span><br><span class="line">        clearReferencesObjectStreamClassCaches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for leaks triggered by ThreadLocals loaded by this class loader</span></span><br><span class="line">    checkThreadLocalsForLeaks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear RMI Targets loaded by this class loader</span></span><br><span class="line">    <span class="keyword">if</span> (clearReferencesRmiTargets) &#123;</span><br><span class="line">        clearReferencesRmiTargets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Clear the IntrospectionUtils cache.</span></span><br><span class="line">    IntrospectionUtils.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the classloader reference in common-logging</span></span><br><span class="line">    <span class="keyword">if</span> (clearReferencesLogFactoryRelease) &#123;</span><br><span class="line">        org.apache.juli.logging.LogFactory.release(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the classloader reference in the VM's bean introspector</span></span><br><span class="line">    java.beans.Introspector.flushCaches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear any custom URLStreamHandlers</span></span><br><span class="line">    TomcatURLStreamHandlerFactory.release(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    那么，Tomcat是如何知道容器中有哪些由于用户的请求而<strong>fork</strong>出来的线程，并在关闭时及时的清理呢？可以关注我的另外一篇文章：<a href="#">Tomcat源码解读：Connector之一个请求的完整历程</a>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    至此，整个Tomcat的启动过程结束，可以看出还是比较 <strong>简洁</strong> 的，结构非常的清晰，遵循<code>Lifecycle</code>的生命周期，在<code>init</code>和<code>start</code>阶段就完整了整个容器的构建过程。</p>
<p>​    通过这个过程的分析我们可以学习到怎么构建一个层次分明的容器关系，怎么利用 <code>Lifecycle</code> 模式分而治之地编码，怎么优雅地关闭容器。同时也了解到Tomcat各个组件的关系及用途，能够更好地优化Tomcat的运行性能，进而定制更适合自己需要的Tomcat。</p>
]]></content>
      <tags>
        <tag>源码阅读</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat5.5下的jndi的配置</title>
    <url>/2008/03/17/tomcat5-5-xia-de-jndi-de-pei-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JNDI是J2EE中一个很重要的标准，通常我们是在J2EE编程中用到，Tomcat中提供了在JSP和Servelt中直接使用JNDI的方法，主要是通过dbcp连接池，下面谈一下我在Tomcat5.5中配置和使用JNDI的方法。 </p>
<a id="more"></a>
<h4 id="方法步骤"><a href="#方法步骤" class="headerlink" title="方法步骤"></a>方法步骤</h4><ol>
<li>先在自己应用程序WEB-INF目录下的web.xml添加以下语句： </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource-ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descrtiption</span>&gt;</span>引用资源说明<span class="tag">&lt;/<span class="name">descrtiption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">res-ref-name</span>&gt;</span>引用资源的JNDI名<span class="tag">&lt;/<span class="name">res-ref-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">res-type</span>&gt;</span>引用资源的类名<span class="tag">&lt;/<span class="name">res-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">res-auth</span>&gt;</span>管理者（Container）<span class="tag">&lt;/<span class="name">res-auth</span>&gt;</span><span class="comment">&lt;!--Container－容器管理 Application－Web应用管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource-ref</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后在tomcat目录/conf/server.xml文件里相应的<context>元素，添加如下子元素： </context></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"引用资源的JNDI名"</span> <span class="attr">auth</span>=<span class="string">"Container"</span> <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">driverClassName</span>=<span class="string">"com.pointbase.jdbc.jdbcUniversalDriver（自己的jdbc驱动）"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">url</span>=<span class="string">"jdbc:pointbase:server://localhost/acme（数据库连接url）"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">username</span>=<span class="string">"root（用户名）"</span> <span class="attr">password</span>=<span class="string">"root（密码）"</span> <span class="attr">maxActive</span>=<span class="string">"20（连接池dbcp的相关配置）"</span> <span class="attr">maxIdle</span>=<span class="string">"10"</span> <span class="attr">maxWait</span>=<span class="string">"10000"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> ：需要把你的驱动拷到 <em>common/lib</em> 下。</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在相应程序的web.xml里添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">resource-ref</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">res-ref-name</span>&gt;</span>jdbc/AcmeDB<span class="tag">&lt;/<span class="name">res-ref-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">res-type</span>&gt;</span>javax.sql.DataSource<span class="tag">&lt;/<span class="name">res-type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">res-auth</span>&gt;</span>Container<span class="tag">&lt;/<span class="name">res-auth</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource-ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后再 <em>tomcat/server.xml</em> 里修改： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/ACMEWeb"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> <span class="attr">docBase</span>=<span class="string">"E:\eclipseproject\ACMEWeb"</span> <span class="attr">workDir</span>=<span class="string">"E:\eclipseproject\ACMEWeb\work"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"jdbc/AcmeDB"</span> <span class="attr">auth</span>=<span class="string">"Container"</span> <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span> <span class="attr">driverClassName</span>=<span class="string">"com.pointbase.jdbc.jdbcUniversalDriver"</span> <span class="attr">url</span>=<span class="string">"jdbc:pointbase:server://localhost/acme"</span> <span class="attr">username</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> <span class="attr">maxActive</span>=<span class="string">"20"</span> <span class="attr">maxIdle</span>=<span class="string">"10"</span> <span class="attr">maxWait</span>=<span class="string">"10000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>建议你把上面的内容编写成为一个xml文件，拷到 <em>conf/Catalina/&lt;主机名&gt;/</em> 文件夹下。</p>
]]></content>
      <tags>
        <tag>Tomcat</tag>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat源码解读——Connector之一个请求的完整历程</title>
    <url>/2016/11/10/tomcat-yuan-ma-jie-du-connector/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    我们在<a href="#">Tomcat 源码解读——启动篇</a>中讲解过<strong>Connector</strong>的初始化过程，但并没有深入的去研究<code>Connector.strat</code>方法，以及启动后是怎么接收并处理用户请求的，本文将重点讲述这一过程。</p>
<a id="more"></a>
<h3 id="配置与协议"><a href="#配置与协议" class="headerlink" title="配置与协议"></a>配置与协议</h3><p>​    再回顾一下<strong>server.xml</strong>关于<code>Connector</code>的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    它位于<code>&lt;service&gt;</code>节点下，用来在具体的端口监听用户的请求，<code>&lt;Connector&gt;</code>节点可以有多个，每个都可以支援各种不同的协议，比如本例中一个用来监听<strong><em>8080</em></strong>端口，处理普通的用户请求，一个基于<strong>AJP</strong>协议在<strong><em>8009</em></strong>端口监听，用于与其它网络节点集成（比如<strong><em>Nginx</em></strong>）。</p>
<p>​    通常我们在做网络编程的时候，都逃不开如下3个步骤：</p>
<ol>
<li>监听端口，创建服务端与客户端的链接；</li>
<li>获取到客户端请求的socket数据，并对Socket数据进行解析和包装成Http请求数据格式；</li>
<li>将包装后的数据交给Container处理。</li>
</ol>
<p>​    那么<code>Connector</code>是如何完成如上3个步骤的？先给出结论，查看源码可以注意到它有两个非常重要的属性：<code>protocolHandler</code>和<code>adapter</code>。其中<code>protocolHandler</code>完成了上面步骤的（1）和（2），而（3）则是由<code>adapter</code>来完成的。</p>
<p>​    协议的设置在<code>conf/server.xml</code>中配置，由<code>setProtocol</code>来赋值，Tomcat提供了6种协议： </p>
<ul>
<li><p>三种不带<strong><em>Ajp</em></strong>的协议，客户端与Tomcat服务器直接连接。 </p>
<ol>
<li>Http11Protocol—————默认协议，阻塞IO方式的支持http1.1协议；</li>
<li>Http11NioProtocol———-非阻塞IO方式的支持http1.1协议 ；</li>
<li>Http11AprProtocol———-使用ARP技术的支持http1.1协议（ARP：Apache portable runtime) ；</li>
</ol>
</li>
<li><p>三种带<strong><em>Ajp</em></strong>的协议为定向包协议，即WEB服务器通过 TCP连接和SERVLET容器连接，例如tomcat和Apache、Nginx等前端服务器连接 </p>
<ol>
<li><p>AjpProtocol——————–阻塞IO方式的支持Ajp协议；</p>
</li>
<li><p>AjpNioProtocol—————非阻塞IO方式的支持Ajp协议；</p>
</li>
<li><p>AjpAprProtocol—————使用ARP技术的支持Ajp协议；</p>
</li>
</ol>
</li>
</ul>
<p>​    为了便于分析，之对Http11Protocol进行分析，其他的大同小异。</p>
<h3 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h3><p>​    我们看看 <code>Connector</code> 的启动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    跟进去协议处理器的启动方法，这个启动方法在<code>AbstractProtocol</code>中，是一个模板方法，所有的协议启动过程都是一样的，都是启动对应的 <code>Endpoint</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">    </span><br><span class="line">    endpoint.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这个<code>Endpoint</code>就是各个协议下，接收请求的入口，<strong><em>暴露</em></strong>给客户端的终点。我们以<code>Http11NioProtocol</code>为例，来看看接下来Tomcat是怎么处理的。</p>
<p>​    <code>Http11NioProtocol</code>的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Http11NioProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(<span class="keyword">new</span> NioEndpoint());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到这里指定一个自己专用的<code>NioEndpoint</code>，当然还有其它的一些构建过程，都交给父类去完成了，无非就是设置一下属性变量等，感兴趣的可以跟进去看看，这是不做讲解。</p>
<p>​     回到<code>start()</code>方法，我们看看<code>NioEndpoint.startInternal</code>方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化监听阀值</span></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动轮询线程，这是一个后台线程，根据状态将 socket 指派到合适的处理线程</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 启动监听线程</span></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    最后一行<code>startAcceptorThreads()</code>启动了N个线程来处理请求，我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Acceptor&lt;U&gt; acceptor = <span class="keyword">new</span> Acceptor&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">        String threadName = getName() + <span class="string">"-Acceptor-"</span> + i;</span><br><span class="line">        acceptor.setThreadName(threadName);</span><br><span class="line">        acceptors.add(acceptor);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(acceptor, threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    具体的线程执行过程是在<code>Acceptor</code>中，线程的核心代码在它的<code>run</code>方法中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">    int errorDelay = 0;</span><br><span class="line"></span><br><span class="line">    // Loop until we receive a shutdown command</span><br><span class="line">    while (endpoint.isRunning()) &#123;</span><br><span class="line">        // endpoint阻塞</span><br><span class="line">        while (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) &#123;</span><br><span class="line">            state = AcceptorState.PAUSED;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // Ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!endpoint.isRunning()) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.RUNNING;</span><br><span class="line">        try &#123;</span><br><span class="line">            //连接数到达最大值时，await等待释放connection，在Endpoint的startInterval方法中设置了最大连接数</span><br><span class="line">            endpoint.countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">            // Endpoint might have been paused while waiting for latch</span><br><span class="line">            // If that is the case, don&apos;t accept new connections</span><br><span class="line">            if (endpoint.isPaused()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //U是一个socketChannel</span><br><span class="line">            U socket = null;           </span><br><span class="line">            try &#123;</span><br><span class="line">                // 接收socket请求</span><br><span class="line">                socket = endpoint.serverSocketAccept();</span><br><span class="line">            &#125; catch (Exception ioe) &#123;</span><br><span class="line">                // We didn&apos;t get a socket</span><br><span class="line">                endpoint.countDownConnection();</span><br><span class="line">                if (endpoint.isRunning()) &#123;</span><br><span class="line">                    errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                    throw ioe;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // Successful accept, reset the error delay</span><br><span class="line">            errorDelay = 0;</span><br><span class="line"></span><br><span class="line">            // Configure the socket</span><br><span class="line">            if (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line">                // endpoint的setSocketOptions方法对socket进行配置</span><br><span class="line">                if (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                    endpoint.closeSocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                endpoint.destroySocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state = AcceptorState.ENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>源码阅读</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>URL 规范</title>
    <url>/2017/11/06/url-gui-fan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="模式规范"><a href="#模式规范" class="headerlink" title="模式规范"></a>模式规范</h4><blockquote>
<p><strong>强制</strong>：统一采用小写，并以中划线（-）作为分隔符，<strong>不得</strong> 进行驼峰式的大小写混合，<strong>不得</strong> 采用其它分割符。</p>
<p>比如：<a href="http://www.example.com/green-dress.html" target="_blank" rel="noopener">http://www.example.com/green-dress.html</a></p>
</blockquote>
<p><strong>参考文献</strong>：</p>
<ol>
<li>IETF 草案：<a href="https://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc1738.txt</a></li>
<li>来自Google的建议：<a href="https://support.google.com/webmasters/answer/76329" target="_blank" rel="noopener"><strong>“we recommend that you use hyphens (-) instead of underscores (_) in your URLs”</strong></a></li>
<li>参考文档：<a href="https://www.webfirm.com/blog/dash-or-underscore-in-url/" target="_blank" rel="noopener">Dash- or underscore_ in URL Web address?</a></li>
</ol>
<h4 id="URL-的生成与拼接"><a href="#URL-的生成与拼接" class="headerlink" title="URL 的生成与拼接"></a>URL 的生成与拼接</h4><blockquote>
<p><strong>建议：</strong> 采用 <code>UriComponent</code> 相关的组件，而非字符串拼接，可以避免较多的不规范及编码问题，如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(<span class="string">"http://www.example.com/query"</span>)</span><br><span class="line">                    .queryParam(<span class="string">"fromUserCode"</span>, config.getVmsFromUserCode())</span><br><span class="line">                    .queryParam(<span class="string">"toUserCode"</span>, account)</span><br><span class="line">                    .queryParam(<span class="string">"msgText"</span>, content);</span><br><span class="line"> log.info(<span class="string">"URL:&#123;&#125;"</span>, uriComponents.toUriString());</span><br></pre></td></tr></table></figure>
<p>​    更多的实用方法请自行查阅API。</p>
]]></content>
      <tags>
        <tag>规范与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>web上用Activex控件开发步骤(MFC)</title>
    <url>/2008/07/16/web-shang-yong-activex-kong-jian-kai-fa-bu-zou-mfc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先要说明的是 web上用activex是门被抛弃的技术。为什么这么说，主要基于以下几个原因：</p>
<ol>
<li>功能过于强大，强大到一旦安装，他所具有的权限可以做任何事，极易被人利用做坏事（相信大家都有浏览网页后莫名被安装流氓软件的经历，当然流氓软件利用的方式不止控件一种）；</li>
<li>通过网页下载控件的中间过程受到操作系统、杀毒软件、浏览器等多方面因素限制，这使你的控件产品未必能在所有用户的电脑上正常使用；</li>
<li>最恶心的一点，未签名没有正规安全证书的控件，在最新的浏览器上（IE7等）默认安全策略是直接屏蔽掉的，而你如果想要获取这个信任，需要向微软等少数单位申请，花费有多少？据说是每年4千多……</li>
</ol>
<p>看了以上如果你还是想要知道步骤，如下：</p>
<a id="more"></a>
<h4 id="一、用Vc-6-0新建工程里的向导创建MFC-activeX-controlWizard"><a href="#一、用Vc-6-0新建工程里的向导创建MFC-activeX-controlWizard" class="headerlink" title="一、用Vc++6.0新建工程里的向导创建MFC activeX controlWizard"></a>一、用Vc++6.0新建工程里的向导创建MFC activeX controlWizard</h4><p>细节不说了，根据你控件需要了，略有不同，问题不会太大。</p>
<h4 id="二、你控件代码的主xx-cpp（非xxCtr-cpp）文件中添加安全接口函数"><a href="#二、你控件代码的主xx-cpp（非xxCtr-cpp）文件中添加安全接口函数" class="headerlink" title="二、你控件代码的主xx.cpp（非xxCtr.cpp）文件中添加安全接口函数"></a>二、你控件代码的主xx.cpp（非xxCtr.cpp）文件中添加安全接口函数</h4><p>否则每次运行控件时IE都会给出安全提示，很烦！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comcat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Objsafe.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本控件的CLSID,注册表用</span></span><br><span class="line"><span class="keyword">const</span> GUID CDECL CLSID_SafeItem =&#123; <span class="number">0x7AE7497B</span>, <span class="number">0xCAD8</span>, <span class="number">0x4E66</span>, &#123; <span class="number">0xA5</span>,<span class="number">0x8B</span>,<span class="number">0xDD</span>,<span class="number">0xE9</span>,<span class="number">0xBC</span>,<span class="number">0xAF</span>,<span class="number">0x6B</span>,<span class="number">0x61</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 版本控制</span></span><br><span class="line"><span class="keyword">const</span> WORD _wVerMajor = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 次版本号</span></span><br><span class="line"><span class="keyword">const</span> WORD _wVerMinor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// CICCardApp::InitInstance - DLL initialization</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CICCardApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bInit = COleControlModule::InitInstance();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bInit)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bInit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// CICCardApp::ExitInstance - DLL termination</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CICCardApp::ExitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> COleControlModule::ExitInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建组件种类</span></span><br><span class="line"><span class="function">HRESULT <span class="title">CreateComponentCategory</span><span class="params">(CATID catid, WCHAR* catDescription)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ICatRegister* pcr = <span class="literal">NULL</span> ;</span><br><span class="line">	HRESULT hr = S_OK ;</span><br><span class="line"></span><br><span class="line">	hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,</span><br><span class="line">	<span class="literal">NULL</span>, CLSCTX_INPROC_SERVER, IID_ICatRegister, (<span class="keyword">void</span>**)&amp;pcr);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">	<span class="keyword">return</span> hr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure the HKCR\Component Categories\&#123;..catid...&#125;</span></span><br><span class="line">	<span class="comment">// key is registered.</span></span><br><span class="line">	CATEGORYINFO catinfo;</span><br><span class="line">	catinfo.catid = catid;</span><br><span class="line">	catinfo.lcid = <span class="number">0x0409</span> ; <span class="comment">// english</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure the provided description is not too long.</span></span><br><span class="line">	<span class="comment">// Only copy the first 127 characters if it is.</span></span><br><span class="line">	<span class="keyword">int</span> len = wcslen(catDescription);</span><br><span class="line">	<span class="keyword">if</span> (len&gt;<span class="number">127</span>)</span><br><span class="line">	len = <span class="number">127</span>;</span><br><span class="line">	wcsncpy(catinfo.szDescription, catDescription, len);</span><br><span class="line">	<span class="comment">// Make sure the description is null terminated.</span></span><br><span class="line">	catinfo.szDescription[len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	hr = pcr-&gt;RegisterCategories(<span class="number">1</span>, &amp;catinfo);</span><br><span class="line">	pcr-&gt;Release();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册组件种类</span></span><br><span class="line"><span class="function">HRESULT <span class="title">RegisterCLSIDInCategory</span><span class="params">(REFCLSID clsid, CATID catid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Register your component categories information.</span></span><br><span class="line">	ICatRegister* pcr = <span class="literal">NULL</span> ;</span><br><span class="line">	HRESULT hr = S_OK ;</span><br><span class="line">	hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,</span><br><span class="line">	<span class="literal">NULL</span>, CLSCTX_INPROC_SERVER, IID_ICatRegister, (<span class="keyword">void</span>**)&amp;pcr);</span><br><span class="line">	<span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Register this category as being "implemented" by the class.</span></span><br><span class="line">		CATID rgcatid[<span class="number">1</span>] ;</span><br><span class="line">		rgcatid[<span class="number">0</span>] = catid;</span><br><span class="line">		hr = pcr-&gt;RegisterClassImplCategories(clsid, <span class="number">1</span>, rgcatid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pcr != <span class="literal">NULL</span>)</span><br><span class="line">		pcr-&gt;Release();</span><br><span class="line">	<span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载组件种类</span></span><br><span class="line"><span class="function">HRESULT <span class="title">UnRegisterCLSIDInCategory</span><span class="params">(REFCLSID clsid, CATID catid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ICatRegister* pcr = <span class="literal">NULL</span> ;</span><br><span class="line">	HRESULT hr = S_OK ;</span><br><span class="line"></span><br><span class="line">	hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,</span><br><span class="line">	<span class="literal">NULL</span>, CLSCTX_INPROC_SERVER, IID_ICatRegister, (<span class="keyword">void</span>**)&amp;pcr);</span><br><span class="line">	<span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Unregister this category as being "implemented" by the class.</span></span><br><span class="line">		CATID rgcatid[<span class="number">1</span>] ;</span><br><span class="line">		rgcatid[<span class="number">0</span>] = catid;</span><br><span class="line">		hr = pcr-&gt;UnRegisterClassImplCategories(clsid, <span class="number">1</span>, rgcatid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pcr != <span class="literal">NULL</span>)</span><br><span class="line">	pcr-&gt;Release();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DllRegisterServer - Adds entries to the system registry</span></span><br><span class="line"><span class="function">STDAPI <span class="title">DllRegisterServer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HRESULT hr;</span><br><span class="line"></span><br><span class="line">	AFX_MANAGE_STATE(_afxModuleAddrThis);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))</span><br><span class="line">		<span class="keyword">return</span> ResultFromScode(SELFREG_E_TYPELIB);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))</span><br><span class="line">		<span class="keyword">return</span> ResultFromScode(SELFREG_E_CLASS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记控件初始化安全.</span></span><br><span class="line">	<span class="comment">// 创建初始化安全组件种类</span></span><br><span class="line">	hr = CreateComponentCategory(CATID_SafeForInitializing,</span><br><span class="line">	<span class="string">L"Controls safely initializable from persistent data!"</span>);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">		<span class="keyword">return</span> hr;</span><br><span class="line">	<span class="comment">// 注册初始化安全</span></span><br><span class="line">	hr = RegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForInitializing);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">		<span class="keyword">return</span> hr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记控件脚本安全</span></span><br><span class="line">	<span class="comment">// 创建脚本安全组件种类</span></span><br><span class="line">	hr = CreateComponentCategory(CATID_SafeForScripting, <span class="string">L"Controls safely scriptable!"</span>);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">		<span class="keyword">return</span> hr;</span><br><span class="line">	<span class="comment">// 注册脚本安全组件种类</span></span><br><span class="line">	hr = RegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForScripting);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">		<span class="keyword">return</span> hr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NOERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// DllUnregisterServer - Removes entries from the system registry</span></span><br><span class="line"></span><br><span class="line"><span class="function">STDAPI <span class="title">DllUnregisterServer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HRESULT hr;</span><br><span class="line"></span><br><span class="line">	AFX_MANAGE_STATE(_afxModuleAddrThis);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))</span><br><span class="line">		<span class="keyword">return</span> ResultFromScode(SELFREG_E_TYPELIB);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))</span><br><span class="line">		<span class="keyword">return</span> ResultFromScode(SELFREG_E_CLASS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除控件初始化安全入口.</span></span><br><span class="line">	hr=UnRegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForInitializing);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">		<span class="keyword">return</span> hr;</span><br><span class="line">	<span class="comment">// 删除控件脚本安全入口</span></span><br><span class="line">	hr=UnRegisterCLSIDInCategory(CLSID_SafeItem, CATID_SafeForScripting);</span><br><span class="line">	<span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">	<span class="keyword">return</span> hr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////</span></span><br><span class="line">	<span class="keyword">return</span> NOERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、添加自己的代码到控件文件xxCtr-cpp中"><a href="#三、添加自己的代码到控件文件xxCtr-cpp中" class="headerlink" title="三、添加自己的代码到控件文件xxCtr.cpp中"></a>三、添加自己的代码到控件文件xxCtr.cpp中</h4><p>这里最好通过向导添加 <strong>View-&gt;ClassWard-&gt;automation</strong>。</p>
<h4 id="四、编译生成你的xx-ocx控件文件"><a href="#四、编译生成你的xx-ocx控件文件" class="headerlink" title="四、编译生成你的xx.ocx控件文件"></a>四、编译生成你的xx.ocx控件文件</h4><p>这个文件其实就是个DLL函数库，只是后缀不同而已。</p>
<h4 id="五、制作xx-inf文件用于之后的空间打包压缩"><a href="#五、制作xx-inf文件用于之后的空间打包压缩" class="headerlink" title="五、制作xx.inf文件用于之后的空间打包压缩"></a>五、制作xx.inf文件用于之后的空间打包压缩</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[version]   signature="$CHICAGO$"   AdvancedINF=1.0   [Add.Code]   xx.ocx=xx.ocx   [xx.ocx]   file-win32-x86=thiscab   clsid=&#123;351FC603-D784-4B8D-BA2C-33C212EC5BAA&#125;   FileVersion=1,0,0,1   RegisterServer=yes</span><br></pre></td></tr></table></figure>
<h4 id="六、打包压缩成xx-cab文件"><a href="#六、打包压缩成xx-cab文件" class="headerlink" title="六、打包压缩成xx.cab文件"></a>六、打包压缩成xx.cab文件</h4><p>你需要用到给控件签名的一些工具：cabarc.exe、signcode.exe,另外你可能需要用于制作自己试验证书的工具：makecert.exe、cert2spc.exe。<br>制作根证书MyCert.cer和私钥myKey.PVK：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">makecert -r  -sv "myKey.PVK"  -n CN="xx Electric Industry Co. Ltd."   MyCert.cer</span><br><span class="line">CERT2SPC MyOKIcert.cer MyOKIcert.spc打包压缩空间为xx.cab：</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cabarc -s 6144 n xx.cab xx.ocx xx.inf</span><br></pre></td></tr></table></figure>
<p>数字签名cab文件<br>双击signocode.exe文件，图形化签名，注意要通过自定义选择自己的证书和私钥而不是选择系统已有的。</p>
<h4 id="七、在你要用空间的Web上添加代码："><a href="#七、在你要用空间的Web上添加代码：" class="headerlink" title="七、在你要用空间的Web上添加代码："></a>七、在你要用空间的Web上添加代码：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">'t1'</span> <span class="attr">codeBase</span>=<span class="string">/UserMode/xx.cab#version</span>=<span class="string">1,0,0,1</span> <span class="attr">classid</span>=<span class="string">'clsid:F3530445-A287-4A0B-AC3E-C4AF2B63EBA7'</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">width</span>=<span class="string">0</span> &gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="八、调用控件内方法。"><a href="#八、调用控件内方法。" class="headerlink" title="八、调用控件内方法。"></a>八、调用控件内方法。</h4><p>通过javascript直接调用控件对象的方法就行了，比如调用空间中存在的一个download()方法： <em>document.getElementByID(“t1”).download();</em>八。客户端使用，其他人从网上下载到你的控件后，如果是Window XP系统的话，需要先导入证书为可信任（详细到Google上搜索导入证书，很容易），再安装控件，之后才能用；而如果是Window2000用户则只要安装控件就可以使用了。</p>
<h4 id="九、控件的删除"><a href="#九、控件的删除" class="headerlink" title="九、控件的删除"></a>九、控件的删除</h4><p>Internet选项-〉设定-〉显示对象，直接看到你的xx.cab文件，Del掉就行了，注册表中信息会自动消除掉，当然你也可以直接到注册表中删除对应xx.inf中列出的键值的项。</p>
<h4 id="十、升级"><a href="#十、升级" class="headerlink" title="十、升级"></a>十、升级</h4><p>只要在源代码中更改xx.rc文件中对应的那些1.0.0.1为你的新版本号，并同时更改你调用控件的web上的版本号就可以了，下一次客户访问这个页面时会自动提示安装新控件，新控件会覆盖就版本的控件。</p>
<p>以上仅供参考，本人也是新手，最近工作需要用控件才能完成一些功能，以上包含了我开发过程中碰到的诸多问题，希望对所有人能有所帮助</p>
]]></content>
      <tags>
        <tag>UED</tag>
        <tag>activeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat源码解读——Mapper的路由游戏</title>
    <url>/2016/11/10/tomcat-yuan-ma-jie-du-lu-you-you-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>在<a href="#">Tomcat 源码解读——启动篇</a>中我们讲解到一个概念：<code>Mapper</code>，它是用来匹配用户的请求，并将请求路由到指定的容器进行处理的关键组件，本文将通过源码分析来了解这个组件的生命周期及运作原理。</p>
</blockquote>
<a id="more"></a>
<p>​    设想一下，当用户通过 URL (<a href="http://www.doleje.com/petstore/hello.jsp" target="_blank" rel="noopener">http://www.doleje.com/petstore/hello.jsp</a>) 请求我们的应用时，Tomcat该如何将这个请求正确地路由到我们指定的<code>Servlet</code>上呢？我们按照Tomcat的组件关系，可以将这个 URL 拆分成如下的几个部分：</p>
<ol>
<li><p><code>Host</code>：<a href="http://www.doleje.com" target="_blank" rel="noopener">www.doleje.com</a></p>
</li>
<li><p><code>Context</code>： petstore</p>
</li>
<li><p><code>ServletWrapper</code>：Hello</p>
</li>
</ol>
<p>​    换句话来说，就是Tomcat是如何将这个请求转到对应的 <code>Host</code> -&gt; <code>Context</code> -&gt; <code>Servlet</code> 上的呢？我们来慢慢分析。</p>
<h3 id="Mapper-相关的模型及概念"><a href="#Mapper-相关的模型及概念" class="headerlink" title="Mapper 相关的模型及概念"></a><code>Mapper</code> 相关的模型及概念</h3><p>​    从名称来看，这是一个映射关系，确实，Tomcat给它的定义也是将一个名称绑定到组件上，通过名称就能找到对应的组件。实际上，它是Tomcat对于<a href="https://javaee.github.io/servlet-spec/" target="_blank" rel="noopener">Servlet规范</a>中<strong>Servlet Rules</strong>的一个实现，它规范了资源如何映射的规则。</p>
<p>​    <code>MapElement</code>是构成映射关系的基本元素，它简单地定义了一个名称对应的组件是什么，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapElement</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapElement</span><span class="params">(String name, T object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    由它派生出来的则有：<code>MappedHost</code>表示 <code>Host</code>的映射关系，<code>MappedContext</code>表示<code>Context</code>的映射关系以及<code>MappedWrapper</code>表示一个 <code>ServletWrapper</code>的映射（至于<code>Servlet</code>为什么叫<code>Wapper</code>后文再述）。具体的源码都就不帖出来了，感兴趣的同学可以自行去翻阅，它们的关系如下图所示：</p>
<p><img src="E:\分享与培训\mapper组件关系图.jpg" alt="mapper组件关系图"></p>
<p>​    可以看到，它其实跟我们的Tomcat容器的层次结构是一样的，每个组件都唯一的<strong>路径+名称</strong>来标识，这样，当用户的请求过来时，各个层次分别根据当前的环境和自己维护的映射关系，一层一层的往下查找，直到找到对应的<code>MappedWrapper</code>或者抛出<strong><em>404</em></strong>。</p>
<h3 id="路由过程"><a href="#路由过程" class="headerlink" title="路由过程"></a>路由过程</h3><p>​    为了有一个更直观的认知，我们先暂时跳过<code>Mapper</code>的初始化构建过程，来看看当<code>Mapper</code>构建完成后，Tomcat是怎么根据用户的请求依次路由定位到这个<code>Mapper</code>找到最终的处理单元的。</p>
<p>​    在文章<a href="#">Tomcat源码解读：Connector之一个请求的完整历程</a>中我们讲解了，当一个请求到达Tomcat时，是由<code>Connector</code>创建了一个<code>CoyoteAdapter</code>用于处理请求的，以<code>Http11Processor</code>为例，在其<code>service()</code>方法中相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketState <span class="title">service</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!getErrorState().isError() &amp;&amp; keepAlive &amp;&amp; !isAsync() &amp;&amp; upgradeToken == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            sendfileState == SendfileState.DONE &amp;&amp; !protocol.isPaused()) &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process the request in the adapter</span></span><br><span class="line">		<span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">		    <span class="keyword">try</span> &#123;</span><br><span class="line">		        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 交由 adapter 去处理请求</span></span><br><span class="line">		        getAdapter().service(request, response);</span><br><span class="line">		        <span class="comment">// Handle when the response was committed before a serious</span></span><br><span class="line">		        <span class="comment">// error occurred.  Throwing a ServletException should both</span></span><br><span class="line">		        <span class="comment">// set the status to 500 and set the errorException.</span></span><br><span class="line">		        <span class="comment">// If we fail here, then the response is likely already</span></span><br><span class="line">		        <span class="comment">// committed, so we can't try and set headers.</span></span><br><span class="line">		        <span class="keyword">if</span>(keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; !isAsync() &amp;&amp;</span><br><span class="line">		                statusDropsConnection(response.getStatus())) &#123;</span><br><span class="line">		            setErrorState(ErrorState.CLOSE_CLEAN, <span class="keyword">null</span>);</span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</span><br><span class="line">		        setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">		    &#125; <span class="keyword">catch</span> (HeadersTooLargeException e) &#123;</span><br><span class="line">		        log.error(sm.getString(<span class="string">"http11processor.request.process"</span>), e);</span><br><span class="line">		        <span class="comment">// The response should not have been committed but check it</span></span><br><span class="line">		        <span class="comment">// anyway to be safe</span></span><br><span class="line">		        <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">		            setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">		        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		            response.reset();</span><br><span class="line">		            response.setStatus(<span class="number">500</span>);</span><br><span class="line">		            setErrorState(ErrorState.CLOSE_CLEAN, e);</span><br><span class="line">		            response.setHeader(<span class="string">"Connection"</span>, <span class="string">"close"</span>); <span class="comment">// <span class="doctag">TODO:</span> Remove</span></span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">		        ExceptionUtils.handleThrowable(t);</span><br><span class="line">		        log.error(sm.getString(<span class="string">"http11processor.request.process"</span>), t);</span><br><span class="line">		        <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">		        response.setStatus(<span class="number">500</span>);</span><br><span class="line">		        setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">		        getAdapter().log(request, response, <span class="number">0</span>);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 省略非关注点代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略非关注点代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到，最终请求是交给了<code>CoyoteAdapter.service</code>去处理，其中关于<code>Mapper</code>的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意看这里，Mapper 的设置入口就是在这里</span></span><br><span class="line">        postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">//check valves if we support async</span></span><br><span class="line">            request.setAsyncSupported(</span><br><span class="line">                    connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">            <span class="comment">// Calling the container</span></span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                    request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>Mapper</code>的路由过程是在<strong>Request</strong>的头信息解析完成之后进行的，在<code>postParseRequest(req, request, res, response)</code>方法中我们可以找到相关的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">postParseRequest</span><span class="params">(org.apache.coyote.Request req, Request request,</span></span></span><br><span class="line"><span class="function"><span class="params">        org.apache.coyote.Response res, Response response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mapRequired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.isError()) &#123;</span><br><span class="line">        <span class="comment">// An error this early means the URI is invalid. Ensure invalid data</span></span><br><span class="line">        <span class="comment">// is not passed to the mapper. Note we still want the mapper to</span></span><br><span class="line">        <span class="comment">// find the correct host.</span></span><br><span class="line">        decodedURI.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mapRequired) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 Service 的 Mapper 来设置 request mappering data</span></span><br><span class="line">        connector.getService().getMapper().map(serverName, decodedURI,</span><br><span class="line">                version, request.getMappingData());</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mapRequired = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (version != <span class="keyword">null</span> &amp;&amp; request.getContext() == versionContext) &#123;</span><br><span class="line">            <span class="comment">// We got the version that we asked for. That is it.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            version = <span class="keyword">null</span>;</span><br><span class="line">            versionContext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            Context[] contexts = request.getMappingData().contexts;</span><br><span class="line">            <span class="comment">// Single contextVersion means no need to remap</span></span><br><span class="line">            <span class="comment">// No session ID means no possibility of remap</span></span><br><span class="line">            <span class="keyword">if</span> (contexts != <span class="keyword">null</span> &amp;&amp; sessionID != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Find the context associated with the session</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = contexts.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    Context ctxt = contexts[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (ctxt.getManager().findSession(sessionID) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// We found a context. Is it the one that has</span></span><br><span class="line">                        <span class="comment">// already been mapped?</span></span><br><span class="line">                        <span class="keyword">if</span> (!ctxt.equals(request.getMappingData().context)) &#123;</span><br><span class="line">                            <span class="comment">// Set version so second time through mapping</span></span><br><span class="line">                            <span class="comment">// the correct context is found</span></span><br><span class="line">                            version = ctxt.getWebappVersion();</span><br><span class="line">                            versionContext = ctxt;</span><br><span class="line">                            <span class="comment">// Reset mapping</span></span><br><span class="line">                            request.getMappingData().recycle();</span><br><span class="line">                            mapRequired = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="comment">// Recycle cookies and session info in case the</span></span><br><span class="line">                            <span class="comment">// correct context is configured with different</span></span><br><span class="line">                            <span class="comment">// settings</span></span><br><span class="line">                            request.recycleSessionInfo();</span><br><span class="line">                            request.recycleCookieInfo(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mapRequired &amp;&amp; request.getContext().getPaused()) &#123;</span><br><span class="line">            <span class="comment">// Found a matching context but it is paused. Mapping data will</span></span><br><span class="line">            <span class="comment">// be wrong since some Wrappers may not be registered at this</span></span><br><span class="line">            <span class="comment">// point.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// Should never happen</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Reset mapping</span></span><br><span class="line">            request.getMappingData().recycle();</span><br><span class="line">            mapRequired = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    核心代码就在于<code>connector.getService().getMapper().map(serverName, decodedURI, version, request.getMappingData())</code>，我们进入这个方法看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">internalMap</span><span class="params">(CharChunk host, CharChunk uri,</span></span></span><br><span class="line"><span class="function"><span class="params">        String version, MappingData mappingData)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappingData.host != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The legacy code (dating down at least to Tomcat 4.1) just</span></span><br><span class="line">        <span class="comment">// skipped all mapping work in this case. That behaviour has a risk</span></span><br><span class="line">        <span class="comment">// of returning an inconsistent result.</span></span><br><span class="line">        <span class="comment">// I do not see a valid use case for it.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Virtual host mapping</span></span><br><span class="line">    MappedHost[] hosts = <span class="keyword">this</span>.hosts;</span><br><span class="line">    MappedHost mappedHost = exactFindIgnoreCase(hosts, host);</span><br><span class="line">    <span class="keyword">if</span> (mappedHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Note: Internally, the Mapper does not use the leading * on a</span></span><br><span class="line">        <span class="comment">//       wildcard host. This is to allow this shortcut.</span></span><br><span class="line">        <span class="keyword">int</span> firstDot = host.indexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (firstDot &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offset = host.getOffset();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                host.setOffset(firstDot + offset);</span><br><span class="line">                mappedHost = exactFindIgnoreCase(hosts, host);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Make absolutely sure this gets reset</span></span><br><span class="line">                host.setOffset(offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mappedHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mappedHost = defaultHost;</span><br><span class="line">            <span class="keyword">if</span> (mappedHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mappingData.host = mappedHost.object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uri.isNull()) &#123;</span><br><span class="line">        <span class="comment">// Can't map context or wrapper without a uri</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uri.setLimit(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Context mapping</span></span><br><span class="line">    ContextList contextList = mappedHost.contextList;</span><br><span class="line">    MappedContext[] contexts = contextList.contexts;</span><br><span class="line">    <span class="keyword">int</span> pos = find(contexts, uri);</span><br><span class="line">    <span class="keyword">if</span> (pos == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastSlash = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> uriEnd = uri.getEnd();</span><br><span class="line">    <span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    MappedContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        context = contexts[pos];</span><br><span class="line">        <span class="keyword">if</span> (uri.startsWith(context.name)) &#123;</span><br><span class="line">            length = context.name.length();</span><br><span class="line">            <span class="keyword">if</span> (uri.getLength() == length) &#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uri.startsWithIgnoreCase(<span class="string">"/"</span>, length)) &#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastSlash == -<span class="number">1</span>) &#123;</span><br><span class="line">            lastSlash = nthSlash(uri, contextList.nesting + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastSlash = lastSlash(uri);</span><br><span class="line">        &#125;</span><br><span class="line">        uri.setEnd(lastSlash);</span><br><span class="line">        pos = find(contexts, uri);</span><br><span class="line">    &#125;</span><br><span class="line">    uri.setEnd(uriEnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="keyword">if</span> (contexts[<span class="number">0</span>].name.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            context = contexts[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mappingData.contextPath.setString(context.name);</span><br><span class="line"></span><br><span class="line">    ContextVersion contextVersion = <span class="keyword">null</span>;</span><br><span class="line">    ContextVersion[] contextVersions = context.versions;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> versionCount = contextVersions.length;</span><br><span class="line">    <span class="keyword">if</span> (versionCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Context[] contextObjects = <span class="keyword">new</span> Context[contextVersions.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contextObjects.length; i++) &#123;</span><br><span class="line">            contextObjects[i] = contextVersions[i].object;</span><br><span class="line">        &#125;</span><br><span class="line">        mappingData.contexts = contextObjects;</span><br><span class="line">        <span class="keyword">if</span> (version != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contextVersion = exactFind(contextVersions, version);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (contextVersion == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return the latest version</span></span><br><span class="line">        <span class="comment">// The versions array is known to contain at least one element</span></span><br><span class="line">        contextVersion = contextVersions[versionCount - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    mappingData.context = contextVersion.object;</span><br><span class="line">    mappingData.contextSlashCount = contextVersion.slashCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrapper mapping</span></span><br><span class="line">    <span class="keyword">if</span> (!contextVersion.isPaused()) &#123;</span><br><span class="line">        internalMapWrapper(contextVersion, uri, mappingData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    过程描述如下：</p>
<ol>
<li><p>根据请求的<strong>Host</strong>去<code>Mapper</code>表中查找<code>MappedHost</code>，这个过程其实就是简单的字符串匹配。</p>
</li>
<li><p>之后根据请求的<strong>Context</strong>信息在<code>MappedHost</code>中的<code>ContextList</code>中去匹配，找到对应的<code>MappedContext</code>。</p>
</li>
<li><p>在该方法的最后，进一步的在<code>ContextVersion</code>中去查找<code>ServletWrapper</code>的<code>Mapper</code>。</p>
</li>
</ol>
<blockquote>
<p>关于 <code>ContextVersion</code> 的概念可能大家平时关注得比较少，这个是Tomcat对于<strong>Parallel Deployment</strong>的体现，就是同一个应用可以有多个版本在部署并服务。试想一下，如果一个正在运行的服务需要新的功能或者有BUG FIX需要重新部署，但是又不能停机的时候该怎么办呢？</p>
<p>在现代的集群时代，可以采用蓝绿发布或者金丝雀发现就可以很好的解决，但是在单例时代该怎么办呢？Tomcat给出的答案就是<strong>Parallel Deployment</strong>，可以同时部署应用的多个版本，而且请求的path保持一致。这真是个好消息。对于部署新版本之后到达的请求，默认会使用新版本来处理，对于旧的请求，由于session中已经包含请求数据，所以会继续处理，直到完成。</p>
</blockquote>
<p>​    直到这时，Tomcat仍然只是将我们的请求定位到了<code>Context</code>这一层，也就是我们的一个应用。再往下就是如何定位到我们处理请求的<strong>Servlet，</strong>这个过程在<code>internalMapWrapper(contextVersion, uri, mappingData)</code>中。这个过程代码比较长，因为场景比较多，总结起来就是如下的五个步骤（四个子嵌套），每一步找到了就直接返回，否则进入下一步：</p>
<ol>
<li>根据<strong>path</strong>严格匹配，比如<strong><em>/user/list</em></strong>。</li>
<li>根据前缀查找，比如：<strong>*/user/**</strong>。</li>
<li>根据扩展后缀查找，比如：<strong><em>\</em>.do*</strong>。</li>
<li>查找是否是欢迎页面，也就是我们在<code>web.xml</code>中配置的<code>&lt;welcome-file-list&gt;</code>节点内容，这里又分为如下三种情况：<ul>
<li>精确匹配</li>
<li>前缀匹配</li>
<li>指定文件</li>
<li>如果指定的文件不存在，则进行后缀扩展查找</li>
</ul>
</li>
<li>如果还没有找到对应的<code>Mapper</code>，则返回默认的，初始化的时候会讲解默认的 <code>ServletMapper</code>来源。</li>
</ol>
<p>​    另外，在由于在创建<code>Mapper</code>的时候，Tomcat将所有的候选项都放入了一个排序好的数组中，所以在这个查找过程中采用了 <strong>二分法</strong> 进行查找，以提高效率，感兴趣的同学可以去<code>find()</code>方法中查看。</p>
<blockquote>
<p>注：以上的匹配过程是有严格的先后顺序的，我们在配置或者调试的时候需要注意。同时，我们也可以看到<code>&lt;welcome-file-list&gt;</code>的配置也是有先后顺序的。</p>
</blockquote>
<h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p>​    说完了根据请求查找具体<code>Mapper</code>的过程，我们再来分析看看这个这个映射关系的数据结构是如何构建的。我们在<a href="#">Tomcat 源码解读——启动篇</a>中已经提到了一点，就是<code>MapperListener</code>的初始化及启动过程，代码只有一行：<code>mapperListener.start();</code>。我们看看这个方法的核心代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    Engine engine = service.getContainer();</span><br><span class="line">    <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findDefaultHost();</span><br><span class="line"></span><br><span class="line">    addListeners(engine);</span><br><span class="line"></span><br><span class="line">    Container[] conHosts = engine.findChildren();</span><br><span class="line">    <span class="keyword">for</span> (Container conHost : conHosts) &#123;</span><br><span class="line">        Host host = (Host) conHost;</span><br><span class="line">        <span class="keyword">if</span> (!LifecycleState.NEW.equals(host.getState())) &#123;</span><br><span class="line">            <span class="comment">// Registering the host will register the context and wrappers</span></span><br><span class="line">            registerHost(host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    首先获取当前的引擎以及默认的<code>Host</code>，对应<code>server.xml</code>中的如下配置：<code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code>。</p>
<p>​    接着监听这个<code>Engine</code>，<code>addListeners(engine)</code>代码如下，除了监听<code>Engine</code>本身外，还监听了所有的孩子组件，主要就是<code>Host</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addListeners</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    container.addContainerListener(<span class="keyword">this</span>);</span><br><span class="line">    container.addLifecycleListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span> (Container child : container.findChildren()) &#123;</span><br><span class="line">        addListeners(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这里我们有必要介绍一下<code>MapperListener</code>的继承关系图，如下所示，它继承了<code>LifecycleListener</code>，<code>LifecycleMBeanBase</code>, <code>ContainerListener</code>，可以看出它除了能监听组件本身外，如果组件是一个容器类的，那么它还能监听容器的相关操作。</p>
<p><img src="E:\分享与培训\mapper-listener继承关系.jpg" alt="mapper-listener继承关系"></p>
<h4 id="注册Host"><a href="#注册Host" class="headerlink" title="注册Host"></a>注册<code>Host</code></h4><p>​    具体监听做了什么事情我们晚点再分析，接着分析代码就是遍历所有的<code>Host</code>并执行<code>registerHost(host)</code>方法，我们看看这个方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHost</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String[] aliases = host.findAliases();</span><br><span class="line">    mapper.addHost(host.getName(), aliases, host);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Container container : host.findChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (container.getState().isAvailable()) &#123;</span><br><span class="line">            registerContext((Context) container);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default host may have changed</span></span><br><span class="line">    findDefaultHost();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(sm.getString(<span class="string">"mapperListener.registerHost"</span>,</span><br><span class="line">                host.getName(), domain, service));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    先是直接调用<code>mapper.addHost</code>将当前的<code>Host</code>注册到<code>Mapper</code>中去，具体的注册过程代码就不贴出来了，就是维护了一个<code>MappedHost</code>的数组用于保存这种映射关系。需要注意的是<strong>这里的<code>MappedHost</code>数组是排序的，好处是在路由查找的时候可以进行二分法来提高效率</strong>。</p>
<h4 id="注册-Context"><a href="#注册-Context" class="headerlink" title="注册 Context"></a>注册 <code>Context</code></h4><p>​    接下来就是遍历该<code>Host</code>下的<code>Context</code>并依次注册过程，我们看看<code>registerContext(context)</code>的方法又有哪些不同，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String contextPath = context.getPath();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(contextPath)) &#123;</span><br><span class="line">        contextPath = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Host host = (Host)context.getParent();</span><br><span class="line"></span><br><span class="line">    WebResourceRoot resources = context.getResources();</span><br><span class="line">    String[] welcomeFiles = context.findWelcomeFiles();</span><br><span class="line">    List&lt;WrapperMappingInfo&gt; wrappers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Container container : context.findChildren()) &#123;</span><br><span class="line">        prepareWrapperMappingInfo(context, (Wrapper) container, wrappers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">"mapperListener.registerWrapper"</span>,</span><br><span class="line">                    container.getName(), contextPath, service));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapper.addContextVersion(host.getName(), host, contextPath,</span><br><span class="line">            context.getWebappVersion(), context, welcomeFiles, resources,</span><br><span class="line">            wrappers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(sm.getString(<span class="string">"mapperListener.registerContext"</span>,</span><br><span class="line">                contextPath, service));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    其实和<code>registerHost</code>的流程是差不多的，在<code>addContextVersion</code>中只不过多了一个查找对应 <code>Host</code> 的过程，关于<code>ContextVersion</code>的概念前面已经提过了，大部分情况下是可以解理为一个应用的。</p>
<h4 id="注册-Wrapper"><a href="#注册-Wrapper" class="headerlink" title="注册 Wrapper"></a>注册 <code>Wrapper</code></h4><p>​    看到这里我们惊奇地发现整个注册过程结束了，为什么没有看到具体的<code>ServletWrapper</code>的注册过程？如果真的的至此结束，请求是如何找到对应的<code>Servlet</code>的？很显然还有其它的操作未完成。</p>
<p>​    其实<code>Wrapper</code>的注册过程是在监听器过程中完成的，还记得我们之前提到的监听器层次模型，以及通过<code>addListeners</code>方法添加的监听器吗？我们现在看看这些监听器是做什么的。</p>
<p>​    在此，我们先回顾一下在<a href="#">Tomcat 源码解读——启动篇</a>中<a href="#">服务启动 `Server.start（）</a>这一节中关于扫描<code>web.xml</code>并添加<code>Servlet</code>的过程。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServletMappingDecoded</span><span class="params">(String pattern, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> jspWildCard)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Validate the proposed mapping</span></span><br><span class="line">        <span class="keyword">if</span> (findChild(name) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">                (sm.getString(<span class="string">"standardContext.servletMap.name"</span>, name));</span><br><span class="line">        String adjustedPattern = adjustURLPattern(pattern);</span><br><span class="line">        <span class="keyword">if</span> (!validateURLPattern(adjustedPattern))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException</span><br><span class="line">                (sm.getString(<span class="string">"standardContext.servletMap.pattern"</span>, adjustedPattern));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add this mapping to our registered set</span></span><br><span class="line">        <span class="keyword">synchronized</span> (servletMappingsLock) &#123;</span><br><span class="line">            String name2 = servletMappings.get(adjustedPattern);</span><br><span class="line">            <span class="keyword">if</span> (name2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Don't allow more than one servlet on the same pattern</span></span><br><span class="line">                Wrapper wrapper = (Wrapper) findChild(name2);</span><br><span class="line">                wrapper.removeMapping(adjustedPattern);</span><br><span class="line">            &#125;</span><br><span class="line">            servletMappings.put(adjustedPattern, name);</span><br><span class="line">        &#125;</span><br><span class="line">        Wrapper wrapper = (Wrapper) findChild(name);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 在这里添加 Servlet 的映射关系</span></span><br><span class="line">        wrapper.addMapping(adjustedPattern);</span><br><span class="line"></span><br><span class="line">        fireContainerEvent(<span class="string">"addServletMapping"</span>, adjustedPattern);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    我们进入这个<code>addMapping</code>方法看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMapping</span><span class="params">(String mapping)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mappingsLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mappings.add(mapping);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mappingsLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发布映射关系添加的事件</span></span><br><span class="line">    <span class="keyword">if</span>(parent.getState().equals(LifecycleState.STARTED))</span><br><span class="line">        fireContainerEvent(ADD_MAPPING_EVENT, mapping);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    除了常规的添加 <strong>Servlet</strong> 映射关系外还有非常重要的一点是发布了一个事件：<code>ADD_MAPPING_EVENT</code>，这个事件的刚好就是为了今天我们讲解的<code>Wrapper</code>注册过程服务的。在<code>MapperListener</code>的事件监听代码中对于这个事件的处理如下（省略了其它事件的处理代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">containerEvent</span><span class="params">(ContainerEvent event)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (Wrapper.ADD_MAPPING_EVENT.equals(event.getType())) &#123;</span><br><span class="line">        <span class="comment">// Handle dynamically adding wrappers</span></span><br><span class="line">        Wrapper wrapper = (Wrapper) event.getSource();</span><br><span class="line">        Context context = (Context) wrapper.getParent();</span><br><span class="line">        String contextPath = context.getPath();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"/"</span>.equals(contextPath)) &#123;</span><br><span class="line">            contextPath = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String version = context.getWebappVersion();</span><br><span class="line">        String hostName = context.getParent().getName();</span><br><span class="line">        String wrapperName = wrapper.getName();</span><br><span class="line">        String mapping = (String) event.getData();</span><br><span class="line">        <span class="keyword">boolean</span> jspWildCard = (<span class="string">"jsp"</span>.equals(wrapperName)</span><br><span class="line">                &amp;&amp; mapping.endsWith(<span class="string">"/*"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册 ServletWrapper 到 Mapper 中</span></span><br><span class="line">        mapper.addWrapper(hostName, contextPath, version, mapping, wrapper,</span><br><span class="line">                jspWildCard, context.isResourceOnlyServlet(wrapperName));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到这里解析了这个<code>ServletMapping</code>相关的信息后，将这个映射关系注册到了<code>Mapper</code>中去了，具体的过程在<code>mapper.addWrapper</code>中，我们看看这个过程又是怎样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addWrapper</span><span class="params">(ContextVersion context, String path,</span></span></span><br><span class="line"><span class="function"><span class="params">            Wrapper wrapper, <span class="keyword">boolean</span> jspWildCard, <span class="keyword">boolean</span> resourceOnly)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (context) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.endsWith(<span class="string">"/*"</span>)) &#123;</span><br><span class="line">            <span class="comment">// Wildcard wrapper</span></span><br><span class="line">            String name = path.substring(<span class="number">0</span>, path.length() - <span class="number">2</span>);</span><br><span class="line">            MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(name, wrapper,</span><br><span class="line">                    jspWildCard, resourceOnly);</span><br><span class="line">            MappedWrapper[] oldWrappers = context.wildcardWrappers;</span><br><span class="line">            MappedWrapper[] newWrappers = <span class="keyword">new</span> MappedWrapper[oldWrappers.length + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (insertMap(oldWrappers, newWrappers, newWrapper)) &#123;</span><br><span class="line">                context.wildcardWrappers = newWrappers;</span><br><span class="line">                <span class="keyword">int</span> slashCount = slashCount(newWrapper.name);</span><br><span class="line">                <span class="keyword">if</span> (slashCount &gt; context.nesting) &#123;</span><br><span class="line">                    context.nesting = slashCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.startsWith(<span class="string">"*."</span>)) &#123;</span><br><span class="line">            <span class="comment">// Extension wrapper</span></span><br><span class="line">            String name = path.substring(<span class="number">2</span>);</span><br><span class="line">            MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(name, wrapper,</span><br><span class="line">                    jspWildCard, resourceOnly);</span><br><span class="line">            MappedWrapper[] oldWrappers = context.extensionWrappers;</span><br><span class="line">            MappedWrapper[] newWrappers =</span><br><span class="line">                <span class="keyword">new</span> MappedWrapper[oldWrappers.length + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (insertMap(oldWrappers, newWrappers, newWrapper)) &#123;</span><br><span class="line">                context.extensionWrappers = newWrappers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="comment">// Default wrapper</span></span><br><span class="line">            MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(<span class="string">""</span>, wrapper,</span><br><span class="line">                    jspWildCard, resourceOnly);</span><br><span class="line">            context.defaultWrapper = newWrapper;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Exact wrapper</span></span><br><span class="line">            <span class="keyword">final</span> String name;</span><br><span class="line">            <span class="keyword">if</span> (path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Special case for the Context Root mapping which is</span></span><br><span class="line">                <span class="comment">// treated as an exact match</span></span><br><span class="line">                name = <span class="string">"/"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                name = path;</span><br><span class="line">            &#125;</span><br><span class="line">            MappedWrapper newWrapper = <span class="keyword">new</span> MappedWrapper(name, wrapper,</span><br><span class="line">                    jspWildCard, resourceOnly);</span><br><span class="line">            MappedWrapper[] oldWrappers = context.exactWrappers;</span><br><span class="line">            MappedWrapper[] newWrappers = <span class="keyword">new</span> MappedWrapper[oldWrappers.length + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (insertMap(oldWrappers, newWrappers, newWrapper)) &#123;</span><br><span class="line">                context.exactWrappers = newWrappers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    同样，根据 <strong>前缀</strong>，<strong>后缀</strong>，<strong>默认值</strong> 以及 <strong>精确匹配</strong> 的几种不同场景，维护一个排序好的 <code>MappedWrapper</code>数组。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文从<code>Mapper</code>的概念模型开始，介绍了Tomcat在接收到用户请求时的路由过程，以及这个路由表的建设过程，了解到<code>Host</code>，<code>Context</code>以及<code>Wrapper</code>的映射关系。同时也介绍了多<code>ContextVersion</code>的来历，以及Tomcat是如何处理多版本的应用路由规则。</p>
]]></content>
      <tags>
        <tag>源码阅读</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Hexo 增加流程图解析功能</title>
    <url>/2017/04/14/wei-hexo-zeng-jia-liu-cheng-tu-jie-xi-gong-neng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p><a href="https://github.com/bubkoo/hexo-filter-flowchart" target="_blank" rel="noopener">hexo-filter-flowchart</a> 插件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>站点配置文件 _config.yml 中增加如下配置:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">flowchart:</span></span><br><span class="line">	<span class="comment"># raphael:   # optional, the source url of raphael.js</span></span><br><span class="line">	<span class="comment"># flowchart: # optional, the source url of flowchart.js</span></span><br><span class="line">	<span class="attr">options:</span> <span class="comment"># options used for `drawSVG`</span></span><br><span class="line">      <span class="attr">scale:</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">      <span class="attr">line-width:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">line-length:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">text-margin:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">font-size:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h2><p>新建文章，增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: 操作</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">cond=&gt;condition: 成功</span><br><span class="line">io=&gt;inputoutput: 输入输出...</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op1</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><div id="flowchart-0" class="flow-chart"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
e=>end: 结束
op1=>operation: 操作
sub1=>subroutine: 子流程
cond=>condition: 成功
io=>inputoutput: 输入输出...

st->op1->cond
cond(yes)->io->e
cond(no)->sub1(right)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title>你知道URL、URI和URN三者之间的区别吗？</title>
    <url>/2016/01/07/uri-url-urn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文翻译自：<a href="http://bitpoetry.io/difference-between-url-uri-and-urn/" target="_blank" rel="noopener">http://bitpoetry.io/difference-between-url-uri-and-urn/</a></p>
</blockquote>
<p>这是一个经典的技术争论，许多人都会自问：URL、URI，很可能还有URN，它们之间的区别是什么。虽然，现在我们简单地把 URN 和 URL 都看做 URI，但严格来说URI可以进一步划分为URL、URN或者这两者的组合，所以了解这三者之间的区别将会非常有趣并让人受益匪浅。如果你恰好在某个地方碰到了这些东西，那么至少应该知道它们的含义。</p>
<p>我认为，尽管对一般人来说，不了解这三个缩略词之间的技术差异以及它们各自的含义并不是什么问题。但是，如果你作为一个计算机科学家、一个Web开发者、一个系统管理员，或者更笼统地说，你工作在IT领域，那么了解这些知识就非常有必要了。</p>
<p>这篇文章旨在于清楚地讲解URL、URI和URN之间的区别，帮助你快速理解这些必备知识。你是不是对这个话题也感到困惑？那么我们开始吧！</p>
<a id="more"></a>
<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>这三个缩略词是Tim Berners-Lee在一篇名为<a href="http://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</a>的文档中定义的互联网标准追踪协议。</p>
<p>引文：</p>
<blockquote>
<p>统一资源标识符（URI）提供了一个简单、可扩展的资源标识方式。URI规范中的语义和语法来源于万维网全球信息主动引入的概念，万维网从1990年起使用这种标识符数据，并被描述为“万维网中的统一资源描述符”。</p>
</blockquote>
<p><img src="/images/pasted-0.png" alt="Tim Berners-Lee"></p>
<p>Tim Berners-Lee ,万维网的发明者，同时也是万维网联盟（W3C）的负责人。照片由 <a href="http://paulclarke.com/" target="_blank" rel="noopener">Paul Clarke</a> 遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC BY-SA 4.0</a> 协议提供。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>首先我们要弄清楚一件事<strong>：URL和URN都是URI的子集</strong>。</p>
<p>换言之，URL和URN都是URI，但是URI不一定是URL或者URN。为了更好的理解这个概念，看下面这张图片。</p>
<p><img src="/images/pasted-1.png" alt="URN-URL-URI"></p>
<p>通过下面的例子（源自 <a href="http://en.wikipedia.org/wiki/Uniform_resource_identifier" target="_blank" rel="noopener">Wikipedia</a>），我们可以很好地理解URN 和 URL之间的区别。如果是一个人，我们会想到他的姓名和住址。</p>
<p>URL类似于住址，它告诉你一种寻找目标的方式（在这个例子中，是通过街道地址找到一个人）。要知道，上述定义同时也是一个URI。</p>
<p>相对地，我们可以把一个人的名字看作是URN；<strong>因此可以用URN来唯一标识一个实体</strong>。由于可能存在同名（姓氏也相同）的情况，所以更准确地说，人名这个例子并不是十分恰当。更为恰当的是书籍的ISBN码和产品在系统内的序列号，尽管没有告诉你用什么方式或者到什么地方去找到目标，但是你有足够的信息来检索到它。引自<a href="http://tools.ietf.org/html/rfc2141" target="_blank" rel="noopener">这篇文章</a>:</p>
<blockquote>
<p>所有的URN都遵循如下语法（引号内的短语是必须的）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; URN &gt; ::= &quot;urn:&quot; &lt; NID &gt; &quot;:&quot; &lt; NSS &gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中NID是命名空间标识符，NSS是标识命名空间的特定字符串。</p>
</blockquote>
<h3 id="一个用于理解这三者的例子"><a href="#一个用于理解这三者的例子" class="headerlink" title="一个用于理解这三者的例子"></a>一个用于理解这三者的例子</h3><p>我们来看一下上述概念如何应用于与我们息息相关的互联网。</p>
<p>再次引用<a href="http://en.wikipedia.org/wiki/Uniform_resource_identifier#URLs" target="_blank" rel="noopener">Wikipedia</a> ，这些引文给出的解释，比上面人员地址的例子更为专业：</p>
<p>关于URL：</p>
<blockquote>
<p>URL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置。</p>
</blockquote>
<p>关于URN：</p>
<blockquote>
<p>URN是URI的一种，用特定命名空间的名字标识资源。使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。</p>
</blockquote>
<p>现在，如果到Web上去看一下，你会找出很多例子，这比其他东西更容易让人困惑。我只展示<strong>一个</strong>例子，非常简单清楚地告诉你在互联网中URI 、URL和URN之间的不同。</p>
<p>我们一起来看下面这个虚构的例子。这是一个<strong>URI</strong>：<code>http://bitpoetry.io/posts/hello.html#intro</code></p>
<p>我们开始分析</p>
<ol>
<li><code>http://</code>: 是定义如何访问资源的<strong>方式</strong>。</li>
<li><code>bitpoetry.io/posts/hello.html</code>：是资源存放的<strong>位置</strong></li>
<li><code>#intro</code>：<strong>资源</strong></li>
</ol>
<p><strong>*URL*</strong>是URI的一个子集，告诉我们访问网络位置的方式。在我们的例子中，URL应该如下所示：<code>http://bitpoetry.io/posts/hello.html</code></p>
<p><strong>*URN*</strong>是URI的子集，包括名字（给定的命名空间内），但是不包括访问方式，如下所示：<code>bitpoetry.io/posts/hello.html#intro</code></p>
<p>就是这样。现在你应该能够辨别出URL和URN之间的不同。</p>
<p>如果你忘记了这篇文章的内容，至少要记住一件事：<strong>URI可以被分为URL、URN或两者的组合。如果你一直使用URI这个术语，就不会有错</strong>。</p>
]]></content>
      <tags>
        <tag>URL</tag>
        <tag>资源定位</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 SELECT INTO</title>
    <url>/2012/04/17/guan-yu-mysql-de-select-into/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>跟 SQLServer 不同，MySQL不支持 SELECT INTO 语句直接备份表结构和数据，由于工作中的需要在网上找到一种方法可以代替, 也有其它方法可以处理，总结如下。</p>
<a id="more"></a>
<h3 id="一、MySQL不支持-SELECT-INTO"><a href="#一、MySQL不支持-SELECT-INTO" class="headerlink" title="一、MySQL不支持 SELECT INTO"></a>一、MySQL不支持 SELECT INTO</h3><ol>
<li><p>方法一</p>
<p> MYSQL不支持：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">Into</span> new_table_name <span class="keyword">from</span> old_table_name;</span><br></pre></td></tr></table></figure>
<p> 替代方法: </p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> new_table_name (<span class="keyword">Select</span> * <span class="keyword">from</span> old_table_name);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>方法二</p>
<ol>
<li><p>先备份表结构和数据</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>导出命令 -u用户名 -p密码 -h主机IP地址 数据库名 表名1   &gt; 导出文件.sql</span><br><span class="line">mysqldump -uroot -proot -h192.168.1.3 target_db target_db2 &gt; db_export.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改备份表的名字</p>
</li>
<li><p>登录MySQL</p>
</li>
<li><p>选择数据库</p>
</li>
<li><p>执行: <code>source db_export.sql</code></p>
</li>
</ol>
</li>
</ol>
<h3 id="二、SQLServer支持-SLECT-INTO"><a href="#二、SQLServer支持-SLECT-INTO" class="headerlink" title="二、SQLServer支持 SLECT INTO"></a>二、SQLServer支持 SLECT INTO</h3><p>备份表直接执行如下就可以了。      </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">Into</span> new_table_name <span class="keyword">from</span> old_table_name;</span><br></pre></td></tr></table></figure>
<h3 id="三、MySQL-SELECT-INTO-FILE-用于导出指定的查询数据到文件"><a href="#三、MySQL-SELECT-INTO-FILE-用于导出指定的查询数据到文件" class="headerlink" title="三、MySQL SELECT INTO FILE 用于导出指定的查询数据到文件"></a>三、MySQL SELECT INTO FILE 用于导出指定的查询数据到文件</h3><p>导出表中所有数据到 outfile.sql 中如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/path/to/outfile.sql'</span> <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu8.04自动挂载硬盘分区</title>
    <url>/2008/08/20/ubuntu8-04-zi-dong-gua-zai-ying-pan-fen-qu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Ubuntu默认开机是不自动挂载硬盘分区的，想要开机自动挂载硬盘，需手动编辑 /etc/fstab 文件，该文件描述了系统启动时所挂载的硬盘设置，具体过程：</p>
<a id="more"></a>
<p>先查看磁盘的uuid（当然也可以查看 label，这样较为清楚地看到分区名称）:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -al /dev/disk/by-uuid (ls -al /dev/disk/by-label)</span><br></pre></td></tr></table></figure>
<p>我的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x 2 root root 160 2008-05-18 15:52 .</span><br><span class="line">drwxr-xr-x 6 root root 120 2008-05-18 15:52 ..</span><br><span class="line">lrwxrwxrwx 1 root root  10 2008-05-18 15:52 3da9d27c-f0e4-406c-9ecb-1cc5d733cfce -&gt; ../../sda2</span><br><span class="line">lrwxrwxrwx 1 root root  10 2008-05-18 15:52 4823-BF99 -&gt; ../../sda8</span><br><span class="line">lrwxrwxrwx 1 root root  10 2008-05-18 15:52 6254D7FB54D7D041 -&gt; ../../sda1</span><br><span class="line">lrwxrwxrwx 1 root root  10 2008-05-18 15:52 9024-CB3A -&gt; ../../sda7</span><br><span class="line">lrwxrwxrwx 1 root root  10 2008-05-18 15:52 e18a56eb-5b1e-4aee-8bdd-6088f1eb9eae -&gt; ../../sda5</span><br><span class="line">lrwxrwxrwx 1 root root  10 2008-05-18 15:52 F464-3F10 -&gt; ../../sda6</span><br></pre></td></tr></table></figure>
<p>使用mount挂载 <em>/dev</em> 下的设备到 <em>/media</em> 下</p>
<p>例：<code>mount /dev/sda4 /media/disk</code></p>
<p>现在要改 <em>/etc/fstab</em> 了<br>加入一行：<br><code>/dev/sda6 /media/D vfat user，auto，umask=002，gid=1000，utf8 0 0</code><br>或是：<br><code>UUID=F464-3F10  /media/D vfat user，auto，umask=002，gid=1000，utf8 0 0</code></p>
<blockquote>
<p>注：vfat是指fat32格式 ，utf8是编码格式，umask是指定访问权限，gid是我的用户id（该ID在用户创建时由系统分配，可在 <em>/etc/passwd</em> 文件中查看到所有用户的相关信息）</p>
</blockquote>
<p>如果是ntfs格式挂载的磁盘应该写成（参考）</p>
<p><code>UUID=F464-3F10 /media/disk ntfs user，nls=utf8，umask=0222，gid=1000，auto 0</code></p>
<p>参考我的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dev/sdb1 /media/Linux vfat user, auto, umask=002, gid=1000, utf8 0 0</span><br><span class="line">/dev/sda7 /media/Media vfat user, auto, umask=002, gid=1000, utf8 0 0</span><br><span class="line">/dev/sda5 /media/ProgramFile vfat user, auto, umask=002, gid=1000, utf8 0 0</span><br><span class="line">/dev/sda1 /media/WindowsXp vfat user, auto, umask=002, gid=1000, utf8 0 0</span><br><span class="line">/dev/sda6 /media/Workspace vfat user, auto, umask=002, gid=1000, utf8 0 0</span><br><span class="line">/dev/sdb6 /media/20GBDisk vfat user, auto, umask=002, gid=1000, utf8 0 0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中JAVA 环境配置及相关</title>
    <url>/2008/07/10/ubuntu-zhong-java-huan-jing-pei-zhi-ji-xiang-guan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h4><p>打开终端，执行以下命令，或使用Adept/新立得软件管理器，在其中分别搜索 <em>sun-java6-jre</em> 和 <em>sun-java6-jdk</em> 并标记安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sun-java6-jre</span><br></pre></td></tr></table></figure>
<p>如果空间富裕，建议安装一个JDK。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sun-java6-jdk</span><br></pre></td></tr></table></figure>
<p>提示：安装过程中需要你回答是否同意使用协议（终端中红蓝色的提示界面），此时按tab键至OK，再按回车即可正常安装。</p>
<a id="more"></a>
<h4 id="设置当前默认的-java-解释器"><a href="#设置当前默认的-java-解释器" class="headerlink" title="设置当前默认的 java 解释器"></a>设置当前默认的 java 解释器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure>
<p>执行后会出现类似如下的画面:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There are 2 alternatives which provide `java'.</span><br><span class="line"></span><br><span class="line">Selection Alternative</span><br><span class="line">-----------------------------------------------</span><br><span class="line">1 /usr/bin/gij-wrapper-4.1</span><br><span class="line">*+ 2 /usr/lib/jvm/java-6-sun/jre/bin/java</span><br><span class="line"></span><br><span class="line">Press enter to keep the default[*], or type selection number:</span><br></pre></td></tr></table></figure>
<p>输入 有包含 “sun” 的行的前面的数字。如上面显示，则输入2，然后回车确定。</p>
<h4 id="配置JAVA环境变量"><a href="#配置JAVA环境变量" class="headerlink" title="配置JAVA环境变量"></a>配置JAVA环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/environment</span><br></pre></td></tr></table></figure>
<p>在其中添加如下两行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CLASSPATH=.:/usr/lib/jvm/java-6-sun/lib</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-6-sun</span><br><span class="line">sudo gedit /etc/jvm</span><br></pre></td></tr></table></figure>
<p>将文件中的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/lib/jvm/java-6-sun</span><br></pre></td></tr></table></figure>
<p>这一行填入到配置块的顶部</p>
<h4 id="安装浏览器的JAVA-Plugin（可选）"><a href="#安装浏览器的JAVA-Plugin（可选）" class="headerlink" title="安装浏览器的JAVA Plugin（可选）"></a>安装浏览器的JAVA Plugin（可选）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sun-java6-plugin</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>使用JNative对条码打印机进行打印</title>
    <url>/2008/02/04/shi-yong-jnative-dui-tiao-ma-da-yin-ji-jin-xing-da-yin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用JNative对条码打印机进行打印 </p>
<p>因项目需要，对Godex EZ2300条码机进行调用打印, 驱动为Ez2000.dll, 用JNI可以实现调用，但比较麻烦, 需 </p>
<p>要用到VC6进行DLL封装，改用JNative组件进行调用, 步骤如下: </p>
<ol>
<li><p>下载 <strong>JNative-1.3.2.zip</strong> 组件库 </p>
</li>
<li><p>解压出来后有 <em>JNative.jar</em>， <em>JNativeCpp.dll</em>，<em>libJNativeCpp.so</em> 三个文件，<em>JNative.jar</em>置于 <code>%JAVA_HOME%/jre/lib/ext</code>目录下, <em>JNativeCpp.dll</em> 置于<code>%SYSTEM%/WINDOWS/SYSTEM32</code>目录下 </p>
</li>
</ol>
<p>3.将<em>Ez2000.dll</em>置于<code>%SYSTEM%/WINDOWS/SYSTEM32</code>目录以及<code>%JAVA_HOME%/jdk/bin</code>目录下 </p>
<a id="more"></a>
<p>具体Java代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.athens.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.xvolks.jnative.JNative;</span><br><span class="line"><span class="keyword">import</span> org.xvolks.jnative.Type;</span><br><span class="line"><span class="keyword">import</span> org.xvolks.jnative.exceptions.NativeException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRINTER_DLL = <span class="string">"Ez2000.dll"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        System.loadLibrary(<span class="string">"Ez2000"</span>);</span><br><span class="line">        JNative n = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            n = demo.getJNativeByFunction(<span class="string">"isready"</span>);</span><br><span class="line">            n.setRetVal(Type.INT);</span><br><span class="line"><span class="comment">// n.setParameter(1, Type.VOID, "");</span></span><br><span class="line">            n.invoke();</span><br><span class="line">            Integer isready = Integer.parseInt(n.getRetVal());</span><br><span class="line">            <span class="keyword">if</span>(isready == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"条码机可以开始接收资料!Starting..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"Starting..."</span>);</span><br><span class="line"><span class="comment">// 打开端口</span></span><br><span class="line">                n = demo.getJNativeByFunction(<span class="string">"openport"</span>);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.STRING, <span class="string">"0"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定参数</span></span><br><span class="line">                n = demo.getJNativeByFunction(<span class="string">"setup"</span>);</span><br><span class="line">                n.setRetVal(Type.INT);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.INT, <span class="string">"30"</span>);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.INT, <span class="string">"7"</span>);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.INT, <span class="string">"2"</span>);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.INT, <span class="string">"1"</span>);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.INT, <span class="string">"0"</span>);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.INT, <span class="string">"0"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出指令</span></span><br><span class="line">                n = demo.getJNativeByFunction(<span class="string">"sendcommand"</span>);</span><br><span class="line">                n.setRetVal(Type.INT);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.STRING, <span class="string">"W70"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line">                n.setRetVal(Type.INT);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.STRING, <span class="string">"^P1"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line">                n.setRetVal(Type.INT);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.STRING, <span class="string">"^L"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line">                n.setRetVal(Type.INT);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.STRING, <span class="string">"AC,20,60,1,1,1,0,TEST"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送条形码</span></span><br><span class="line">                n = demo.getJNativeByFunction(<span class="string">"ecTextOut"</span>);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.INT, <span class="string">"20"</span>);</span><br><span class="line">                n.setParameter(<span class="number">1</span>, Type.INT, <span class="string">"10"</span>);</span><br><span class="line">                n.setParameter(<span class="number">2</span>, Type.INT, <span class="string">"34"</span>);</span><br><span class="line">                n.setParameter(<span class="number">3</span>, Type.STRING, <span class="string">"标楷体"</span>);</span><br><span class="line">                n.setParameter(<span class="number">4</span>, Type.STRING, <span class="string">"Athens Testing Successlly!!!"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出指令</span></span><br><span class="line">                n = demo.getJNativeByFunction(<span class="string">"sendcommand"</span>);</span><br><span class="line">                n.setRetVal(Type.INT);</span><br><span class="line">                n.setParameter(<span class="number">0</span>, Type.STRING, <span class="string">"E"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭端口</span></span><br><span class="line">                n = demo.getJNativeByFunction(<span class="string">"closeport"</span>);</span><br><span class="line">                n.invoke();</span><br><span class="line">                System.out.println(<span class="string">"Ending..."</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"条码机无法接收资料!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    n.dispose();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NativeException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过方法名取得JNative对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JNative <span class="title">getJNativeByFunction</span><span class="params">(String functionName)</span> <span class="keyword">throws</span> NativeException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JNative(PRINTER_DLL, functionName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>使用Spring Framework的十二个理由</title>
    <url>/2015/12/27/shi-yong-spring-framework-de-shi-er-ge-li-you/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天在外网看到一篇文章讲述了在项目中使用 Spring 的 12 个理由，觉得非常不错，转载如下。<br><a id="more"></a></p>
<p>I am proud to say I have been a <strong>Spring developer</strong> since 2004. I have used Spring Framework in all my projects since then.</p>
<p>The projects did differ in the Spring modules that came into play based on the clients needs.</p>
<p>There are some modules and projects I have never worked with and I will identify them as we go along.</p>
<p>Having said that, I am trying some of these new modules in my current projects. I may come back to update my familiarity with them in future as I learn more.</p>
<p>The term ‘Spring developer’ needs a quick mention. With it, I want to clarify how I leveraged Spring Framework and its modules in my projects as we go along.</p>
<p>This will help you understand where Spring Framework can come into play in your projects.</p>
<p>You will get to understand what it can or cannot do based on some real use case scenarios I provide below. I will refer to different projects within Spring Framework Ecosystem throughout the post.</p>
<p>Some of these terms below may be new to you. For now, It is more important to understand the problem they are solving. I will revisit them one by one in the future posts.</p>
<p>Here are twelve reasons to use Spring Framework in your projects in no particular order:</p>
<h2 id="1-Use-Spring-Framework-for-writing-web-applications"><a href="#1-Use-Spring-Framework-for-writing-web-applications" class="headerlink" title="1. Use Spring Framework for writing web applications"></a>1. Use Spring Framework for writing web applications</h2><p>It did not start out this way. But <strong>Spring MVC</strong> is now the de facto framework for java web applications development.</p>
<p>Most of my projects used Spring MVC. Other frameworks in space include <a href="https://struts.apache.org/" target="_blank" rel="noopener">Struts</a>, <a href="https://myfaces.apache.org/" target="_blank" rel="noopener">JSF</a>, <a href="http://tapestry.apache.org/" target="_blank" rel="noopener">Tapestry</a>, <a href="http://www.gwtproject.org/" target="_blank" rel="noopener">GWT</a>, <a href="https://www.playframework.com/" target="_blank" rel="noopener">Play</a> etc.</p>
<p>Most other web applications provide integration with Spring Framework. With Spring MVC, this support is natural and built-in.</p>
<p>And Spring MVC delivers.</p>
<p>You are not bound to any container lifecycle that you need to manipulate. Spring does this behind the scenes for you. If you do decide to participate in the lifecycle, Spring exposes methods that can be overridden.</p>
<p>Spring MVC provides special form tags and validation out of the box. It supports the easy availability of model. It handles the request to model mapping.</p>
<p>You can add custom converters to handle special data in your forms. I will discuss this in a new light with code and samples soon.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-webflow.png" alt="Spring Web Flow Logo">Spring Web Flow</p>
<p>Spring MVC makes sense for most of the web based applications. If you have a <strong>stateful</strong>application, I suggest you look at <strong>Spring Web Flow</strong>.</p>
<p>Only one of my projects leveraged Spring Web Flow. That was a long time ago.</p>
<p>Spring Web Flow lets you build a wizard – a set of screens a user must go through before saving the data. Spring Web Flow will save you from having to store a lot of temporary data.</p>
<p>A mortgage application would be a stateful application. A flight reservation system is another example.</p>
<h2 id="2-Use-Spring-Framework-for-exposing-RESTful-services"><a href="#2-Use-Spring-Framework-for-exposing-RESTful-services" class="headerlink" title="2. Use Spring Framework for exposing RESTful services"></a>2. Use Spring Framework for exposing RESTful services</h2><p>Use Spring MVC to expose your services as RESTful URLs. <a href="https://jersey.java.net/" target="_blank" rel="noopener">Jersey</a> is another alternative.</p>
<p>Spring HATEOAS sits on top of Spring MVC and helps it better represent resources.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-hateoas.png" alt="Spring HATEOAS Logo">Spring HATEOAS</p>
<p><a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener">HATEOAS</a> stands for <strong>H</strong>ypermedia <strong>a</strong>s <strong>t</strong>he <strong>E</strong>ngine <strong>o</strong>f <strong>A</strong>pplication <strong>S</strong>tate.</p>
<p>I will try and give a quick and dirty explanation for HATEOAS. I understand the concept, but I haven’t used it in my projects yet.</p>
<p>A web services developer provides a contract to its consumer before they can call it.</p>
<p>In <a href="https://en.wikipedia.org/wiki/SOAP" target="_blank" rel="noopener">SOAP</a> world, this was the stub or the interface that let the client know which methods were available.</p>
<p>In <a href="https://en.wikipedia.org/wiki/REST" target="_blank" rel="noopener">REST</a>, we have been building URLs with appropriate data to send. We still needed to know what the server expects here.</p>
<p>In Hypermedia, the resource identifiers will give you a clue about what it expects. This will give you insight into how you can further interact with it. A small convention over configuration on the web, if you will.</p>
<p>I used Jersey for one of my projects as opposed to Spring MVC. Jersey follows JSR specification for creating RESTful web services.</p>
<p>Spring MVC deviates from the specification in a slight way. It is easy to convert the API from Spring MVC to Jersey and vice versa. I will discuss MVC in future but for now it stands for <strong>M</strong>odel, <strong>V</strong>iew and <strong>C</strong>ontroller. MVC helps define a clear separation of concerns amongst layers.  For instance, your view should not depend on how java models it.</p>
<p>In my opinion, when in doubt always go with Spring MVC. If you ever need to support a web page with JSP, Jersey can’t help you. Jersey deals with REST only. Spring MVC will give you best of both worlds.</p>
<p>If your client wants to use jQuery on top of JSPs, you can do so with Spring MVC. If, at a later point of time, you want to use a Javascript MVC framework, Spring MVC will continue to support you.</p>
<p>Few popular Javascript MVC frameworks are <a href="https://angularjs.org/" target="_blank" rel="noopener">AngularJS</a>, <a href="http://emberjs.com/" target="_blank" rel="noopener">Ember</a>, and <a href="http://backbonejs.org/" target="_blank" rel="noopener">Backbone.js</a></p>
<p>Javascript MVC frameworks bring structure to the javascript code. It keeps the code modular and clear.</p>
<p>CSS Frameworks bring ease and structure to the web design code. <a href="http://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap</a> is the most popular CSS Framework out there. <a href="http://foundation.zurb.com/" target="_blank" rel="noopener">Foundation</a> is another one.</p>
<p>Spring MVC brings structure to the servlet programming model. It keeps the data model separate from view. Servlets embedded HTML code a long time ago. Struts MVC Framework solved that problem. Spring MVC came later.</p>
<p>Javascript MVC frameworks are like Spring MVC but on the javascript layer. With Javascript MVC frameworks, you build your web pages separate from your server logic.</p>
<p>The two layers then communicate and exchange data with servers via RESTful URLs.</p>
<p>More on MVC frameworks in future posts.</p>
<h2 id="3-Use-Spring-Framework-to-secure-your-web-applications"><a href="#3-Use-Spring-Framework-to-secure-your-web-applications" class="headerlink" title="3. Use Spring Framework to secure your web applications."></a>3. Use Spring Framework to secure your web applications.</h2><p>For all my projects that involved web development, I have used Spring Security.  A two-minute introduction is below.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-security.png" alt="Spring Security Logo">Spring Security</p>
<p>Spring Security intercepts web URLs. Here are few examples:</p>
<p><em>You can tell it that all URLs with a specific pattern e.g. <strong>/static</strong> are accessible to all users.</em> </p>
<p><em>You can tell it that all URLs with a specific pattern e.g. <strong>/admin</strong> are only available to users with a specific role. e.g. ROLE_ADMIN.</em></p>
<p>You can also add annotations on the java methods to make them secure. I will discuss this in length in a future post.</p>
<p>Spring Security provides both <strong>authentication</strong> as well as <strong>authorization</strong>.</p>
<p><strong>Authentication</strong> helps identify who you are.</p>
<p><strong>Authorization</strong> helps identify what you can do in the system.</p>
<p>When starting a fresh project, I integrate spring security and use <strong>in-memory</strong> authentication.</p>
<p>In-memory authentication premise is simple. You hard code a bunch of username, password, role combination into a file or within your XML or java code.</p>
<p>Spring Security would then let you in using either one of them and give you the role for that user. This helps developers continue with the application development.</p>
<p>Later, you could plug in a different authentication provider. And there are no code changes to the business logic as a result of this.</p>
<p>Most projects I have worked with pull credentials from database tables. Once the database is available, we switch to a database authentication provider.</p>
<p>For two of my projects, I have authenticated users against LDAP via <strong>Spring LDAP</strong>.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-ldap.png" alt="Spring LDAP Logo">Spring LDAP</p>
<p>For one of my other projects, our users were database schema owners. Spring security supported custom authentication where we had to proxy as database users.</p>
<p>One of the projects I worked on required BASIC authentication support.</p>
<p>Three of my projects leveraged the following Single Sign-On (SSO)  solutions for pre-authentication.</p>
<ol>
<li><strong>Oracle Based Single Sign-On (OBSSO) .</strong> I used Spring Security Custom authentication here to integrate it with my applications.</li>
<li><strong>CA Siteminder aka CA Single Sign-On.</strong> Spring Security provides a built-in module for this. In my opinion, this is the easiest single sign-on solution to work with. CA Siteminder is a paid solution.</li>
<li><strong>Apereo’s Central Authentication Service (CAS).</strong>  This is open source Single Sign-On solution that came out of Yale University. If you can’t afford CA Siteminder, CAS may work for you. It is a free and open source solution. Apereo provides jars for integration with Spring Security.</li>
</ol>
<h2 id="4-Use-Spring-Framework-for-communicating-with-databases"><a href="#4-Use-Spring-Framework-for-communicating-with-databases" class="headerlink" title="4. Use Spring Framework for communicating with databases."></a>4. Use Spring Framework for communicating with databases.</h2><p>For most of my projects, I used <strong>Spring ORM</strong> with hibernate underneath. One of the projects used <strong>Spring JPA</strong>while the others were direct hibernate calls. ORM is the Object Relational Mapping. It is a way to represent your tables into java objects and vice versa. <a href="http://hibernate.org/" target="_blank" rel="noopener">Hibernate</a> is the most popular ORM Framework. <a href="http://mybatis.org/mybatis-3/" target="_blank" rel="noopener">myBatis</a> is another one.</p>
<p>One of the projects used <strong>myBatis</strong> instead of Hibernate. <strong>mybatis-spring</strong> module came in handy there. MyBatis used to be iBatis before iPhone and iMac and iPad came along.</p>
<p>And if you are dealing with a lot of existing plain old JDBC code, my suggestion would be to use <strong>Spring JDBC</strong>.</p>
<p>Let Spring JDBC close your statements and connections. Use Spring JDBC to integrate connection pooling. Let Spring handle your database transactions as well.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-data.png" alt="Spring Data Logo">Spring Data</p>
<p>I also ran into situations where I was using hibernate for ORM but had to call a pl/SQL procedure in Oracle. Hibernate expects your procedure in a certain way. So, I used Spring JDBC to call procedures if they didn’t fit in the structure required by hibernate.</p>
<p>If you are starting a new project, I would recommend using <strong>Spring Data</strong>. It sits on top of Spring ORM.</p>
<p>With Spring Data, you don’t write standard CRUD operations. They come built-in. I will explain this in a future post.</p>
<p>I have used Spring Data for Oracle and MongoDB now without any issues. I know it has support for other NoSQL and graph databases like Redis, Cassandra, Neo4j, Couchbase, Elasticsearch and Solr.</p>
<h2 id="5-Use-Spring-Framework-for-handling-long-running-jobs"><a href="#5-Use-Spring-Framework-for-handling-long-running-jobs" class="headerlink" title="5. Use Spring Framework for handling long running jobs."></a>5. Use Spring Framework for handling long running jobs.</h2><p>I have worked at two projects where the database queries would take hours to finish. I will explain the reason below in a second.</p>
<p>You can’t expect your users who kick off this report to wait that long, though.</p>
<p>For one, Your browser requests will die based on the application server settings. For instance, tomcat has a default setting of 30 minutes before timing out user request. So the process may be running in the background but the user can’t see it anymore.</p>
<p>One of the projects had accounting updates to make to millions of rows. Here we used <strong>Spring Batch</strong>.</p>
<p><a href="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-batch.png" target="_blank" rel="noopener"><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-batch.png" alt="Spring Batch Logo"></a>Spring Batch</p>
<p>In this case, our web request would kick off a Spring Batch Job and immediately return with a Job Id. So the user is not waiting.</p>
<p>I can then use the job id to check the status of the job and keep the user updated of the progress.</p>
<p>This could be an email notification to the user. Or these days, you could leverage web sockets to push any notification to the user while he is still online.</p>
<p>Spring Batch also provides you a way to notify a system in case of status changes. So you could tell Spring Batch to update a row in the database or send an email once the job status changed. The possibilities are endless here.</p>
<p>The second project had reporting data to pull from a massive datamart. The reporting tool we used handled it for us. But the concept was the same with it running async and handing us an id.</p>
<p>Spring Batch expects a certain database schema and it has a learning curve.</p>
<p>Spring Batch does not make things fast. But it will ensure data integrity and consistency in your job.</p>
<p>You can tell it to retry a job X number of times if it fails. You could tell it how to handle failures.</p>
<p>Try coding this yourself and you will appreciate Spring Batch even more.</p>
<h2 id="6-Use-Spring-Framework-to-handle-external-resources-or-systems-you-have-to-work-with"><a href="#6-Use-Spring-Framework-to-handle-external-resources-or-systems-you-have-to-work-with" class="headerlink" title="6. Use Spring Framework to handle external resources or systems you have to work with."></a>6. Use Spring Framework to handle external resources or systems you have to work with.</h2><p>In one of my projects, Our client would send us reports as XML files via web services. These XMLs were small, but there was no definite way to tell when these files would come in. We had 100k XML files come in six months on average.</p>
<p>Our goal was to intercept these files as they came in and process them for our system intake.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-integration.png" alt="Spring Integration Logo">Spring Integration</p>
<p>This is a typical scenario for a service that depends on an external system.</p>
<p>We used <strong>Spring Integration</strong> for this task. We set up a file poller for the directory of incoming files. Once the file came in, the event would get triggered. We would then push it through our workflow.</p>
<p>The code to handle the incoming file would stay separate from the rest of the workflow. This kept the external party dependency away from the rest of the system and made testing easy.</p>
<h2 id="7-Use-Spring-Framework-for-testing-purposes"><a href="#7-Use-Spring-Framework-for-testing-purposes" class="headerlink" title="7. Use Spring Framework for testing purposes."></a>7. Use Spring Framework for testing purposes.</h2><p>I once worked on a Struts 1.x based web application with EJB3 implementation underneath. They needed to perform some clean up of the data for their testing environment on a regular basis.</p>
<p>So, I created a simple standalone Spring JDBC project and ran a bunch of updates on the tables. I learned more about the project and data structure via this effort than from few months code sifting.</p>
<h2 id="8-Use-Spring-Framework-for-standalone-java-projects"><a href="#8-Use-Spring-Framework-for-standalone-java-projects" class="headerlink" title="8. Use Spring Framework for standalone java projects."></a>8. Use Spring Framework for standalone java projects.</h2><p>I worked on a product that was a standalone CLI (command line interface) sold to clients. It was Java based business rules engine with heavy XML parsing.</p>
<p>When things went wrong, it was hard to test which component failed to deliver.</p>
<p>So, I introduced Spring Framework in a test package within the project. I used Spring Context, Spring Test, and JUnit to call these different components.</p>
<p>The testers had an XML and unit tests that could prep the data before each call.</p>
<h2 id="9-Use-Spring-Framework-to-convert-your-application-into-an-executable"><a href="#9-Use-Spring-Framework-to-convert-your-application-into-an-executable" class="headerlink" title="9. Use Spring Framework to convert your application into an executable."></a>9. Use Spring Framework to convert your application into an executable.</h2><p>Going back to the Spring Batch project. We were kicking off these jobs from a web page based on user’s input.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-boot.png" alt="Spring Boot Logo">Spring Boot</p>
<p>The application was using Spring Framework and its different modules already. But an external team needed to kick off these batch jobs from their end on their own schedule.</p>
<p>So, I created an executable using Spring Boot to point to the main Spring Batch Job. It was the same job that we were calling from our web application. It was the same codebase.</p>
<p>The external team could call this executable nightly or whenever now. There was no code change needed from our side.</p>
<h2 id="10-Use-Spring-Framework-to-integrate-Social-Media-into-your-applications"><a href="#10-Use-Spring-Framework-to-integrate-Social-Media-into-your-applications" class="headerlink" title="10. Use Spring Framework to integrate Social Media into your applications."></a>10. Use Spring Framework to integrate Social Media into your applications.</h2><p>I used to have a startup that failed two years ago. It wasn’t due to technology, though.</p>
<p>I used <strong>Spring Social</strong> to allow users to sign into my application. The application would allow any Facebook, Google, Linkedin or Twitter user to sign up as a result.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-social.png" alt="Spring Social Logo">Spring Social</p>
<p>Spring Social leverages OAuth underneath to make this possible. These social media accounts expose OAuth APIs to allow authentication.</p>
<p>I also used <strong>Spring Mobile</strong> to provide a mobile user experience of my application. I won’t recommend this, though.</p>
<p>Spring Mobile allows you to customize your pages so you can tweak them for mobile users. It implies having to change the code to accommodate both users.</p>
<p>This is cumbersome and not the best bang for the buck.</p>
<p>If I were starting out, I would leverage Bootstrap and Angular JS to build out the application.</p>
<p>Bootstrap is responsive CSS Framework and Angular JS is mobile friendly javascript MVC Framework.</p>
<p>As I write this, Angular 2.x is in works. Angular2 is a mobile-first platform.</p>
<h2 id="11-Use-Spring-Framework-to-come-up-with-a-quick-prototype"><a href="#11-Use-Spring-Framework-to-come-up-with-a-quick-prototype" class="headerlink" title="11. Use Spring Framework to come up with a quick prototype."></a>11. Use Spring Framework to come up with a quick prototype.</h2><p>If you are looking to expose few database tables as a set of screens, I recommend you look into <strong>Spring Roo</strong>. You will get a working CRUD application that will maintain data integrity out of the box.</p>
<p>You can then use the app to allow data manipulation without going into the database.</p>
<p>Sometimes you want to ask your client for important columns to show on screen. Spring Roo could be a quick prototype for client feedback in that case.  You can do this with Grails even faster. If you know Groovy, maybe you’d consider this.</p>
<h2 id="12-Use-Spring-Framework-to-get-Started"><a href="#12-Use-Spring-Framework-to-get-Started" class="headerlink" title="12. Use Spring Framework to get Started."></a>12. Use Spring Framework to get Started.</h2><p>Last but not least, Spring Framework helps you get started.</p>
<p>Use Spring Boot to create the web or standalone application in a span of few minutes. If you are a Groovy guy and used Grails, you have the same power in Spring Boot for java now and then some.</p>
<p><a href="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-cloud.png" target="_blank" rel="noopener"><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-cloud.png" alt="Spring Cloud Logo"></a>Spring Cloud</p>
<p>Use Spring Cloud to build micro services fast. The micro-services are already configured for registration and discovery. And that’s all I know at this point about Spring Cloud.</p>
<p><em>I have never used Spring Cloud in any of my projects.</em></p>
<p>Use Spring XD to build a distributed system for your big data applications.</p>
<p>I explained earlier how Spring Batch can fail-proof your long running jobs.</p>
<p>If you have a web application that spawns these jobs, you need a way to abstract Spring Batch from the rest of the app. Spring Integration comes in handy here.</p>
<p><img src="http://cdn.springtutorials.com/wp-content/uploads/2015/10/spring-xd.png" alt="Spring XD Logo">Spring XD</p>
<p>If you leverage Hadoop for big data, Spring Batch can act as a backbone. You could segregate the work as Tasklets. These tasklets coordinate their flow using Steps. These Steps can combine to become a Job.</p>
<p>It is easy to propose Spring Batch alone. Combine it with Spring Integration and you have a distributed system per se.</p>
<p>But what about scalability and monitoring of these different moving parts?</p>
<p>How do you provide any real-time analytics in a system like this?</p>
<p>With the two questions above, we have identified a use case for Spring XD.</p>
<p><em>I have never used Spring XD for any of my projects.</em></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>I hope you were able to get an idea of what Spring Framework does. And if the terms were new, I hope you were able to look past them. These terms I discussed above fit into Spring Ecosystem in two ways – Spring modules and Spring Projects. I plan to discuss them next. Regardless, I hope you can decide now if it makes sense to use Spring Framework in your projects.</p>
<p>It would make my day if you shared how you have used or plan to use Spring Framework in your own projects.</p>
<p>I am always interested in different approaches developers take to address a specific problem.</p>
<p>If you thought of a different solution to a problem I described above, what would it be? Please don’t hesitate to share it below.</p>
<p>I promise to to give it a due consideration.</p>
<p>Please take a few minutes and say hi either in the comments below or <a href="http://springtutorials.com/facebook-connect" target="_blank" rel="noopener">connect with me on Facebook here</a>. I would love to stay in touch.</p>
<p>Thanks!</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>关于OpenSessionInViewFilter</title>
    <url>/2008/06/23/guan-yu-opensessioninviewfilter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用了OpenSessionInViewFilter之后，程序开发确实少了很多问题。一个直接的优点就是，不用再去关心lazy-loading的问题，因为在一个Request的处理周期内，Session都是Open的。 但是，”Great Charge means great responsibility”，更大的方便也就意味着更大的责任。此Filter运用时也要非常小心。<br><a id="more"></a><br>从OpenSessionInViewFilter的文档中，我们可以看到下面一段话： </p>
<blockquote>
<p>WARNING: Applying this filter to existing logic can cause issues that have not appeared before, through the use of a single Hibernate Session for the processing of an entire request. In particular, the reassociation of persistent objects with a Hibernate Session has to occur at the very beginning of request processing, to avoid clashes with already loaded instances of the same objects. </p>
<p>Alternatively, turn this filter into deferred close mode, by specifying “singleSession”=”false”: It will not use a single session per request then, but rather let each data access operation or transaction use its own session (like without Open Session in View). Each of those sessions will be registered for deferred close, though, actually processed at request completion. </p>
<p>A single session per request allows for most efficient first-level caching, but can cause side effects, for example on saveOrUpdate or if continuing after a rolled-back transaction. The deferred close strategy is as safe as no Open Session in View in that respect, while still allowing for lazy loading in views (but not providing a first-level cache for the entire request). </p>
<p>Looks up the SessionFactory in Spring’s root web application context. Supports a “sessionFactoryBeanName” filter init-param in web.xml; the default bean name is “sessionFactory”. Looks up the SessionFactory on each request, to avoid initialization order issues (when using ContextLoaderServlet, the root application context will get initialized after this filter). </p>
<p><strong>NOTE</strong> : This filter will by default not flush the Hibernate Session, as it assumes to be used in combination with service layer transactions that care for the flushing, or HibernateAccessors with flushMode FLUSH_EAGER. If you want this filter to flush after completed request processing, override closeSession and invoke flush on the Session before closing it. Additionally, you will also need to override getSession() to return a Session in a flush mode other than the default FlushMode.NEVER. Note that getSession and closeSession will just be invoked in single session mode! </p>
</blockquote>
<p>在Hibernate的论坛里面，我也看到了类似的话: </p>
<blockquote>
<p>  // Quote An alternative solution that you don’t need to implement yourself is to use the Spring Franmework’s OpenSessionInViewFilter class. You simply define a servlet filter mapping for the filter and it takes care of opening a Session when a request comes in and closing it when the response is generated. In fact, it will even bind the Session to the current thread and <strong>Spring provides a static SessionFactoryUtils.getSession() method that intelligently returns the bound Session or a new one (optionally)</strong>. We use this pattern in our Struts application and it works like a charm. You can reliably get the one Session even if you use jsp:include and you can pass around your Hibernate POJOs without worrying about lazy initialization exceptions anywhere. However, be aware that having a single Session open for an entire request/response cycle can result in some unexpected behavior that did not happen before. We encountered this ourselves, but dealt with it by using the JUnit setUp() and tearDown() methods to mimic the OpenSessionInViewFilter behavior in our unit tests and solving the quirks from there. </p>
</blockquote>
<p>Single Session虽然可以最大限度的使用Session中的一级缓存，然而，却可能带来很多的副作用，平时在使用的过程中一定要注意。</p>
]]></content>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式——基于Redis的高性能缓存</title>
    <url>/2011/01/12/fen-bu-shi-ji-yu-redis-de-gao-xing-neng-huan-cun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>之前在学校一直都没怎么关注分布式的的应用，在实际的开发场景中，因为都是一些小的项目，也没类似的需求。来到公司后才知道，几乎所有的大的应用都是在分布式环境下运行，就是每个业务都是独立开始部署的，同时每个应用都部署了N台机器。分布式环境一个非常大的区别就是应用并不是运行在一个 JVM 上的，那么所有以本地内存执行为前提的相关技术都将不适用，都需要重写。<br>所以我一直打算从零开始整理所有在分布式环境下所需要应用或改造的技术，于是就有了这个系列——分布式应用开发与学习。</p>
</blockquote>
<p>关于分布式，另一个非常重要的一点就是缓存，如何在分布式环境下构建高效的缓存系统，在大佬的指点下，开始研究整理了 <em>Redis</em> 相关的资料，主要应用分布式环境下的缓存，替换之前用的基于内存的。当然，像 Memcached 这类产品其实也算得上是分布式环境下的替代品，也非常的不错，在各个场景及行业中也有非常多的应用，表现也不错。但 <em>Redis</em> 是最近出来的，性能更好的，天生基于分布式环境开发的产品，所以先研究一下。<br><a id="more"></a></p>
<h2 id="2-Redis简介"><a href="#2-Redis简介" class="headerlink" title="2. Redis简介"></a>2. Redis简介</h2><p>Redis通常被描述为Key-Value存储引擎，当然这是准确的，但更好的描述应该是一个数据结构引擎。那是什么意思？Redis支持五种不同的数据结构：<em>Strings（字符串）</em>，<em>Hashes（哈希）</em>，<em>Lists（列表）</em>，<em>Sets（集合）</em>和<em>Sorted Sets（有序集）</em>。每个都具有独特的特征并支持独特的命令。</p>
<p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供<em>Lists</em>，<em>Sets</em>，<em>ZSets</em>，<em>Hashes</em>等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h3 id="2-2-优势"><a href="#2-2-优势" class="headerlink" title="2.2 优势"></a>2.2 优势</h3><ul>
<li>数据都放在内存中，性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的Strings（字符串）<em>，</em>Hashes（哈希）<em>，</em>Lists（列表）<em>，</em>Sets（集合）<em>和</em>Sorted Sets（有序集）*数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知，key 过期等等特性。</li>
</ul>
<h2 id="3-Redis-安装与启动"><a href="#3-Redis-安装与启动" class="headerlink" title="3. Redis 安装与启动"></a>3. Redis 安装与启动</h2><p>Redis 的安装还是比较简单的，目前这个开源项目还是托管在 Google Code 上，下载源码后就可以配置编译了（目前稳定版本为：2.0.4）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> wget http://Redis.googlecode.com/files/Redis-2.0.4.tar.gz </span><br><span class="line"><span class="meta">$</span> tar xzf Redis-2.0.4.tar.gz</span><br><span class="line"><span class="meta">$</span> cd Redis-2.0.4</span><br><span class="line"><span class="meta">$</span> make</span><br></pre></td></tr></table></figure>
<p>make完后 Redis-2.0.4目录下会出现编译后的Redis服务程序Redis-server，还有用于测试的客户端程序Redis-cli<br>下面启动Redis服务.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span>./redis-server</span><br></pre></td></tr></table></figure>
<p>注意这种方式启动Redis 使用的是默认配置。也可以通过启动参数告诉Redis使用指定配置文件使用下面命令启动.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ./redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p><em>redis.conf</em>是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</p>
<p>启动Redis服务进程后，就可以使用测试客户端程序<em>Redis-cli</em>和Redis服务交互了。</p>
<h2 id="4-Redis-数据类型"><a href="#4-Redis-数据类型" class="headerlink" title="4. Redis 数据类型"></a>4. Redis 数据类型</h2><h3 id="4-1-Strings"><a href="#4-1-Strings" class="headerlink" title="4.1 Strings"></a>4.1 Strings</h3><p><em>Strings</em>是五种数据结构中最简单的一种。其实严格来说这个名字不太准确（这里的 <em>String</em> 并不是指我们常说的字符串），<em>Strings</em>只不过是我们看起来的表象，实际存储的都是二进制序列化对象（blob），应该说是单一的 KEY-VALUE 来描述也许更准确。这种数据类型最常见的的方法是<code>GET</code>和<code>Set</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Sets pages:about "about us"</span><br><span class="line">GET pages:about</span><br><span class="line">about us</span><br></pre></td></tr></table></figure>
<p>当然<em>Strings</em>结构还可以做更多的事情，支持很多其他可用的命令，比如，<code>INCR</code>或者<code>GETRANGE</code>。</p>
<blockquote>
<p>所有关于 <em>Hashes</em> 的命令都在这里：<a href="https://redis.io/commands#string" target="_blank" rel="noopener">https://redis.io/commands#string</a></p>
</blockquote>
<h3 id="4-2-Hashes——哈希"><a href="#4-2-Hashes——哈希" class="headerlink" title="4.2 Hashes——哈希"></a>4.2 Hashes——哈希</h3><p><em>Hashes</em>数据结构跟我们平时理解的（哈希/字典）是一致的。不是直接操作 Key（比如使用Strings），而是操纵 Key 的某个字段。</p>
<p>它常见的语法结构是：<code>HSET key field value</code>，它将哈希表<code>key</code>中的域<code>field</code>的值设为<code>value</code>，如果<code>key</code>不存在，一个新的哈希表被创建并进行<a href="https://redis.io/commands/hset" target="_blank" rel="noopener">HSET</a>操作。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; HGET myhash field1</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
<p>与Redis中的其他所有内容一样，字段和值最终都是字节数组，因此它们可以是任何内容，但是字段往往是字符串。那么我们何时该使用<em>Hashes</em>而不是<em>Strings</em>？例如，以下两者有什么区别？（我使用<em>JSON</em>来表示一个复杂的值，实际Redis仍然会将其序列化为一个字节数组）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET users:goku &#123;race: &apos;sayan&apos;, power: 9001&#125;</span><br><span class="line">HSET users:goku race sayan</span><br><span class="line">HSET users:goku power 9001</span><br></pre></td></tr></table></figure>
<p>其实这取决于你将如何去控制和查询，如果您需要控制单个字段，并且不想将整个对象拉入应用程序，请使用<em>Hashes</em>，否则，<em>Strings</em>可能就是你想要的。</p>
<blockquote>
<p>所有关于 <em>Hashes</em> 的命令都在这里：<a href="https://redis.io/commands#hash" target="_blank" rel="noopener">https://redis.io/commands#hash</a></p>
</blockquote>
<h3 id="4-3-Lists——列表"><a href="#4-3-Lists——列表" class="headerlink" title="4.3 Lists——列表"></a>4.3 Lists——列表</h3><p><em>Lists</em> 的作用是将一个数组的值关联到一个单的 Key 上，实际上，可以（并且应该）将它们视为动态数组。<em>Lists</em>可以进行插入，追加，弹出，推入，裁剪等操作。列表还有一个用法就是，Redis不支持二级索引，只能通过 Key 访问数据，这个时候就可以用列表来模拟索引（虽然这当然不是他们唯一的用途）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">length = redis.lpush(&apos;users:newest&apos;, &apos;user:goku&apos;)</span><br><span class="line">if length &gt; 100</span><br><span class="line">  # 只保留 100 个，超过时将前面的删除</span><br><span class="line">  redis.rpop(&apos;users:newest&apos;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>上面的代码保留了对列表中最新注册用户的引用。这里我们实时维护列表长度，尽管可以将其移动到后台任务，就是我们插入时不再作息超过 100 个时的逻辑（任由列表不断的增长，让后台的任务去管理这个长度），获取用户的时候只需要获取 10 个就行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃得到10个最新用户 </span><br><span class="line">keys = redis.lrange(&apos;users:newest&apos;, 0, 10)</span><br><span class="line">#multi获得实际的10用户对象 </span><br><span class="line">redis.mget(*keys)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有关于 <em>Hashes</em> 的命令都在这里：<a href="https://redis.io/commands#list" target="_blank" rel="noopener">https://redis.io/commands#list</a></p>
</blockquote>
<h3 id="4-4-Sets——集合"><a href="#4-4-Sets——集合" class="headerlink" title="4.4 Sets——集合"></a>4.4 Sets——集合</h3><p><em>Sets</em>很像<em>Lists</em>，它提供了我们数学中常说的集合的语义（给定集合中没有重复的值）。还提供了<em>差集</em>，<em>并集</em>等操作，比如<code>SDIFF</code>，<code>SUNION</code>或<code>SUNIONSTORE</code>等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD friends:leto ghanima</span><br><span class="line">SADD friends:leto duncan</span><br><span class="line">SADD friends:paul duncan</span><br><span class="line">SADD friends:paul gurney</span><br><span class="line">SINTER friends:leto friends:paul</span><br><span class="line">1) &quot;duncan&quot;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-Sorted-Sets——排序集合"><a href="#4-5-Sorted-Sets——排序集合" class="headerlink" title="4.5 Sorted Sets——排序集合"></a>4.5 Sorted Sets——排序集合</h3><p><em>排序集合</em>在<em>集合</em>的基础之上添加了权重功能，我们可以给每个元素添加一个<em>权重/分数</em>，并可以对这个<em>权重/分数</em>信息进行相应的操作（排序，比较等），比如我们要查询一下<em>权重/分类</em>在 <em>500-100</em> 的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZADD friends:leto 1000 ghanima</span><br><span class="line">ZADD friends:leto 994 duncan</span><br><span class="line">ZADD friends:leto 2 farad&apos;n</span><br><span class="line">ZRANGEBYSCORE friends:leto 500 1000</span><br><span class="line">1) &quot;duncan&quot;</span><br><span class="line">2) &quot;ghanima&quot;</span><br></pre></td></tr></table></figure>
<h2 id="5-Redis-Key-查询"><a href="#5-Redis-Key-查询" class="headerlink" title="5. Redis Key 查询"></a>5. Redis Key 查询</h2><p>在Redis中，只能通过 Key 查询数据。即使我们使用哈希，我们也不能查找某个 <em>Hashes</em> 的  <em>street</em> 字段值等于 <em>xxx</em> 的数据。当我们查看列表时，我们看到了如何构建二级索引。管理自己的二级索引可能会很麻烦，有时它无法在复杂性方面进行扩展。</p>
<p>除了上述五种数据结构外，Redis还有一些针对 Key 的命令，用来管理所有的缓存 Key。像<code>DEL</code>，<code>EXISTS</code>和<code>RENAME</code>。可能最常用的是<code>KEYS</code>命令，它接受一个表达式并返回找到的键。例如，如果我想删除8月份的所有排名，我可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keys = redis.keys(&quot;ranks:daily:*:201108*&quot;)</span><br><span class="line">redis.del(*keys)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：<code>keys</code> 命令会线性地遍历所有找到匹配的键，很慢，建议只将它用于调试和开发目的</strong></p>
</blockquote>
<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><p>Redis还是比较易于设置和维护的，数据在单个文件中持久保存到磁盘，只需复制即可备份。我们所有操作的数据都应该适合内存（因为Redis本身是基于内存存储数据的）。</p>
<p>Redis支持主从复制，但目前还不会执行自动故障转移，也不会执行任何类型的分片，所以我们需要自己来实现HAProxy。Redis Cluster是即将发布的主要版本，应该能解决这个难题。</p>
<p>另外，Redis还支持事务，管道等更多命令，更多管理功能，Key 的自动过期的能力，甚至还有发布和订阅API 等，感兴趣的话可以自行去官网了解。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>从安全SDK的BUG看SpringMVC的参数解析</title>
    <url>/2019/04/03/cong-an-quan-sdk-de-bug-kan-springmvc-de-can-shu-jie-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>最近在工作中碰到安全组的同学，在编写一个用于加解密的 <em>Filter</em>时考虑问题不够周全导致的 bug。这个 <em>Filter</em> 的原意是在客户端根据一定的条件将请求的数据进行加密，同时在服务端对数据进行解密。于是，他写了一个 <em>Filter</em> 来过滤请求，部分代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    SecurityHttpServletRequestWrapper requestWrapper = <span class="keyword">new</span> SecurityHttpServletRequestWrapper(</span><br><span class="line">            (HttpServletRequest) request);</span><br><span class="line">    chain.doFilter(requestWrapper, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>将原始的请求包装成一个自定义的 <em>HttpServletRequestWrapper</em>，并重写了请求中获取参数的方法，以此来达到解密的目的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String[]&gt; params;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET =  Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a request object wrapping the given request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the request is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        <span class="keyword">this</span>.params = decodeParams(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码，需要区分版本,验签规则:</span></span><br><span class="line"><span class="comment">     * 1.只签名不加密的情况下，服务器对所有参数验签，所以客户端在调用签名接口后再自行添加的参数会导致服务器验签失败</span></span><br><span class="line"><span class="comment">     * 2.签名且加密的情况下，服务器只对加密部分验签，客户端自行添加的明文参数不会参与验签</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String []&gt; decodeParams(HttpServletRequest request) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己定义了一个 Request Map，并对原始参数进行解密，同时覆盖一系列的 <em>getXXX</em> 方法，返回解密后的参数。应该说，在大部分情况下，这个设计是没错的，这也是安全 SDK 运行了好几个版本也没出什么问题的原因。</p>
<p>但是，我们如果去翻阅 <em>HttpServletRequestWrapper</em> 的源码会发现，这个类的方法数量远不止这么几个 <em>getXXX</em>，如下图所示：</p>
<p><img src="/images/pasted-110.png" alt="upload successful"></p>
<p>当然，并不是说这里所有的方法都需要去覆盖重写，但是与加解密安全相关的都必须要进行完整的覆盖，除了之前 SDK 中的 <em>getXXX</em> 之外，还至少应该覆盖如下的 API：</p>
<ul>
<li><code>public int getContentLength()</code></li>
<li><code>public long getContentLengthLong()</code></li>
<li><code>public ServletInputStream getInputStream() throws IOException</code></li>
</ul>
<p>其中：<em>getContentLength()</em> 以及 <em>getContentLengthLong()</em> 是因为加解密的过程势必会导致请求数据的大小发生变化，所以这里要重新计算并返回实际的数据长度。而 <em>getInputStream()</em> 则是因为有一些数据并不是通过 query 参数的方式进行传递的，比如我们今天要讨论的 <em>@RequestBody</em>。</p>
<p>所以当采用以上 SDK 时，对于常规的参数接入方式完全没有问题，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"vaid"</span>, notes = <span class="string">"获取 VAID"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/vaid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> IdentifierItemDTO <span class="title">queryForVaid</span><span class="params">(@ApiParam(value = <span class="string">"包名"</span>)</span> @RequestParam String packageName,</span></span><br><span class="line"><span class="function">                                      @<span class="title">ApiParam</span><span class="params">(value = <span class="string">"应用 ID"</span>)</span> @RequestParam String appId,</span></span><br><span class="line"><span class="function">                                      @<span class="title">ApiParam</span><span class="params">(value = <span class="string">"签名"</span>)</span> @RequestParam String signature) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果你尝试采用 <em>@RequestBody</em> 来接收参数，则会发生参数无法解析的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"vaid"</span>, notes = <span class="string">"获取 VAID"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/vaid"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> IdentifierItemDTO <span class="title">queryForVaid</span><span class="params">(@ApiParam(value = <span class="string">"应用三元组"</span>)</span> @RequestBody AppTriple triple) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <em>@RequestBody</em> 的内容来自于 <em>Request.getInputStream()</em> ，而原 SDK 并没有对这部分数据进行处理。</p>
<h2 id="2-SpringMVC-的参数处理流程"><a href="#2-SpringMVC-的参数处理流程" class="headerlink" title="2. SpringMVC 的参数处理流程"></a>2. SpringMVC 的参数处理流程</h2><p>如果你用过 Spring2.x 及以下的版本，可能会比较清楚，通常我们在配置 SpringMVC 时，需要手动的给 <em>HandlerAdapter</em> 添加各种 <em>HandlerMethodArgumentResolver</em>，而这个 <em>HandlerMethodArgumentResolver</em> 就是用来处理各类参数转换及绑定的，由于太过久远，我们就不分析2.x版本的实现原理了。</p>
<h3 id="2-1-RequestMappingHandlerMapping"><a href="#2-1-RequestMappingHandlerMapping" class="headerlink" title="2.1 RequestMappingHandlerMapping"></a>2.1 <code>RequestMappingHandlerMapping</code></h3><p>我们看看从Spring3.x 之后提供的基于 <em>Namespace</em> 的配置方式（原理大同小异）。与 <em>HandlerMethodArgumentResolver</em> 相关的配置如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"resolver.MyResolver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:argument-resolvers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它是包含在 <em>\<a href="mvc:annotation-drive\" target="_blank" rel="noopener">mvc:annotation-drive\</a></em> 中的，所以我们从源头分析起，这个 <em>Namespace</em> 的处理入口类是 <em>MvcNamespaceHandler</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">      registerBeanDefinitionParser(<span class="string">"default-servlet-handler"</span>, <span class="keyword">new</span> DefaultServletHandlerBeanDefinitionParser());</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个节点是由 <em>AnnotationDrivenBeanDefinitionParser</em> 去解析的，在这个解析器里面非常重要的一点是定义了如下的 SpringBean——<code>RequestMappingHandlerMapping</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	Object source = parserContext.extractSource(element);</span><br><span class="line">	XmlReaderContext readerContext = parserContext.getReaderContext();</span><br><span class="line"></span><br><span class="line">	CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">	parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line">	RuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);</span><br><span class="line">	...</span><br><span class="line">	RootBeanDefinition handlerAdapterDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerAdapter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    handlerAdapterDef.setSource(source);</span><br><span class="line">    handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    handlerAdapterDef.getPropertyValues().add(<span class="string">"contentNegotiationManager"</span>, contentNegotiationManager);</span><br><span class="line">    handlerAdapterDef.getPropertyValues().add(<span class="string">"webBindingInitializer"</span>, bindingDef);</span><br><span class="line">    handlerAdapterDef.getPropertyValues().add(<span class="string">"messageConverters"</span>, messageConverters);</span><br><span class="line">    addRequestBodyAdvice(handlerAdapterDef);</span><br><span class="line">    addResponseBodyAdvice(handlerAdapterDef);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Bean 非常重要，是 SpringMVC 的几个核心之一，甚至说是 <strong>最</strong> 核心的也不为过。它定义了<em>数据解析</em>，<em>参数绑定</em>，<em>返回值处理</em>，<em>视图解析</em>，<em>内容绑定</em>，<em>消息转换</em>等等一系列的组件，所以这些组件的相互配合完成了所有 SpringMVC 的使命。</p>
<h3 id="2-2-HandlerMethodArgumentResolver"><a href="#2-2-HandlerMethodArgumentResolver" class="headerlink" title="2.2 HandlerMethodArgumentResolver"></a>2.2 <code>HandlerMethodArgumentResolver</code></h3><p>上一节提到 <em>RequestMappingHandlerMapping</em> 是整个 SpringMVC 中最核心的组件，而其中整合了我们今天的主角：<em>HandlerMethodArgumentResolver</em>；这个组件主要有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口，用于将请求中的参数根据相应的配置绑定到方法参数上去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断该策略是否适用于该参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实际解析方法参数的过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">         NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是设计模式中的 <strong>策略模式</strong> 的运用，整个 SpringMVC 中提供了许多的不同场景下的实现，在真正进行参数解析与绑定时，会遍历所有的 <em>Resolver</em> ，调用其 <em>supportsParameter()</em> 方法来确定是否支持当前这个参数的处理，如果支持，则再调用 <em>resolveArgument()</em> 方法来实现真正的参数解析（同时还会进行相应的绑定、转移过程，这利益于方法参数中的 <em>WebDataBinderFactory</em> 的支持）。</p>
<blockquote>
<p>注：在 Spring 中，几乎所有的策略模式的实现都是类似这样的，先中收集所有的策略，然后<em>supportsXXX()</em> 方法来确定该策略是否符合当前的场景，最终在符合要求的策略上调用其 <em>executeXXX()</em> 之类的方法来完成真正的能力实现。</p>
</blockquote>
<h3 id="2-3-系统自带的-HandlerMethodArgumentResolver"><a href="#2-3-系统自带的-HandlerMethodArgumentResolver" class="headerlink" title="2.3 系统自带的 HandlerMethodArgumentResolver"></a>2.3 系统自带的 <em>HandlerMethodArgumentResolver</em></h3><p>了解了 <em>HandlerMethodArgumentResolver</em> 后我们再回到 <em>RequestMappingHandlerMapping</em> 组件中，看看 SpringMVC 自带了多少的 <em>Resolver</em> ，添加自带 <em>Resolver</em> 的过程在其 <em>afterPropertiesSet()</em> 方法，这个是 SpringBean 的生命周期回调方法（可以参考我另一篇文章<a href="/2015/08/10/spring-zhong-bean-de-sheng-ming-zhou-qi">《Spring中Bean的生命周期》</a>），将在 Bean 构造完成后进行回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">	initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加系统自带的各种 ArgumentResolver</span></span><br><span class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">		<span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">		List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">		<span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看这个获取自带 <em>Resolver</em> 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of argument resolvers to use including built-in resolvers</span></span><br><span class="line"><span class="comment"> * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Type-based argument resolution</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Custom arguments</span></span><br><span class="line">	<span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catch-all</span></span><br><span class="line">	resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">	resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到共分为四类：</p>
<ul>
<li>Annotation-based argument resolution：基于注解处理的参数解析器</li>
<li>Type-based argument resolution：基于类型的参数解析器</li>
<li>Custom arguments resolution：用户自定义的解析器，<strong>我们在配置文件中添加的自定义解析器</strong> 就属于这类</li>
<li>Catch-all：其它</li>
</ul>
<p>这四个类型囊括了 SpringMVC 中所有的参数解析，使得我们在编写 <em>Controller.method</em> 时，不再需要手动的去 <em>request</em> 中去获取参数，绝大部分情况下只需要定义参数（或者注解参数）即可，而各个不同的 <em>Resolver</em> 会根据我们的定义（注解）完成对应的参数解析与绑定。</p>
<h2 id="3-RequestBody-的解析"><a href="#3-RequestBody-的解析" class="headerlink" title="3. @RequestBody 的解析"></a>3. <em>@RequestBody</em> 的解析</h2><p>了解了 SpringMVC 对于参数的解析过程后，我们再来看看第一章遇到的问题产生的原因及解决方案：<em>@RequestBody</em> 注解的参数是如何解析绑定定？</p>
<h3 id="3-1-supportsParameter"><a href="#3-1-supportsParameter" class="headerlink" title="3.1 supportsParameter()"></a>3.1 <code>supportsParameter()</code></h3><p>根据我们前面的分析，在四个参数解析器分类中，<em>@RequestBody</em> 的的解析应该是属于 <strong>基于注解处理的参数解析器</strong> ，所以我们只需要在系统默认注册的那些基于注解处理的参数解析器中去查找分析即可。</p>
<p>同时，前面也提到，具体哪个 <em>Resolver</em> 会应用到这个参数的解析过程是由其 <em>supportsParameter()</em> 方法来决定的，那么就很容易的找到 <em>RequestResponseBodyMethodProcessor</em> 组件，我们看看它的源码部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只处理标注有 *@RequestBody* 的参数</span></span><br><span class="line">		<span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常的简单，也很直接的通过 <em>parameter.hasParameterAnnotation(RequestBody.class)</em> 来声明该策略只处理标注有 <em>@RequestBody</em> 的参数；</p>
<h3 id="3-2-resolveArgument"><a href="#3-2-resolveArgument" class="headerlink" title="3.2 resolveArgument()"></a>3.2 <code>resolveArgument()</code></h3><p>真正解析参数的源码过程如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment">	 * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment">	 * converter to read the content with.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		parameter = parameter.nestedIfOptional();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析参数并进行相应的转换</span></span><br><span class="line">		Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">        </span><br><span class="line">		String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">		WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">		<span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">			validateIfApplicable(binder, parameter);</span><br><span class="line">			<span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">			Type paramType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">		HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// InputMessage 实际上就是 ServletServerHttpRequest</span></span><br><span class="line">		ServletServerHttpRequest inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line"></span><br><span class="line">		Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line">		<span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (checkRequired(parameter)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"Required request body is missing: "</span> +</span><br><span class="line">						parameter.getMethod().toGenericString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：这里参数中的 <em>InputMessage</em> 实际就是 <em>ServletServerHttpReques</em> ，不要被名字给迷惑了</p>
</blockquote>
<p><em>readWithMessageConverters</em> 是最底层的参数解析及转移的过程，这个过程源码相对比较复杂，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the method argument value of the expected parameter type by reading</span></span><br><span class="line"><span class="comment"> * from the given HttpInputMessage.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the expected type of the argument value to be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputMessage the HTTP input message representing the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter descriptor (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetType the target type, not necessarily the same as the method</span></span><br><span class="line"><span class="comment"> * parameter type, e.g. for &#123;<span class="doctag">@code</span> HttpEntity&lt;String&gt;&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the created method argument value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the reading from the request fails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotSupportedException if no suitable message converter is found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">		Type targetType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 MediaType ，即我们请求中的 Content-Type</span></span><br><span class="line">	MediaType contentType;</span><br><span class="line">	<span class="keyword">boolean</span> noContentType = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		contentType = inputMessage.getHeaders().getContentType();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(ex.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (contentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">		noContentType = <span class="keyword">true</span>;</span><br><span class="line">		contentType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数类型，为后续的类型转换器作准备</span></span><br><span class="line">	Class&lt;?&gt; contextClass = (parameter != <span class="keyword">null</span> ? parameter.getContainingClass() : <span class="keyword">null</span>);</span><br><span class="line">	Class&lt;T&gt; targetClass = (targetType <span class="keyword">instanceof</span> Class ? (Class&lt;T&gt;) targetType : <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		ResolvableType resolvableType = (parameter != <span class="keyword">null</span> ?</span><br><span class="line">				ResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType));</span><br><span class="line">		targetClass = (Class&lt;T&gt;) resolvableType.resolve();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod();</span><br><span class="line">	Object body = NO_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 包装一个 EmptyBodyCheckingHttpInputMessage</span></span><br><span class="line">		inputMessage = <span class="keyword">new</span> EmptyBodyCheckingHttpInputMessage(inputMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MessageConverter 是参数的转换器</span></span><br><span class="line">        <span class="comment">// 同样的套路，熟悉的模式：策略模式（收集-canXXX()/supportsXX()-doXXX()）</span></span><br><span class="line">		<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">			Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line">			<span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">				GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter;</span><br><span class="line">				<span class="keyword">if</span> (genericConverter.canRead(targetType, contextClass, contentType)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 读取 body 内容，并进行转换器的前置、后置处理</span></span><br><span class="line">					<span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">						inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">						body = genericConverter.read(targetType, contextClass, inputMessage);</span><br><span class="line">						body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (converter.canRead(targetClass, contentType)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 读取 body 内容，并进行转换器的前置、后置处理</span></span><br><span class="line">					<span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">						inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">						body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage);</span><br><span class="line">						body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"I/O error while reading input message"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (body == NO_VALUE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (httpMethod == <span class="keyword">null</span> || !SUPPORTED_METHODS.contains(httpMethod) ||</span><br><span class="line">				(noContentType &amp;&amp; inputMessage.getBody() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(contentType, <span class="keyword">this</span>.allSupportedMediaTypes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛开 Header 信息处理，分支处理，数据转换等，真正核心的数据都保存在 <code>InputMessage.getBody()</code>，而这个<em>InputMessage</em> 实际上就是 <em>ServletServerHttpRequest</em>，所以我们看看 <em>ServletServerHttpRequest.getBody()</em> 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过表单提交数据</span></span><br><span class="line">	<span class="keyword">if</span> (isFormPost(<span class="keyword">this</span>.servletRequest)) &#123;</span><br><span class="line">		<span class="keyword">return</span> getBodyFromServletRequestParameters(<span class="keyword">this</span>.servletRequest);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 直接在 body 里面提交数据</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.servletRequest.getInputStream();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分了两种场景：</p>
<ul>
<li><p>通过表单提交：判定的依据是 <em>content-type=”application/x-www-form-urlencoded”</em>，同时 <em>httpMethod=POST</em>，这个时候，会将所有的表单序列化成字节流。如下所示：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use &#123;<span class="doctag">@link</span> javax.servlet.ServletRequest#getParameterMap()&#125; to reconstruct the</span></span><br><span class="line"><span class="comment"> * body of a form 'POST' providing a predictable outcome as opposed to reading</span></span><br><span class="line"><span class="comment"> * from the body, which can fail if any other code has used the ServletRequest</span></span><br><span class="line"><span class="comment"> * to access a parameter, thus causing the input stream to be "consumed".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InputStream <span class="title">getBodyFromServletRequestParameters</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">	Writer writer = <span class="keyword">new</span> OutputStreamWriter(bos, FORM_CHARSET);</span><br><span class="line"></span><br><span class="line">	Map&lt;String, String[]&gt; form = request.getParameterMap();</span><br><span class="line">	<span class="keyword">for</span> (Iterator&lt;String&gt; nameIterator = form.keySet().iterator(); nameIterator.hasNext();) &#123;</span><br><span class="line">		String name = nameIterator.next();</span><br><span class="line">		List&lt;String&gt; values = Arrays.asList(form.get(name));</span><br><span class="line">		<span class="keyword">for</span> (Iterator&lt;String&gt; valueIterator = values.iterator(); valueIterator.hasNext();) &#123;</span><br><span class="line">			String value = valueIterator.next();</span><br><span class="line">			writer.write(URLEncoder.encode(name, FORM_CHARSET));</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">				writer.write(<span class="string">'='</span>);</span><br><span class="line">				writer.write(URLEncoder.encode(value, FORM_CHARSET));</span><br><span class="line">				<span class="keyword">if</span> (valueIterator.hasNext()) &#123;</span><br><span class="line">					writer.write(<span class="string">'&amp;'</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nameIterator.hasNext()) &#123;</span><br><span class="line">			writer.append(<span class="string">'&amp;'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	writer.flush();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>通过 body 提交：直接返回 <em>ServletRequest.getInputStream()</em> 即可</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>根据以上的分析，我们很清楚的知道了第一节中提到的 BUG 的问题根源所在：<em>@RequestBody</em> 参数的绑定是由 <em>RequestResponseBodyMethodProcessor</em> 完成的，而 <em>RequestResponseBodyMethodProcessor</em> 在进行 <em>resolveArgument</em> 时会通过 <em>ServletRequest.getInputStream()</em> 读取数据流，从而完成最终的数据转换、绑定。而安全 SDK 并没有对 <em>ServletRequest.getInputStream()</em> 进行任何的支持，从而导致读取的数据（加密后）不符合 <em>application/json</em> 的格式规范，进而抛出异常。</p>
<p>知道原因后解决的方案就比较清晰了，就是在加解密的时候对于 <em>ServletRequest.getInputStream()</em> 数据同样要进行相应的处理。</p>
<p>当然，更严谨的来说，前面提到的 <em>getContentLength()</em>，<em>getContentLengthLong()</em> 最好也要进行处理，虽然这里并没有涉及到这两个方法的执行。但 <strong>对于一些网络相关的优化或者压缩支持的时候，这两个方法是非常重要的，当实际的数据长度和这两个方法返回的数据不一致，会导致一些丢包或者数据展示不全的 bug</strong> 。</p>
<h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h2><p>现在 Spring/SpringBoot 的更新迭代与优化后，框架的自动化程度越来越高，编写 Spring 相关的应用会越来越简单，提高了开发的生产效率。</p>
<p>但是，另一方面，过多的自动化，过多的细节隐藏导致的后果是越来越多的人不知道背后的原理，一旦出现问题时手足无措，不知道从哪里开始分析与排查。</p>
<p>所以，这里建议，<strong>想要真正学好用好 Spring 框架，可以尝试使用 Spring1.x/2.x 的版本去写一些测试 demo 应用。这两个版本的 Spring 配置过程比较复杂，各个组件都需要自己去配置，关联关系都需要自己去维护，但正因为如此，开发者更能够理解各个组件的功能、之间的依赖关系，更能够从底层的去了解 Spring 的运行原理。</strong></p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式——基于zookeeper实现的分布式锁</title>
    <url>/2010/04/12/fen-bu-shi-ji-yu-zookeeper-shi-xian-de-fen-bu-shi-suo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>之前在学校一直都没怎么关注分布式的的应用，在实际的开发场景中，因为都是一些小的项目，也没类似的需求。来到公司后才知道，几乎所有的大的应用都是在分布式环境下运行，就是每个业务都是独立开始部署的，同时每个应用都部署了N台机器。分布式环境一个非常大的区别就是应用并不是运行在一个 JVM 上的，那么所有以本地内存执行为前提的相关技术都将不适用，都需要重写。<br>所以我一直打算从零开始整理所有在分布式环境下所需要应用或改造的技术，于是就有了这个系列——分布式应用开发与学习。</p>
</blockquote>
<p>关于分布式，同步与锁就是其中一例（当然还有非常非常多其它的技术），今天就整理了一下基于 ZooKeeper 的分布式锁的实现原理与方式。</p>
<a id="more"></a>
<h2 id="2-ZooKeeper"><a href="#2-ZooKeeper" class="headerlink" title="2. ZooKeeper"></a>2. ZooKeeper</h2><p>ZooKeeper 是大数据处理框架 Hadoop 下的一个子项目，是一种用于分布式应用程序的高性能协调服务框架。ZooKeeper 维护大型集群环境中所需的公共对象。这些对象的示例包括配置信息，分层命名空间等。应用程序利用这些服务来协调大型集群的分布式处理。 </p>
<p><strong>它是如何工作的？</strong></p>
<p>想象一下，Hadoop集群跨越500个或更多服务器。那么就需要有一个集中管理整个集群的方案，包括在名称、组和同步服务，配置管理等。Hadoop集群的其他开源项目也需要跨集群服务，ZooKeeper 就是为这个场景而生的，嵌入ZooKeeper可以很方便地构建同步服务。</p>
<p>对于应用程序，ZooKeeper提供了跨节点同步的基础结构。它通过在ZooKeeper服务器上的内存中维护状态类型信息来实现此目的。ZooKeeper服务器保留整个系统状态的副本，并将此信息保存在本地日志文件中。多个ZooKeeper服务器支持大型Hadoop集群（主服务器同步顶级服务器）。 </p>
<p>在ZooKeeper中，应用程序可以创建所谓的<em>znode</em>（一个在ZooKeeper服务器上保留在内存中的文件）。<em>znode</em>可以由群集中的任何节点更新，群集中的任何节点都可以注册以通知该<em>znode</em>的更改（在ZooKeeper的说法中，服务器可以设置为“监视”特定的<em>znode</em>）。 </p>
<p>使用这个<em>znode</em>基础结构，应用程序可以通过在ZooKeeper znode中更新它们的状态来同步它们在分布式集群中的任务，通知群集的其余部分特定节点的状态更改。此群集范围的状态集中服务对于跨大型分布式服务器集的管理和序列化任务至关重要。</p>
<p>更多关于 ZooKeeper 的信息可以去官网<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">http://zookeeper.apache.org/</a>或者查看我之前关于 ZooKeeper 的文章<a href="/2010/04/08/fen-bu-shi-ji-yu-zookeeper-gou-jian-fen-bu-shi-ying-yong/">分布式——基于zookeeper构建分布式应用</a>，这并不是我今天要整理的重点，但确实是前提，你必须了解<em>znode</em>的几种类型和各自的特点才能更好地理解我们怎么利用它的这些特性来实现分布式锁。</p>
<h2 id="3-锁服务"><a href="#3-锁服务" class="headerlink" title="3. 锁服务"></a>3. 锁服务</h2><p>分布式锁是一种在进程集合之间提供互斥的机制。在任何时候，只有一个进程可以保持锁定。分布式锁可以用于大型分布式系统中的领导者选举，其中领导者是在任何时间点持有锁的进程。</p>
<p>不要将ZooKeeper自己的领导者选举与一般领导者选举服务混淆，后者可以使用ZooKeeper原语构建。Zoo-Keeper自己的领导人选举没有公开曝光，不像我们在这里描述的一般领导人选举服务的类型，</p>
<p>要使用ZooKeeper实现分布式锁，我们使用<strong>临时顺序节点</strong>。这个想法很简单：首先指定一个锁定节点，通常描述被锁定的实体，比如 <em>/leader</em>，那么想要获取锁的客户端创建<strong>临时顺序</strong>的节点作为锁节点的子节点，同时所有的客户端都会监听<em>/leader</em>的孩子节点（当发生变化时确认是否是自己获得了锁）。</p>
<p>在任何时间点，具有<strong>最低序列号</strong>的客户端都会持有锁。例如，如果两个客户端大约在同一时间创建子节点，<em>/leader/lock-1</em>和<em>/leader/lock-2</em>，则创建<em>/leader/lock-1</em>的客户端持有锁，因为它的节点具有最低的序列号。</p>
<p>这样只需删除<em>/leader/lock-1</em>即可释放锁定，这个过程可以是主动的，也可能是被动的（比如客户端进程死亡，它将被删除，因为它是一个短暂的znode）。创建<em>/leader/lock-2</em>的客户端监听到这个事件后，在比较了所有的序号后，发现自己变成最小的序号了，于是将获得锁。</p>
<p>锁获取的伪代码如下：</p>
<ol>
<li>在lock节点下创建一个名为<em>lock-</em>的<strong>临时顺序节点</strong>并记住它的实际路径名（create操作的返回值），获取锁定节点的孩子列表并设置一个 <em>Watch</em>。</li>
<li>如果在第1步中创建的节点的路径名具最小子顺序号，则已获取锁。</li>
<li>等待<em>Watch</em>设置的通知，在事件到达后然后转到步骤2。</li>
</ol>
<h2 id="4-羊群效应"><a href="#4-羊群效应" class="headerlink" title="4. 羊群效应"></a>4. 羊群效应</h2><p>虽然这个算法是正确的，但它有一些问题。第一个问题是这种实施受到<a href="https://wiki.mbalib.com/wiki/%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">羊群效应</a>的影响。考虑成百上千的客户端，都试图获得锁。每个客户端都会在锁定znode上放置一个监视，以查看其子集的更改。每次释放锁定时，所有的客户端都被唤醒，并来检查自己是否是最小序号的节点，从而产生“羊群效应”。</p>
<p>但实际上应该只有少数客户端（分布式锁场景应该只有一个客户端）可以进行实际的锁操作，在这种情况下，只有一个客户端将成功获取锁定。羊群效应导致了维护和发送监视事件到所有客户端的过程会导致流量高峰，这会给ZooKeeper服务器带来压力。</p>
<p>为了避免羊群效应，我们需要优化通知条件。实现锁的关键是，应该只有当具有先前序列号的子znode消失时，才需要通知该客户端，而不是在删除（或创建）<strong>任何</strong>子znode时都通知我。在我们的例子中，如果客户端创建了<em>/leader/lock-1</em>，<em>/leader/lock-2</em>和<em>/leader/lock-3</em>，那么当<em>/leader/lock-2</em>消失时，只需要通知持有<em>/leader/ lock-3</em> 节点的客户端。当<em>/leader/lock-1</em>消失或添加新的<em>/leader/lock-4</em>时，并不需要通知它。</p>
<h2 id="5-可恢复的异常"><a href="#5-可恢复的异常" class="headerlink" title="5. 可恢复的异常"></a>5. 可恢复的异常</h2><p>上面描述的锁定算法还有另一个问题是：没有处理由于创建操作失败的情况（比如由于连接丢失而失败）。回想一下，在这种情况下，我们不知道操作是成功还是失败。创建顺序节点是一种非幂等操作，因此我们不能简单地重试，因为如果第一次创建已经成功，我们将会有一个永远不会删除的孤立节点（至少在客户端会话结束之前）。</p>
<p>同时，重新连接后，客户端无法判断它是否创建了任何子znode。通过在znode名称中嵌入标识符，如果它遭受连接丢失，它可以检查锁定节点的任何子节点是否在其名称中具有其标识符。如果子节点包含其标识符，则它知道创建操作成功，它不应该创建另一个子节点。如果没有子标识符在其名称中，则客户端可以安全地创建新的顺序子节点。</p>
<p>客户端的会话标识符是一个长整数，对于ZooKeeper服务是唯一的，因此非常适合在连接丢失事件中标识客户端。可以通过调用ZooKeeper <code>getSessionId()</code> API 方法来获取会话标识符。</p>
<p>使用类似<code>lock- &lt;sessionId&gt;</code>的名称创建临时顺序节点，以便当ZooKeeper附加序列号时，名称将变为<code>lock- &lt;sessionId&gt; - &lt;sequenceNumber&gt;</code>。序列号对于父级是唯一的，而不是子级的名称，因此这种技术允许子节点识别其创建者以及添加创建顺序。</p>
<h2 id="6-不可恢复的异常"><a href="#6-不可恢复的异常" class="headerlink" title="6. 不可恢复的异常"></a>6. 不可恢复的异常</h2><p>如果客户端的ZooKeeper会话到期，客户端创建的临时节点将被删除，有效地放弃锁定或至少丧失客户端获取锁定的权利。使用锁的应用程序应该意识到它不再持有锁，清理它的状态，然后通过创建一个新的锁对象并尝试获取它来重新开始。请注意，由应用程序控制此进程，而不是锁实现，因为它无法猜测应用程序如何清理其状态。</p>
<h2 id="7-具体实现"><a href="#7-具体实现" class="headerlink" title="7. 具体实现"></a>7. 具体实现</h2><p>知道了上述的原理以及各种异常情况后，要具体实现就比较简单了，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[]  data      = &#123; <span class="number">0x12</span>, <span class="number">0x34</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeperx           zookeeper = ZooKeeperClient.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String         root;                                     <span class="comment">//根节点路径</span></span><br><span class="line">    <span class="keyword">private</span> String               id;</span><br><span class="line">    <span class="keyword">private</span> LockNode             idName;</span><br><span class="line">    <span class="keyword">private</span> String               ownerId;</span><br><span class="line">    <span class="keyword">private</span> String               lastChildId;</span><br><span class="line">    <span class="keyword">private</span> Throwable            other     = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> KeeperException      exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> InterruptedException interrupt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLock</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">        ensureExists(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁操作，阻塞式可被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        <span class="comment">// 可能初始化的时候就失败了</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interrupt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> interrupt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestableRuntimeException(other);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isOwner()) &#123;<span class="comment">//锁重入</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BooleanMutex mutex = <span class="keyword">new</span> BooleanMutex();</span><br><span class="line">        acquireLock(mutex);</span><br><span class="line">        <span class="comment">// 避免zookeeper重启后导致watcher丢失，会出现死锁使用了超时进行重试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.get(DEFAULT_TIMEOUT_PERIOD, TimeUnit.MICROSECONDS);<span class="comment">// 阻塞等待值为true</span></span><br><span class="line">            <span class="comment">// mutex.get();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mutex.state()) &#123;</span><br><span class="line">                lock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interrupt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> interrupt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestableRuntimeException(other);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁对象, 不会阻塞</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> KeeperException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException </span>&#123;</span><br><span class="line">        <span class="comment">// 可能初始化的时候就失败了</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isOwner()) &#123;<span class="comment">//锁重入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        acquireLock(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interrupt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestableRuntimeException(other);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isOwner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zookeeper.delete(root + <span class="string">"/"</span> + id, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                id = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExists</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat stat = zookeeper.exists(path, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zookeeper.create(path, data, CreateMode.PERSISTENT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            interrupt = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回锁对象对应的path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前是不是锁的owner</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> &amp;&amp; ownerId != <span class="keyword">null</span> &amp;&amp; id.equals(ownerId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前的节点id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===================== helper method =============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行lock操作，允许传递watch变量控制是否需要阻塞lock操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">acquireLock</span><span class="params">(<span class="keyword">final</span> BooleanMutex mutex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;<span class="comment">//构建当前lock的唯一标识</span></span><br><span class="line">                    <span class="keyword">long</span> sessionId = zookeeper.getDelegate().getSessionId();</span><br><span class="line">                    String prefix = <span class="string">"x-"</span> + sessionId + <span class="string">"-"</span>;</span><br><span class="line">                    <span class="comment">//如果第一次，则创建一个节点</span></span><br><span class="line">                    String path = zookeeper.create(root + <span class="string">"/"</span> + prefix, data,</span><br><span class="line">                            CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">                    <span class="keyword">int</span> index = path.lastIndexOf(<span class="string">"/"</span>);</span><br><span class="line">                    id = StringUtils.substring(path, index + <span class="number">1</span>);</span><br><span class="line">                    idName = <span class="keyword">new</span> LockNode(id);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    List&lt;String&gt; names = zookeeper.getChildren(root, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (names.isEmpty()) &#123;</span><br><span class="line">                        id = <span class="keyword">null</span>;<span class="comment">//异常情况，重新创建一个</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//对节点进行排序</span></span><br><span class="line">                        SortedSet&lt;LockNode&gt; sortedNames = <span class="keyword">new</span> TreeSet&lt;LockNode&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                            sortedNames.add(<span class="keyword">new</span> LockNode(name));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (sortedNames.contains(idName) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                            id = <span class="keyword">null</span>;<span class="comment">//清空为null，重新创建一个</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//将第一个节点做为ownerId</span></span><br><span class="line">                        ownerId = sortedNames.first().getName();</span><br><span class="line">                        <span class="keyword">if</span> (mutex != <span class="keyword">null</span> &amp;&amp; isOwner()) &#123;</span><br><span class="line">                            mutex.set(<span class="keyword">true</span>);<span class="comment">//直接更新状态，返回</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> isOwner();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        SortedSet&lt;LockNode&gt; lessThanMe = sortedNames.headSet(idName);</span><br><span class="line">                        <span class="keyword">if</span> (!lessThanMe.isEmpty()) &#123;</span><br><span class="line">                            <span class="comment">//关注一下排队在自己之前的最近的一个节点</span></span><br><span class="line">                            LockNode lastChildName = lessThanMe.last();</span><br><span class="line">                            lastChildId = lastChildName.getName();</span><br><span class="line">                            <span class="comment">//异步watcher处理</span></span><br><span class="line">                            zookeeper.exists(root + <span class="string">"/"</span> + lastChildId, <span class="keyword">new</span> AsyncWatcher() &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncProcess</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                                    acquireLock(mutex);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                acquireLock(mutex);<span class="comment">// 如果节点不存在，需要自己重新触发一下，watcher不会被挂上去</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (isOwner()) &#123;</span><br><span class="line">                                mutex.set(<span class="keyword">true</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                id = <span class="keyword">null</span>;<span class="comment">// 可能自己的节点已超时挂了，所以id和ownerId不相同</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (id == <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">            <span class="keyword">if</span> (mutex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mutex.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            interrupt = e;</span><br><span class="line">            <span class="keyword">if</span> (mutex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mutex.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            other = e;</span><br><span class="line">            <span class="keyword">if</span> (mutex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mutex.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isOwner() &amp;&amp; mutex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mutex.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-第三方实现"><a href="#8-第三方实现" class="headerlink" title="8. 第三方实现"></a>8. 第三方实现</h2><p>由于这个场景太常见了，所以目前也现出了许多基于 ZooKeeper 的分布式的最佳实践，其中<a href="https://curator.apache.org/curator-recipes/shared-reentrant-lock.html/" target="_blank" rel="noopener">Apache Curator Reentrant Lock</a>就是一个非常好的官方推荐的实现。它的使用方式非常的简单，大家可以去官网或者 Google 了解一下，有了这个，我们基本上不再需要自行去实现分布式锁服务了。大概的使用模式如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterProcessMutex mutex = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"><span class="comment">// 获取锁，这里是阻塞的，会一直等待直到获取锁</span></span><br><span class="line">mutex.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行业务</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 注意，一定要 finally 里面释放锁</span></span><br><span class="line">    mutex.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式——基于zookeeper构建分布式应用</title>
    <url>/2010/04/08/fen-bu-shi-ji-yu-zookeeper-gou-jian-fen-bu-shi-ying-yong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>之前在学校一直都没怎么关注分布式的的应用，在实际的开发场景中，因为都是一些小的项目，也没类似的需求。来到公司后才知道，几乎所有的大的应用都是在分布式环境下运行，就是每个业务都是独立开始部署的，同时每个应用都部署了N台机器。分布式环境一个非常大的区别就是应用并不是运行在一个 JVM 上的，那么所有以本地内存执行为前提的相关技术都将不适用，都需要重写。<br>所以我一直打算从零开始整理所有在分布式环境下所需要应用或改造的技术，于是就有了这个系列——分布式应用开发与学习。</p>
</blockquote>
<p>关于分布式，其中非常重要的一点就是分布环境中的配置管理与状态同步，关于这一点是 ZooKeeper 的强项。今天就整理了一下基于 ZooKeeper 的相关使用方式。</p>
<p>人们普遍认为，您不应该设计或实施自己的加密算法，而应使用经过充分测试的第三方库。分布式系统也是如此：不要总想着构建自己的协议来协调集群，因为要考虑的因素实在太多了，当然前提是已经有成熟的第三方库支持。</p>
<p>构建分布式系统不是一个小问题，它很容易出现竞争条件，死锁和不一致。使集群协调快速且可扩展与使其可靠一样困难。而<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Apache ZooKeeper</a>的出现为我们提供编写正确的分布式应用程序所需的工具的协调服务。</p>
<p>Apache HBase，HDFS和其他Apache Hadoop项目已经使用ZooKeeper来提供高可用性服务，ZooKeeper 通常可以使分布式编程更容易，这个已经成为事实上的业界标准。<br><a id="more"></a></p>
<h2 id="2-ZooKeeper的工作原理"><a href="#2-ZooKeeper的工作原理" class="headerlink" title="2. ZooKeeper的工作原理"></a>2. ZooKeeper的工作原理</h2><p>ZooKeeper在服务器集群上运行，该集群共享数据的状态。每当进行更改时，需要通过集群仲裁（至少一半服务器来进行评估），只能仲裁通过，更改才会生效。集群中将会通过选举来找到一个 Leader ，如果同时进行两次相互冲突的变化，率先通过 Leader 支持的变更会生效，另一个将失败。另外，ZooKeeper保证来自同一客户端的写入将按照该客户端发送的顺序进行处理，这个特性可以使系统用于实现分布式排队的锁，队列和其他重要操作。</p>
<p>单个节点服务器无法判断其他服务器是否实际关闭，所以当它自己在配置好的超时时间内，无法连接到仲裁节点时，服务器就会断开所有客户端会话。这种无法连接的原因也可能是由于网络分区而刚刚与它们断开离，因此整个集群并无法保证所有的节点状态都是一样的。所以尽管有一些服务器节点出现故障，但只要整数的一半以上的节点可用，集群就可以继续服务。当故障服务器恢复在线时，它将与集群的其余部分同步并可以恢复服务。</p>
<p>最好使用奇数个服务器运行ZooKeeper集群，比如三，五或七。例如，如果您运行五个服务器而三个服务器已关闭，则集群将不可用（因此您可以关闭一个服务器以进行维护，并且仍能在意外故障中继续运行）。但是，如果运行六台服务器，则在三次故障后集群仍然不可用，但三次同时发生故障的可能性现在略高。还要记住，当添加更多服务器时，您可能能够容忍更多故障，但也可能开始具有较低的写入吞吐量。（<a href="http://zookeeper.apache.org/doc/r3.4.5/zookeeperOver.html#Performance" target="_blank" rel="noopener">Apache的文档</a>  很好地说明了各种ZooKeeper集群大小的性能特征。）</p>
<h2 id="3-安装ZooKeeper"><a href="#3-安装ZooKeeper" class="headerlink" title="3. 安装ZooKeeper"></a>3. 安装ZooKeeper</h2><p>ZooKeeper依赖Java环境，（当然，客户端是可以支持<a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZKClientBindings" target="_blank" rel="noopener">其他几种语言的</a>）。从<a href="http://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">ZooKeeper发行版本</a>页面下载好相应版本（目前是<em>3.3.0</em>），并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> wget http://mirrors.estointernet.in/apache/zookeeper/zookeeper-3.3.0/zookeeper-3.3.0.tar.gz</span><br><span class="line"><span class="meta">$</span> tar -zxvf zookeeper-3.3.0.tar.gz</span><br><span class="line"><span class="meta">$</span> cd zookeeper-3.3.0/conf</span><br><span class="line"><span class="meta">$</span> touch zoo.cfg</span><br></pre></td></tr></table></figure>
<p>我们创建了一个配置文件 <em>zoo.cfg</em> ，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime=2000  </span><br><span class="line">dataDir=/Users/ivan/zookeeper/data  </span><br><span class="line">dataLogDir=/Users/ivan/zookeeper/logs  </span><br><span class="line">clientPort=4180</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>tickTime： ZooKeeper中使用的基本时间单位, 毫秒值.</li>
<li>dataDir：数据目录，可以是任意目录</li>
<li>dataLogDir： log目录，同样可以是任意目录，如果没有设置该参数，将使用和dataDir相同的设置</li>
<li>clientPort：监听的端口号</li>
</ul>
<p>执行启动脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ./bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /root/DevTools/zookeeper-3.3.0/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>
<p>表示一个单机版的 <em>ZooKeeper</em> 启动成功，<em>ZooKeeper</em> 支持集群和伪集群模式启动。生产模式一般为集群模式以保持高可用，伪集群模式通常用于本地开发测试。安装方法都比较简单，今天主要整理一些常见的场景和命令，这里就不演示其它的安装过程了。</p>
<h2 id="4-ZooKeeper-CLI"><a href="#4-ZooKeeper-CLI" class="headerlink" title="4. ZooKeeper CLI"></a>4. ZooKeeper CLI</h2><p>ZooKeeper附带了一个用于交互式使用的命令行客户端，但实际上您可以 直接从应用程序中使用其中一种<a href="http://blog.cloudera.com/blog/2009/05/building-a-distributed-concurrent-queue-with-apache-zookeeper/" target="_blank" rel="noopener">编程语言绑定</a>。我们将演示将ZooKeeper与命令行客户端一起使用的基本原则。</p>
<p>执行 <code>./bin/zkCli.sh</code> 后，看见如下的输出即表示已经连接上了 <em>ZooKeeper</em>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Welcome to ZooKeeper!</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里省略了其它的一些输出</p>
</blockquote>
<p>在执行命令时，某些日志消息可能隐藏了初始提示，因此如果您没有看到它，只需按<code>&lt;ENTER&gt;</code>即可。尝试输入<code>ls /</code>或<code>help</code>查看其他可能的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[cluster, controller_epoch, brokers, zookeeper, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] help</span><br><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">        stat path [watch]</span><br><span class="line">        set path data [version]</span><br><span class="line">        ls path [watch]</span><br><span class="line">        delquota [-n|-b] path</span><br><span class="line">        ls2 path [watch]</span><br><span class="line">        setAcl path acl</span><br><span class="line">        setquota -n|-b val path</span><br><span class="line">        history</span><br><span class="line">        redo cmdno</span><br><span class="line">        printwatches on|off</span><br><span class="line">        delete path [version]</span><br><span class="line">        sync path</span><br><span class="line">        listquota path</span><br><span class="line">        rmr path</span><br><span class="line">        get path [watch]</span><br><span class="line">        create [-s] [-e] path data acl</span><br><span class="line">        addauth scheme auth</span><br><span class="line">        quit</span><br><span class="line">        getAcl path</span><br><span class="line">        close</span><br><span class="line">        connect host:port</span><br></pre></td></tr></table></figure>
<p>这类似于类UNIX系统中的shell和文件系统。ZooKeeper将其数据存储在<em>znode</em>结构中。每个znode都可以包含数据（如文件）并拥有子节点（如目录）。ZooKeeper旨在处理每个znode中的小块数据：<strong>默认限制为1MB</strong>。</p>
<h2 id="5-读写数据"><a href="#5-读写数据" class="headerlink" title="5. 读写数据"></a>5. 读写数据</h2><h3 id="5-1-创建——create"><a href="#5-1-创建——create" class="headerlink" title="5.1 创建——create"></a>5.1 创建——<code>create</code></h3><p>前面说了，ZooKeeper 的数据结构类似于文件系统，所以创建<em>znode</em>就像创建一个目录或者文件一样简单。比如如下的命令创建一个空的节点作为父目录，另一个节点作为其子目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] create /zk-demo ''</span><br><span class="line">Created /zk-demo</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /zk-demo/node-1 'Hello World'</span><br><span class="line">Created /zk-demo/node-1</span><br></pre></td></tr></table></figure>
<p>然后我们再通过 <code>ls</code>命令查看一下我们刚刚创建的节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 8] ls /</span><br><span class="line">[cluster, controller_epoch, brokers, zookeeper, zk-demo, admin, isr_change_notification, consumers, log_dir_event_notification, latest_producer_id_block, config]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] ls /zk-demo</span><br><span class="line">[node-1]</span><br></pre></td></tr></table></figure>
<h3 id="5-2-读取数据——get"><a href="#5-2-读取数据——get" class="headerlink" title="5.2 读取数据——get"></a>5.2 读取数据——<code>get</code></h3><p>节点创建成功后，可以使用<code>get</code>命令读取这些节点的内容。节点中包含的数据打印在第一行，之后列出元数据（<code>&lt;metadata&gt;</code>），注意它的 <em>dataVersion</em> 属性，这个属性表示版本信息，我们一会再要查看这个属性值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] get /zk-demo/node-1</span><br><span class="line">Hello World</span><br><span class="line">cZxid = 0x9b</span><br><span class="line">ctime = Sat Apr 13 03:01:24 UTC 2019</span><br><span class="line">mZxid = 0x9b</span><br><span class="line">mtime = Sat Apr 13 03:01:24 UTC 2019</span><br><span class="line">pZxid = 0x9b</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 11</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<h3 id="5-3-修改——set"><a href="#5-3-修改——set" class="headerlink" title="5.3 修改——set"></a>5.3 修改——<code>set</code></h3><p>当然，您可以在创建后修改节点，修改的过程也非常简单，重要设置一下即可。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] set /zk-demo/node-1 'Yesterday once more'</span><br><span class="line">cZxid = 0x9b</span><br><span class="line">ctime = Sat Apr 13 03:01:24 UTC 2019</span><br><span class="line">mZxid = 0x9c</span><br><span class="line">mtime = Sat Apr 13 03:06:19 UTC 2019</span><br><span class="line">pZxid = 0x9b</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 19</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] get /zk-demo/node-1</span><br><span class="line">Yesterday once more</span><br><span class="line">cZxid = 0x9b</span><br><span class="line">ctime = Sat Apr 13 03:01:24 UTC 2019</span><br><span class="line">mZxid = 0x9c</span><br><span class="line">mtime = Sat Apr 13 03:06:19 UTC 2019</span><br><span class="line">pZxid = 0x9b</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 19</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p>请注意，<em>dataVersion</em> 值已被修改（以及修改后的时间戳）。</p>
<h3 id="5-4-删除——delete"><a href="#5-4-删除——delete" class="headerlink" title="5.4 删除——delete"></a>5.4 删除——<code>delete</code></h3><p>当然，你也可以删除节点。<strong>无法删除有孩子的节点（除非他们的孩子先被删除）</strong>。删除还有一个<code>rmr</code>命令，用于递归删除节点以及节点下的所有孩子节点，可用于代替delete命令，如果发现指定节点拥有子节点时, <code>rmr</code>命令会首先删除子节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 13] delete /zk-demo/node-1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 14] get /zk-demo/node-1</span><br><span class="line">Node does not exist: /zk-demo/node-1</span><br></pre></td></tr></table></figure>
<h2 id="6-顺序节点和临时节点"><a href="#6-顺序节点和临时节点" class="headerlink" title="6. 顺序节点和临时节点"></a>6. 顺序节点和临时节点</h2><p>除了标准的节点类型，还有两种特殊类型的节点：<strong>顺序节点（sequential）</strong>和<strong>临时节点（ephemeral）</strong>。您可以通过分别将<code>-s</code>和<code>-e</code>标志传递给<code>create</code>命令来创建它们。</p>
<h3 id="6-1-顺序节点——sequence"><a href="#6-1-顺序节点——sequence" class="headerlink" title="6.1 顺序节点——sequence"></a>6.1 顺序节点——<em>sequence</em></h3><p>创建顺序节点时，我们只需要指定<em>名称前缀</em>，ZooKeeper 在创建时会自动给我们添加顺序号，并且ZooKeeper保证同时创建的两个节点将不会被赋予相同的数字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] create -s /zk-demo/fruit one</span><br><span class="line">Created /zk-demo/fruit0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] create -s /zk-demo/fruit two</span><br><span class="line">Created /zk-demo/fruit0000000002</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我们使用了相同的 <em>path(/zk-demo/fruit)</em> 来创建节点，ZooKeeper 自动为我们添加了<em>0000000001</em>的序号后缀。</p>
</blockquote>
<p>顺序节点是一个非常好的特性，比如我们可以用它来创建分布式互斥锁。如果客户端想要保留互斥锁，则会创建一个顺序节点。如果它是具有该名称的最小数字节点，则它保持锁定。如果没有，它等待。要释放互斥锁，它会删除该节点，允许下一个节点来保持锁定。</p>
<h3 id="6-2-临时节点——ephemeral"><a href="#6-2-临时节点——ephemeral" class="headerlink" title="6.2 临时节点——ephemeral"></a>6.2 临时节点——<em>ephemeral</em></h3><p>临时节点是相对于持久化节点（默认创建的节点就是持久化节点）而言的。它会和客户端会话绑定，如果创建该节点的session结束了，该节点就会被自动删除。节点不能拥有子节点. 虽然临时节点与创建它的session绑定，但只要该该节点没有被删除，其他session就可以读写该节点中关联的数据。使用<code>-e</code>参数指定创建临时节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /zk-demo/item1 fromOne</span><br><span class="line">Created /zk-demo/item1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /zk-demo</span><br><span class="line">[item1, fruit0000000001, fruit0000000002]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /zk-demo/item1</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] get /zk-demo/item1</span><br><span class="line">fromOne</span><br><span class="line">cZxid = 0xa4</span><br><span class="line">ctime = Sat Apr 13 03:27:09 UTC 2019</span><br><span class="line">mZxid = 0xa4</span><br><span class="line">mtime = Sat Apr 13 03:27:09 UTC 2019</span><br><span class="line">pZxid = 0xa4</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line"><span class="meta">#</span> 注意这里记录了临时节点的所有者，如果该客户端与服务器断开连接，这个节点将会被自动删除</span><br><span class="line">ephemeralOwner = 0x100030399c90005</span><br><span class="line">dataLength = 7</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：严格来说，顺序节点并不能算是一个类型，它和临时节点也并不冲突，一个节点可以同时是<strong>顺序节点</strong>和<strong>临时节点</strong>。</p>
</blockquote>
<p>您可以通过使临时顺序节点来实现一个非常简单的选举系统。当创建它们的客户端断开连接时，会自动删除临时节点（这意味着ZooKeeper也可以帮助您进行故障检测 - 分布式系统中的另一个难题）。客户端可以在关闭时故意断开连接，或者可以认为集群已断开连接，因为客户端超出了配置的超时而未发送心跳。创建编号最小的临时顺序节点的节点采用“Master”角色。如果计算机崩溃，或者JVM暂停太长时间以进行垃圾收集，则会删除临时节点，并且下一个符合条件的节点可以占据其位置。</p>
<h2 id="7-监听器——Watch"><a href="#7-监听器——Watch" class="headerlink" title="7. 监听器——Watch"></a>7. 监听器——<code>Watch</code></h2><p>ZooKeeper还可以通知您节点内容的变化或节点孩子节点的变化。这个是通过在节点的数据上注册<em>Watch</em>来实现的，在使用<code>get</code>或<code>stat</code>命令来访问当前内容或元数据时，添加<em>Watch</em>参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] create /zk-demo/watch-this</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /zk-demo/watch-this 'Watch Test'</span><br><span class="line">Created /zk-demo/watch-this</span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] get /zk-demo/watch-this true</span><br><span class="line">Watch Test</span><br><span class="line">cZxid = 0xa5</span><br><span class="line">ctime = Sat Apr 13 03:34:36 UTC 2019</span><br><span class="line">mZxid = 0xa5</span><br><span class="line">mtime = Sat Apr 13 03:34:36 UTC 2019</span><br><span class="line">pZxid = 0xa5</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 10</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p> 我们在执行 <code>get</code> 命令时，添加一个 <em>true</em> 参数，表示除了要获取节点信息外，我还要监控这个节点的变化。之后我们修改这个节点的内容（从当前的ZooKeeper客户端或再开启一个，或者通过程序 API 来修改都是一样），您将看到写入终端的以下消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 13]</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/zk-demo/watch-this</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这个 <em>Watcher</em> 只会生效一次，就是说它只监听一次修改，后续的修改它将收不到事件消息。如果您希望将来收到更改通知，则必须在每次触发时重置 <em>Watcher</em>。<em>Watcher</em>允许您使用ZooKeeper实现基于事件的异步系统，并在ZooKeeper中的数据本地副本过时时通知节点。</p>
</blockquote>
<h2 id="8-版本控制和ACL"><a href="#8-版本控制和ACL" class="headerlink" title="8. 版本控制和ACL"></a>8. 版本控制和ACL</h2><p>如果查看以前命令中列出的元数据，您将看到许多文件系统中常见的项目以及上面讨论过的功能：创建时间，修改时间（和相应的事务ID），内容大小（以字节为单位），和节点的创建者（如果是临时节点）。您还将看到一些有助于保护数据完整性和安全性的功能元数据：数据版本控制和ACL。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Watch Test</span><br><span class="line">cZxid = 0xa5</span><br><span class="line">ctime = Sat Apr 13 03:34:36 UTC 2013</span><br><span class="line">mZxid = 0xa9</span><br><span class="line">mtime = Sat Apr 13 03:36:08 UTC 2013</span><br><span class="line">pZxid = 0xa5</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 10</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>
<p>每次读取或写入时都会提供当前版本的数据，也可以将版本信息作为写入命令（测试和设置操作）的一部分，这样如果尝试使用指定的过期版本进行写入，则会失败（这有助于确保您不会覆盖客户端尚未处理的更改）。</p>
<p>ZooKeeper还支持使用访问控制列表（ACL）和各种身份验证系统。ACL允许您指定细粒度的权限，以定义允许创建，读取，更新或删除每个节点的用户和组。这里就不分析了，如果你感兴趣的话，可以到它的官网去查阅<a href="http://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html#sc_ZooKeeperAccessControl" target="_blank" rel="noopener">ZooKeeperAccessControl</a>。</p>
<h2 id="9-其它"><a href="#9-其它" class="headerlink" title="9. 其它"></a>9. 其它</h2><p>ZooKeeper支持各类语言的客户端，上述所有机制都可以通过各种编程语言客户端来完成，通过 API 编写更好的分布式应用程序。几个Hadoop项目已经在使用ZooKeeper协调集群并提供高可用性的分布式服务，最著名的就是Apache HBase，它使用ZooKeeper来跟踪主服务器，区域服务器以及分布在整个集群中的数据状态。</p>
<p>以下是ZooKeeper可能对项目有用的其他一些示例，您可以<a href="http://zookeeper.apache.org/doc/trunk/recipes.html" target="_blank" rel="noopener">在此处</a>找到许多这些用例所需的算法的详细信息  。</p>
<ul>
<li><ul>
<li><p>分组与命名服务</p>
<pre><code>通过让每个节点为自己注册一个临时节点（以及它可能正在履行的任何角色），您可以使用ZooKeeper替代集群中的DNS。关闭的节点会自动从列表中删除，并且您的集群始终具有活动节点的最新目录。
</code></pre><ul>
<li><p>分布式互斥锁和 Leader 选举</p>
<p>  我们在上面讨论了与顺序节点相关的ZooKeeper的这些潜在用途。这些功能可以帮助您在集群中实现自动故障转移，协调对资源的并发访问，以及安全地在集群中做出其他决策。</p>
</li>
<li><p>异步消息传递和事件广播</p>
<p>  如果吞吐量是主要考量的时候，其他工具更适合于消息传递，但我发现ZooKeeper对于在构建一些简单的<em>pub/sub</em>系统非常有用。</p>
</li>
<li><p>集中的配置管理</p>
<p>  使用ZooKeeper存储配置信息有两个主要好处。首先，只需要告知新节点如何连接到ZooKeeper，然后可以下载所有其他配置信息并确定它们应该在集群中自己扮演的角色。其次，您的应用程序可以订阅配置中的更改，允许您通过ZooKeeper客户端调整配置并在运行时修改集群的行为。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-常用命令"><a href="#10-常用命令" class="headerlink" title="10. 常用命令"></a>10. 常用命令</h2><p>对于服务管控而言，有如下的常用命令：</p>
<ol>
<li>stat: 查看ZK结点follower或leader情况。</li>
<li>srst: 重置通过stat查看的统计结果信息。</li>
<li>ruok: 测试Server，若回复imok表示已经启动。</li>
<li>dump: 列出未经处理的会话和临时节点。</li>
<li>kill: 关掉server, 必须在ZK服务运行的机器上执行。</li>
<li>conf: 输出相关服务配置的详细信息。</li>
<li>cons: 列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。</li>
<li>crst: 重置 connection/session 所有连接的统计信息。</li>
<li>envi: 输出关于服务环境的详细信息。</li>
<li>reqs: 列出未经处理的请求。</li>
<li>wchs: 列出服务器 watch 的详细信息。</li>
<li>wchc: 通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。</li>
<li>wchp: 通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。</li>
<li>srvr: 列出服务的详细信息。</li>
<li>mntr: 打印所有可以用来监控集群服务健康状态信息的变量。</li>
</ol>
<p>对于客户端操作，有如下的常用命令：</p>
<p>进入<em>zkCli</em>后敲入<em>help</em>，或者随便敲几个字符ZK会打印出如下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get path [watch]</span><br><span class="line">ls path [watch]</span><br><span class="line">set path data [version]</span><br><span class="line">rmr path</span><br><span class="line">delquota [-n|-b] path</span><br><span class="line">quit </span><br><span class="line">printwatches on|off</span><br><span class="line">create [-s] [-e] path data acl</span><br><span class="line">stat path [watch]</span><br><span class="line">close </span><br><span class="line">ls2 path [watch]</span><br><span class="line">history </span><br><span class="line">listquota path</span><br><span class="line">setAcl path acl</span><br><span class="line">getAcl path</span><br><span class="line">sync path</span><br><span class="line">redo cmdno</span><br><span class="line">addauth scheme auth</span><br><span class="line">delete path [version]</span><br><span class="line">setquota -n|-b val path</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<em>path</em> 要以 / 打头；使用监听如：<code>get /t watch</code></p>
</blockquote>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>古人对“媒人”的七个雅称</title>
    <url>/2014/04/23/gu-ren-dui-mei-ren-de-qi-ge-ya-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-37.png" alt="upload successful"></p>
<a id="more"></a>
<p><strong>伐柯</strong>：这个雅称来自《诗经·豳风·伐柯》：“伐柯如何？匪斧不克，取妻如何？匪媒不得。”意思是说怎样去砍那斧柄呢没有斧头不可能；怎样娶那妻子呢？没有媒人是不行的。《中庸》也有“执柯以伐柯”之说，后来人们便称媒人为“伐柯”或“伐柯人”。</p>
<p><img src="/images/pasted-38.png" alt="upload successful"></p>
<p><strong>保山</strong>：《红楼梦》第119回：“他说二爷不在家，大太太做得主的，况且还有舅舅做保山。”当时人们称媒人为“保山”，指像山一样稳固可靠的保证人。</p>
<p><img src="/images/pasted-39.png" alt="upload successful"></p>
<p><strong>冰人</strong>：这个名称来自于《晋书·索紞传》中的一个故事，晋时有个叫索紞的，善于解梦，预卜吉凶祸福。有一次有一个叫令狐策的人做了一个梦，梦见自己站在冰上，和冰下一个人说话。不知是何征兆，就要索紞为他解梦。索紞分析了一下梦境的情节，即对他说：“冰上为阳，冰下为阴，阴阳事也。士如归妻，适冰未泮，婚姻事也。君在冰上，与冰下人语，为阳语阴，媒介事也。君当为人做媒，冰泮而婚成。”后来令狐策果然给一个太守的儿子做媒，又碰巧把婚事说成了。所以，“冰人”即成为“媒人”的代称。</p>
<p><img src="/images/pasted-40.png" alt="upload successful"></p>
<p><strong>媒妁</strong>：媒，谓谋合二姓；妁，谓斟酌二姓。《孟子滕文公》云：“不待父母之命，媒妁之言，钻穴隙相窥，逾墙相从，则父母、国人皆贼之。”</p>
<p><img src="/images/pasted-41.png" alt="upload successful"></p>
<p><strong>月老</strong>：唐小说记载，唐代人韦固夜经宋城，遇一老人倚囊而坐，向月检书。固问所检何书。答曰：天下之婚牍。又问囊中赤绳何用答曰：以系夫妻之足。传说这位老人是主管婚姻之神，故以“月老”作为媒人的别称。</p>
<p><img src="/images/pasted-42.png" alt="upload successful"></p>
<p><strong>红娘</strong>：本是唐元稹《莺莺传》中的主人公崔莺莺的侍女。《莺莺传》写张生与崔莺莺相爱，经崔的侍女红娘从中设谋撮合，使这对有情人终成眷属，元代王实甫据此改编为《西厢记》杂剧。此后，“红娘”便成了媒人的别称。</p>
<p><img src="/images/pasted-43.png" alt="upload successful"></p>
<p><strong>红叶</strong>：这个别称来自一个爱情故事。唐僖宗时，有个叫韩翠苹的宫女渴望得到正常的人间之爱，便冒着生命危险在红叶上题诗，让红叶随着御河的水传到宫外。有一个书生在偶然中拾得题诗的红叶，为其中的幽情所感动，也题诗于红叶之上，借流水传到宫中，韩翠苹常偷空到御河边，因此也得到了题诗红叶。后来天作良缘，后宫放宫女3000人，两个有情人终于在民间相见，结为伉俪。韩翠苹感慨万端，又题诗一首道：“一联佳句随流水，十载幽情满素怀。今日却成鸾凤友，方知红叶是良媒。”此后，人们便把媒人又称为红叶。</p>
<p><img src="/images/pasted-44.png" alt="upload successful"></p>
]]></content>
      <tags>
        <tag>传统文化</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解读——JDBC</title>
    <url>/2012/03/07/spring-yuan-ma-jie-du-jdbc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面我们看看Spring JDBC相关的实现，在Spring中，JdbcTemplate是经常被使用的类来帮助用户程序操作数据库，在JdbcTemplate为用户程序提供了许多便利的数据库操作方法，比如查询，更新等，而且在Spring中，有许多类似 JdbcTemplate的模板,比如HibernateTemplate等等。<br><a id="more"></a></p>
<p>看来这是Rod.Johnson的惯用手法，一般而言这种Template中都是通过回调函数CallBack类的使用来完成功能的，客户需要在回调接口中实现自己需要的定制行为，比如使用客户想要用的SQL语句等。不过往往Spring通过这种回调函数的实现已经为我们提供了许多现成的方法供客户使用。一般来说回调函数的用法采用匿名类的方式来实现，比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcTemplate = <span class="keyword">new</span> JdbcTemplate(datasource);  </span><br><span class="line">jdbcTemplate.execute(<span class="keyword">new</span> CallBack()&#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">CallbackInterfacedoInAction</span><span class="params">()</span></span>&#123;  </span><br><span class="line">               ......  </span><br><span class="line">               <span class="comment">//用户定义的代码或者说Spring替我们实现的代码  </span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在模板中嵌入的是需要客户化的代码，由Spring来作或者需要客户程序亲自动手完成。下面让我们具体看看在JdbcTemplate中的代码是怎样完成使命的，我们举JdbcTemplate.execute()为例，这个方法是在JdbcTemplate中被其他方法调用的基本方法之一，客户程序往往用这个方法来执行基本的SQL语句：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(ConnectionCallback action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;  </span><br><span class="line">    <span class="comment">//这里得到数据库联接  </span></span><br><span class="line">    Connection con = DataSourceUtils.getConnection(getDataSource());  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Connection conToUse = con;  </span><br><span class="line">        <span class="comment">//有些特殊的数据库，需要我们使用特别的方法取得datasource  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nativeJdbcExtractor != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// Extract native JDBC Connection, castable to OracleConnection or the like.  </span></span><br><span class="line">            conToUse = <span class="keyword">this</span>.nativeJdbcExtractor.getNativeConnection(con);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// Create close-suppressing Connection proxy, also preparing returned Statements.  </span></span><br><span class="line">            conToUse = createConnectionProxy(con);  </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//这里调用的是传递进来的匿名类的方法，也就是用户程序需要实现CallBack接口的地方。  </span></span><br><span class="line">        <span class="keyword">return</span> action.doInConnection(conToUse);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;  </span><br><span class="line">        <span class="comment">//如果捕捉到数据库异常，把数据库联接释放，同时抛出一个经过Spring转换过的Spring数据库异常，  </span></span><br><span class="line">        <span class="comment">//我们知道，Spring做了一个有意义的工作是把这些数据库异常统一到自己的异常体系里了。  </span></span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());  </span><br><span class="line">        con = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">throw</span> getExceptionTranslator().translate(<span class="string">"ConnectionCallback"</span>, getSql(action), ex);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="comment">//最后不管怎样都会把数据库连接释放  </span></span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于JdbcTemplate中给出的其他方法，比如query,update,execute等的实现，我们看看query()：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">query</span><span class="params">(PreparedStatementCreator psc, <span class="keyword">final</span> PreparedStatementSetter pss, <span class="keyword">final</span> ResultSetExtractor rse)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> DataAccessException </span>&#123;  </span><br><span class="line">    ..........  </span><br><span class="line">    <span class="comment">//这里调用了我们上面看到的execute()基本方法,然而这里的回调实现是Spring为我们完成的查询过程  </span></span><br><span class="line">    <span class="keyword">return</span> execute(psc, <span class="keyword">new</span> PreparedStatementCallback() &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">            <span class="comment">//准备查询结果集  </span></span><br><span class="line">            ResultSet rs = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//这里配置SQL参数  </span></span><br><span class="line">                <span class="keyword">if</span> (pss != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    pss.setValues(ps);  </span><br><span class="line">                &#125;</span><br><span class="line">          <span class="comment">//这里执行的SQL查询  </span></span><br><span class="line">                rs = ps.executeQuery();  </span><br><span class="line">                ResultSet rsToUse = rs;  </span><br><span class="line">                <span class="keyword">if</span> (nativeJdbcExtractor != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);  </span><br><span class="line">                &#125;</span><br><span class="line">         <span class="comment">//返回需要的记录集合  </span></span><br><span class="line">                <span class="keyword">return</span> rse.extractData(rsToUse);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="comment">//最后关闭查询的纪录集，对数据库连接的释放在execute()中释放，就像我们在上面分析的看到那样。  </span></span><br><span class="line">                JdbcUtils.closeResultSet(rs);  </span><br><span class="line">                <span class="keyword">if</span> (pss <span class="keyword">instanceof</span> ParameterDisposer) &#123;  </span><br><span class="line">                    ((ParameterDisposer) pss).cleanupParameters();  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>辅助类DataSourceUtils来用来对数据库连接进行管理的主要工具，比如打开和关闭数据库连接等基本操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">doGetConnection</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">   <span class="comment">//把对数据库连接放到事务管理里面进行管理  </span></span><br><span class="line">    ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);  </span><br><span class="line">    <span class="keyword">if</span> (conHolder != <span class="keyword">null</span> &amp;&amp; (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) &#123;  </span><br><span class="line">        conHolder.requested();  </span><br><span class="line">        <span class="keyword">if</span> (!conHolder.hasConnection()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Fetching resumed JDBC Connection from DataSource"</span>);  </span><br><span class="line">            conHolder.setConnection(dataSource.getConnection());  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conHolder.getConnection();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里得到需要的数据库连接，在配置文件中定义好的。  </span></span><br><span class="line">    logger.debug(<span class="string">"Fetching JDBC Connection from DataSource"</span>);  </span><br><span class="line">    Connection con = dataSource.getConnection();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;  </span><br><span class="line">        logger.debug(<span class="string">"Registering transaction synchronization for JDBC Connection"</span>);  </span><br><span class="line">        <span class="comment">// Use same Connection for further JDBC actions within the transaction.  </span></span><br><span class="line">        <span class="comment">// Thread-bound object will get removed by synchronization at transaction completion.  </span></span><br><span class="line">        ConnectionHolder holderToUse = conHolder;  </span><br><span class="line">        <span class="keyword">if</span> (holderToUse == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            holderToUse = <span class="keyword">new</span> ConnectionHolder(con);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            holderToUse.setConnection(con);  </span><br><span class="line">        &#125;</span><br><span class="line">        holderToUse.requested();  </span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(  </span><br><span class="line">                <span class="keyword">new</span> ConnectionSynchronization(holderToUse, dataSource));  </span><br><span class="line">        holderToUse.setSynchronizedWithTransaction(<span class="keyword">true</span>);  </span><br><span class="line">        <span class="keyword">if</span> (holderToUse != conHolder) &#123;  </span><br><span class="line">            TransactionSynchronizationManager.bindResource(dataSource, holderToUse);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> con;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那我们实际的DataSource对象是怎样得到的？很清楚我们需要在上下文中进行配置：它作为JdbcTemplate父类JdbcAccessor的属性存在：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcAccessor</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 这里是我们依赖注入数据库数据源的地方。 */</span>  </span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Helper to translate SQL exceptions to DataAccessExceptions */</span>  </span><br><span class="line">    <span class="keyword">private</span> SQLExceptionTranslator exceptionTranslator;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit = <span class="keyword">true</span>;  </span><br><span class="line">  </span><br><span class="line">    ........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而对于DataSource的缓冲池实现，我们通过定义Apache Jakarta Commons DBCP或者C3P0提供的DataSource来完成，然后只要在上下文中配置好就可以使用了。从上面我们看到JdbcTemplate提供了许多简单查询和更新功能，但是如果需要更高层次的抽象，以及更面向对象的方法来访问数据库。Spring为我们提供了org.springframework.jdbc.object包，这里面包含了SqlQuery,SqlMappingQuery, SqlUpdate和StoredProcedure等类，这些类都是Spring JDBC应用程序可以使用的主要类，但我们要注意使用这些类的时候，用户需要为他们配置好一个JdbcTemplate作为其基本的操作的实现。<br>比如说我们使用MappingSqlQuery来将表数据直接映射到一个对象集合 - 具体可以参考书中的例子<br>1.我们需要建立DataSource和sql语句并建立持有这些对象的MappingSqlQuery对象<br>2.然后我们需要定义传递的SqlParameter,具体的实现我们在MappingSqlQuery的父类RdbmsOperation中可以找到：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareParameter</span><span class="params">(SqlParameter param)</span> <span class="keyword">throws</span> InvalidDataAccessApiUsageException </span>&#123;  </span><br><span class="line">   <span class="comment">//如果声明已经被编译过，则该声明无效  </span></span><br><span class="line">   <span class="keyword">if</span> (isCompiled()) &#123;  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InvalidDataAccessApiUsageException(<span class="string">"Cannot add parameters once query is compiled"</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//这里对参数值进行声明定义  </span></span><br><span class="line">   <span class="keyword">this</span>.declaredParameters.add(param);</span><br></pre></td></tr></table></figure></p>
<p>而这个declareParameters维护的是一个列表：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** List of SqlParameter objects */</span>  </span><br><span class="line"><span class="keyword">private</span> List declaredParameters = <span class="keyword">new</span> LinkedList();</span><br></pre></td></tr></table></figure></p>
<p>这个列表在以后compile的过程中会被使用。<br>3.然后用户程序需要实现MappingSqlQuery的mapRow接口，将具体的ResultSet数据生成我们需要的对象，这是我们迭代使用的方法。1，2，3步实际上为我们定义好了一个迭代的基本单元作为操作模板。<br>4.在应用程序，我们直接调用execute()方法得到我们需要的对象列表，列表中的每一个对象的数据来自于执行SQL语句得到记录集的每一条记录，事实上执行的execute在父类SqlQuery中起作用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List <span class="title">executeByNamedParam</span><span class="params">(Map paramMap, Map context)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;  </span><br><span class="line">    validateNamedParameters(paramMap);  </span><br><span class="line">    Object[] parameters = NamedParameterUtils.buildValueArray(getSql(), paramMap);  </span><br><span class="line">    RowMapper rowMapper = newRowMapper(parameters, context);  </span><br><span class="line">    String sqlToUse = NamedParameterUtils.substituteNamedParameters(getSql(), <span class="keyword">new</span> MapSqlParameterSource(paramMap));  </span><br><span class="line">    <span class="comment">//我们又看到了JdbcTemplate,这里使用JdbcTemplate来完成对数据库的查询操作，所以我们说JdbcTemplate是基本的操作类。  </span></span><br><span class="line">     <span class="keyword">return</span> getJdbcTemplate().query(newPreparedStatementCreator(sqlToUse, parameters), rowMapper);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们可以看到template模式的精彩应用和对JdbcTemplate的灵活使用。通过使用它，我们免去了手工迭代ResultSet并将其中的数据转化为对象列表的重复过程。在这里我们只需要定义SQL语句和SqlParameter - 如果需要的话，往往SQL语句就常常能够满足我们的要求了。这是灵活使用JdbcTemplate的一个很好的例子。<br>Spring还为其他数据库操作提供了许多服务，比如使用SqlUpdate插入和更新数据库，使用UpdatableSqlQuery更新ResultSet，生成主键，调用存储过程等。<br>书中还给出了对BLOB数据和CLOB数据进行数据库操作的例子：<br>对BLOB数据的操作通过LobHander来完成，通过调用JdbcTemplate和RDBMS都可以进行操作：<br>在JdbcTemplate中，具体的调用可以参考书中的例子 - 是通过以下调用起作用的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(String sql, PreparedStatementCallback action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> SimplePreparedStatementCreator(sql), action);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后通过对实现PreparedStatementCallback接口的AbstractLobCreatingPreparedStatementCallback的回调函数来完成：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException, DataAccessException </span>&#123;  </span><br><span class="line">    LobCreator lobCreator = <span class="keyword">this</span>.lobHandler.getLobCreator();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="comment">//这是一个模板方法，具体需要由客户程序实现  </span></span><br><span class="line">        setValues(ps, lobCreator);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(ps.executeUpdate());  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;  </span><br><span class="line">        lobCreator.close();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义的需要客户程序实现的虚函数  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PreparedStatement ps, LobCreator lobCreator)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span><br></pre></td></tr></table></figure></p>
<p>而我们注意到setValues()是一个需要实现的抽象方法，应用程序通过实现setValues来定义自己的操作 - 在setValues中调用lobCreator.setBlobAsBinaryStrem()。让我们看看具体的BLOB操作在LobCreator是怎样完成的，我们一般使用DefaultLobCreator作为BLOB操作的驱动：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlobAsBinaryStream</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        PreparedStatement ps, <span class="keyword">int</span> paramIndex, InputStream binaryStream, <span class="keyword">int</span> contentLength)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">    <span class="comment">//通过JDBC来完成对BLOB数据的操作，对Oracle,Spring提供了OracleLobHandler来支持BLOB操作。  </span></span><br><span class="line">    ps.setBinaryStream(paramIndex, binaryStream, contentLength);  </span><br><span class="line">    ........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面提到的是零零碎碎的Spring JDBC使用的例子，可以看到使用Spring JDBC可以帮助我们完成许多数据库的操作。Spring对数据库操作最基本的服务是通过JdbcTeamplate和他常用的回调函数来实现的，在此之上，又提供了许多RMDB的操作来帮助我们更便利的对数据库的数据进行操作 - 注意这里没有引入向Hibernate这样的O/R方案。对这些O/R方案的支持，Spring由其他包来完成服务。<br>书中还提到关于execute和update方法之间的区别，update方法返回的是受影响的记录数目的一个计数，并且如果传入参数的话，使用的是java.sql.PreparedStatement,而execute方法总是使用 java.sql.Statement,不接受参数，而且他不返回受影响记录的计数，更适合于创建和丢弃表的语句，而update方法更适合于插入，更新和删除操作，这也是我们在使用时需要注意的。 </p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>古人对年龄的称呼</title>
    <url>/2016/03/23/gu-ren-dui-nian-ling-de-cheng-hu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-93.png" alt="upload successful"></p>
<p>现在人们说年龄</p>
<p>都是很直接的1岁、10岁、40岁</p>
<p>简单明了</p>
<p>却貌似少了一点“韵味”</p>
<p>那么古人对于年龄</p>
<p>又是如何称谓呢？</p>
<p>有些称谓现在还能听到</p>
<p>但有些已经很少有人知道<br><a id="more"></a></p>
<h3 id="幼年"><a href="#幼年" class="headerlink" title="幼年"></a>幼年</h3><p>度：小儿初生之时。</p>
<p>汤饼之期：指婴儿出生3日。</p>
<p>赤子、襁褓：未满周岁的婴儿。</p>
<p>牙牙：象声词，婴儿学语的声音，指1岁。</p>
<p>孩提：指初知发笑尚在襁褓中的幼儿，指2—3岁的儿童。</p>
<p>始龀：男孩8岁，女孩7岁。根据生理状况，男孩8岁、女孩7岁换牙，脱去乳齿，长出恒牙，这时叫“龀”，“龆年”或“髫年”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">蓬头稚子学垂纶，侧坐莓苔草映身。</span><br><span class="line"></span><br><span class="line">路人借问遥招手，怕得鱼惊不应人。</span><br><span class="line"></span><br><span class="line">			——胡令能《小儿垂钓》</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-94.png" alt="upload successful"></p>
<h3 id="总角"><a href="#总角" class="headerlink" title="总角"></a>总角</h3><p>八九岁至十三四岁的少年</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总角之宴，言笑晏晏。</span><br><span class="line"></span><br><span class="line">信誓旦旦，不思其反。</span><br><span class="line"></span><br><span class="line">			——《诗经·卫风·氓》</span><br></pre></td></tr></table></figure>
<p>九龄：9岁。</p>
<p>指数之年：9岁。</p>
<p>黄口：10岁以下。</p>
<p>幼学：10岁。<strong>《礼记·曲礼上》：“人生十年曰幼学。”</strong></p>
<p>外傅之年：儿童10岁。</p>
<p><img src="/images/pasted-95.png" alt="upload successful"></p>
<h3 id="少年"><a href="#少年" class="headerlink" title="少年"></a>少年</h3><p>金钗之年：女孩12岁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">头上金钗十二行，足下丝履五文章。</span><br><span class="line"></span><br><span class="line">				——《河中之水歌》</span><br></pre></td></tr></table></figure>
<p>豆蔻：指女子十三四岁至十五六岁（豆蔻是一种初夏开花的植物，初夏还不是盛夏，比喻人还未成年，故称未成年的少年时代为“豆蔻年华”）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">娉娉袅袅十三余，豆蔻梢头二月初。</span><br><span class="line"></span><br><span class="line">春风十里扬州路，卷上珠帘总不如。</span><br><span class="line"></span><br><span class="line">				——《赠别》</span><br></pre></td></tr></table></figure>
<p>舞夕之年：少年13至15岁。</p>
<p>及笄（jí jī）：指女子15岁。</p>
<blockquote>
<p>志学之年：<strong>孔子曰，“吾十有五而志于学。”</strong></p>
</blockquote>
<p><img src="/images/pasted-96.png" alt="upload successful"></p>
<h3 id="青年"><a href="#青年" class="headerlink" title="青年"></a>青年</h3><p>成童：15或15稍上的年岁。</p>
<p>舞象之年：少年15至20岁。</p>
<p>二八：为16岁。</p>
<p>破瓜、碧玉年华：女子16岁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">碧玉小家女，不敢攀贵德。</span><br><span class="line"></span><br><span class="line">感郎千金意，惭无倾城色。</span><br><span class="line"></span><br><span class="line">碧玉破瓜时，相为情颠倒。</span><br><span class="line"></span><br><span class="line">感郎不羞郎，回身就郎抱。</span><br><span class="line"></span><br><span class="line">		——《碧玉歌》</span><br></pre></td></tr></table></figure>
<p>加冠：指男子20岁。古时男子20岁行加冠礼，表示已成年。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">嗟我客上都，忽已见暮春。</span><br><span class="line"></span><br><span class="line">骑马出闇门，眯眼吹红尘。</span><br><span class="line"></span><br><span class="line">西湖商贾区，山僧多市人；</span><br><span class="line"></span><br><span class="line">谁令污泉石，只合加冠巾。</span><br><span class="line"></span><br><span class="line">黄冠更可憎，状与屠沽邻，齁齁酒肉气，吾辈何由亲！</span><br><span class="line"></span><br><span class="line">少须一哄散，境寂鸥自驯。</span><br><span class="line"></span><br><span class="line">举手邀素月，移舟采青苹。</span><br><span class="line"></span><br><span class="line">钟从南山来，殷殷浮烟津。鹤发隐者欤？</span><br><span class="line"></span><br><span class="line">长歌收钓缗。畏冷不竟夕，恨此老病身。</span><br><span class="line"></span><br><span class="line">明发复扰扰，吾诗其绝麟。</span><br><span class="line"></span><br><span class="line">				——陆游《夜泛西湖示桑甥世昌》</span><br></pre></td></tr></table></figure>
<p><strong>弱冠：古人20岁行冠礼，以示成年，但体犹未壮，故称“弱冠”。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弱冠同怀长者忧，临岐回想尽悠悠。</span><br><span class="line"></span><br><span class="line">耦耕若便遗身老，黄发相看万事休。</span><br><span class="line"></span><br><span class="line">				——刘禹锡《重答柳柳州》</span><br></pre></td></tr></table></figure>
<p><strong>桃李年华：女子20岁。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">粉淡香清自一家，未容桃李占年华。</span><br><span class="line"></span><br><span class="line">常思南郑清明路，醉袖迎风雪一杈。</span><br><span class="line"></span><br><span class="line">				——陆游《梨花》</span><br></pre></td></tr></table></figure>
<p><strong>花信年华：女子24岁。</strong></p>
<p>而立（而立之年）：30岁，因为《论语》有言，“三十而立，四十而不惑。”</p>
<p>始室：30岁。《礼记·内则》：“三十而有室，始理男事”。</p>
<p>克壮：正当壮年，古代30岁为壮。</p>
<p><strong>半老徐娘：女子30岁。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花作婵娟玉作妆，风流争似旧徐娘。 </span><br><span class="line"></span><br><span class="line">夜深曲曲湾湾月，万里随君一寸肠。</span><br><span class="line"></span><br><span class="line">				——刘禹锡《七绝 梦扬州乐妓和诗》</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-97.png" alt="upload successful"></p>
<h3 id="中年"><a href="#中年" class="headerlink" title="中年"></a>中年</h3><p><strong>不惑（不惑之年）：40岁为“不惑之年”。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不惑之年，心宜不动。</span><br><span class="line"></span><br><span class="line">常思玉金枷重。无常一著可伤悲，悟时速把良缘种。</span><br><span class="line"></span><br><span class="line">鄙了惺惺，装成懵懂。修完内貌频看供。功成行满去朝元，瑞云。</span><br><span class="line"></span><br><span class="line">				——《踏云行 赠张公》</span><br></pre></td></tr></table></figure>
<p>艾：50岁。《礼记·曲礼上》：“五十曰艾。”</p>
<p><strong>半百、知天命、知命之年：50岁。</strong></p>
<p>六九年：即54岁。</p>
<p><img src="/images/pasted-98.png" alt="upload successful"></p>
<p>###老年</p>
<p><strong>耳顺</strong>、<strong>花甲</strong> 之年：均指60岁。</p>
<p><strong>高龄</strong>：敬辞，称老人的年龄，多指60岁以上。</p>
<p>耆：古称60岁的人为“耆”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">继粟继肉，以养贤才；</span><br><span class="line"></span><br><span class="line">祝鲠祝噎，以礼耆耋。</span><br><span class="line"></span><br><span class="line">				—— 陆游 《谢致仕表》</span><br></pre></td></tr></table></figure>
<p>下寿：古人以60为下寿，指60岁以上。</p>
<p>还历寿：61岁的寿辰。</p>
<p>从心之年：70岁。</p>
<p>古稀：古代人活到70岁，也就很不容易了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">七十人言自古稀，我今过二未全衰。</span><br><span class="line"></span><br><span class="line">读书似走名场日，许国如骑战马时。</span><br><span class="line"></span><br><span class="line">秋晚雁来空自感，夜阑酒尽不胜悲。</span><br><span class="line"></span><br><span class="line">渭滨星霣逾千载，一表何人继出师！</span><br><span class="line"></span><br><span class="line">				——陆游《七十二岁吟》</span><br></pre></td></tr></table></figure>
<p>悬车之年、杖围之年：均指70岁。</p>
<p>耋：七八十岁的年纪，泛指老年。如：耄耋之年。</p>
<p>喜寿：指77岁，草书喜字似七十七，故特代指77岁。</p>
<p>朝枚之年、朝枝之年：均指八九十岁。</p>
<p>伞寿：80岁寿辰。因伞字的草体形似八十，故称“伞寿”。</p>
<p>中寿：指80岁以上。</p>
<p>米寿：指88岁。因米字拆开好似八十八，故借指88岁。</p>
<p>上寿：90岁为上寿。</p>
<p>白寿：指99岁，百少一为99，故借指99岁。</p>
<p>期颐：指百岁高寿。</p>
<p>茶寿：指108岁。茶字上面廿，下面为八十八，二者相加得108岁。</p>
<p>双稀、双庆：140岁。古稀指70岁，因此双稀是70岁的两倍140岁。</p>
]]></content>
      <tags>
        <tag>古代文化</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试利器——Hamcrest</title>
    <url>/2016/04/08/dan-yuan-ce-shi-li-qi-hamcrest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>最近在翻阅 Spring 源码的时候，发现它引入了一个新的框架来进行单元测试——<a href="http://hamcrest.org/" target="_blank" rel="noopener"><strong>Hamcrest</strong> </a>。查阅相关的资料学习了一下，发现确实是一个非常简洁高效的测试框架，它捆绑在JUnit中。</p>
<p>记录一下<strong>探索Hamcrest API</strong>并学习的过程，让更多的人了解到这种直观的单元测试。</p>
<a id="more"></a>
<h2 id="2-Hamcrest依赖"><a href="#2-Hamcrest依赖" class="headerlink" title="2. Hamcrest依赖"></a>2. Hamcrest依赖</h2><p>我们可以通过在<em>pom.xml</em>文件中添加以下依赖项来将<strong>Hamcrest</strong>与maven一起使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在<a href="https://search.maven.org/classic/#search%7Cga%7C1%7Ca%3A%22hamcrest-all%22" target="_blank" rel="noopener">此处</a>找到此库的最新版本。</p>
<h2 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h2><p><strong>Hamcrest</strong>通常与<em>junit</em>和其他测试框架一起用于进行断言。具体来说，我们只使用API的单个<em>assertThat</em>语句与适当的匹配器，而不是使用<em>junit</em>的众多<em>assert</em>方法。</p>
<p>让我们看一个测试两个 <em>String</em> 的相似性的例子，以便清楚地了解<strong>Hamcrest</strong>如何进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringMatcherTest</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Strings_whenEqual_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"foo"</span>;</span><br><span class="line">        String b = <span class="string">"FOO"</span>;</span><br><span class="line">        assertThat(a, equalToIgnoringCase(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接下来的部分中，我们将介绍<strong>Hamcrest</strong>提供的其他几个常见匹配器。</p>
<h2 id="4-Class-匹配器"><a href="#4-Class-匹配器" class="headerlink" title="4. Class 匹配器"></a>4. <em>Class</em> 匹配器</h2><p><strong>Hamcrest</strong>提供了用于在任意Java对象上进行断言的匹配器。</p>
<p>断言 <em>Object</em> 的 <em>toString</em> 方法返回指定的 <em>String</em> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenBean_whenToStringReturnsRequiredString_thenCorrect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person=<span class="keyword">new</span> Person(<span class="string">"Barrack"</span>, <span class="string">"Washington"</span>);</span><br><span class="line">    String str=person.toString();</span><br><span class="line">    assertThat(person,hasToString(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以检查一个类是另一个类的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Classes_whenOneInheritsFromOther_thenCorrect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertThat(Cat<span class="class">.<span class="keyword">class</span>,<span class="title">typeCompatibleWith</span>(<span class="title">Animal</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-bean-匹配器"><a href="#5-bean-匹配器" class="headerlink" title="5. bean 匹配器"></a>5. bean 匹配器</h2><p>我们可以使用<strong>Hamcrest</strong>的Bean匹配器来检查Java bean的属性。</p>
<p>假设以下 <em>Person</em>  bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String address;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String personName, String personAddress)</span> </span>&#123;</span><br><span class="line">        name = personName;</span><br><span class="line">        address = personAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以检查bean是否具有<em>name</em> 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenBean_whenHasValue_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Baeldung"</span>, <span class="number">25</span>);</span><br><span class="line">    assertThat(person, hasProperty(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以检查 <em>Person</em>  是否具有<em>地址</em>属性，并且值为纽约：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenBean_whenHasCorrectValue_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Baeldung"</span>, <span class="string">"New York"</span>);</span><br><span class="line">    assertThat(person, hasProperty(<span class="string">"address"</span>, equalTo(<span class="string">"New York"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以检查是否使用相同的值构造了两个 <em>Person</em> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Beans_whenHavingSameValues_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person(<span class="string">"Baeldung"</span>, <span class="string">"New York"</span>);</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person(<span class="string">"Baeldung"</span>, <span class="string">"New York"</span>);</span><br><span class="line">    assertThat(person1, samePropertyValuesAs(person2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Collection-匹配器"><a href="#6-Collection-匹配器" class="headerlink" title="6. Collection 匹配器"></a>6. <em>Collection</em> 匹配器</h2><p><strong>Hamcrest</strong>提供用于检查<em>Collection</em> 的匹配器。</p>
<p>简单检查一下<em>Collection</em>是否为空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenCollection_whenEmpty_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; emptyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    assertThat(emptyList, empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要检查<em>Collection</em> 的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAList_whenChecksSize_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; hamcrestMatchers = Arrays.asList(</span><br><span class="line">      <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span>);</span><br><span class="line">    assertThat(hamcrestMatchers, hasSize(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，对于数组也有类似的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenArray_whenChecksSize_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] hamcrestMatchers = &#123; <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span> &#125;;</span><br><span class="line">    assertThat(hamcrestMatchers, arrayWithSize(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查<em>Collection是否</em>包含给定成员（无论顺序如何）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAListAndValues_whenChecksListForGivenValues_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; hamcrestMatchers = Arrays.asList(</span><br><span class="line">      <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span>);</span><br><span class="line">    assertThat(hamcrestMatchers,</span><br><span class="line">    containsInAnyOrder(<span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"collections"</span>, <span class="string">"number"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步断言<em>Collection</em> 成员（按给定顺序排列）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAListAndValues_whenChecksListForGivenValuesWithOrder_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; hamcrestMatchers = Arrays.asList(</span><br><span class="line">      <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span>);</span><br><span class="line">    assertThat(hamcrestMatchers,</span><br><span class="line">    contains(<span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要检查数组是否包含给定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenArrayAndValue_whenValueFoundInArray_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] hamcrestMatchers = &#123; <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span> &#125;;</span><br><span class="line">    assertThat(hamcrestMatchers, hasItemInArray(<span class="string">"text"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以反过来，测试某个元素是否存在于某个 <em>Collection</em> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenValueAndArray_whenValueIsOneOfArrayElements_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] hamcrestMatchers = &#123; <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span> &#125;;</span><br><span class="line">    assertThat(<span class="string">"text"</span>, isOneOf(hamcrestMatchers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个相似的 API 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenValueAndArray_whenValueFoundInArray_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>,</span><br><span class="line">      <span class="string">"number"</span> &#125;;</span><br><span class="line">    assertThat(<span class="string">"beans"</span>, isIn(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，对于数组也有这样的 API，检查数组是否包含某个元素（顺序无关）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenArrayAndValues_whenValuesFoundInArray_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] hamcrestMatchers = &#123; <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span> &#125;;</span><br><span class="line">      assertThat(hamcrestMatchers,</span><br><span class="line">    arrayContainingInAnyOrder(<span class="string">"beans"</span>, <span class="string">"collections"</span>, <span class="string">"number"</span>,</span><br><span class="line">      <span class="string">"text"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要检查数组是否包含给定元素但是按给定顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenArrayAndValues_whenValuesFoundInArrayInOrder_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] hamcrestMatchers = &#123; <span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span> &#125;;</span><br><span class="line">    assertThat(hamcrestMatchers,</span><br><span class="line">    arrayContaining(<span class="string">"collections"</span>, <span class="string">"beans"</span>, <span class="string">"text"</span>, <span class="string">"number"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 <em>Map</em> ，可以使用以下匹配器：</p>
<p>要检查它是否包含给定的 key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenMapAndKey_whenKeyFoundInMap_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"blogname"</span>, <span class="string">"baeldung"</span>);</span><br><span class="line">    assertThat(map, hasKey(<span class="string">"blogname"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和给定的 value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenMapAndValue_whenValueFoundInMap_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"blogname"</span>, <span class="string">"baeldung"</span>);</span><br><span class="line">    assertThat(map, hasValue(<span class="string">"baeldung"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 <em>Entry</em>  ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenMapAndEntry_whenEntryFoundInMap_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"blogname"</span>, <span class="string">"baeldung"</span>);</span><br><span class="line">    assertThat(map, hasEntry(<span class="string">"blogname"</span>, <span class="string">"baeldung"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-Number-匹配器"><a href="#7-Number-匹配器" class="headerlink" title="7. Number 匹配器"></a>7. <em>Number</em> 匹配器</h2><p>该<em>Numerb</em> 匹配器是用来对变量进行数字相关的断言。</p>
<p>要检查 <em>greatThen</em> 条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAnInteger_whenGreaterThan0_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThat(<span class="number">1</span>, greaterThan(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 <em>greaterThan</em> 或 <em>equalTo</em> 条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAnInteger_whenGreaterThanOrEqTo5_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThat(<span class="number">5</span>, greaterThanOrEqualTo(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 <em>lessThan</em> 条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAnInteger_whenLessThan0_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThat(-<span class="number">1</span>, lessThan(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 <em>lessThan</em> 或 <em>equalTo</em> 条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAnInteger_whenLessThanOrEqTo5_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThat(-<span class="number">1</span>, lessThanOrEqualTo(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要检查 <em>closeTo</em> 条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenADouble_whenCloseTo_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThat(<span class="number">1.2</span>, closeTo(<span class="number">1</span>, <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个检查方法特别的有意思，但是个人认为适用的场景并不是很多，它是用来测试 <strong>某个数字是否约等于基准值（第二个参数为误差范围）</strong></p>
<h2 id="8-Text-匹配器"><a href="#8-Text-匹配器" class="headerlink" title="8. Text 匹配器"></a>8. <em>Text</em> 匹配器</h2><p>使用<strong>Hamcrest</strong>的文本匹配器，对<em>String</em>的断言变得更容易，更整洁，更直观。</p>
<p>要检查 <em>String</em> 是否为空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenString_whenEmpty_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">""</span>;</span><br><span class="line">    assertThat(str, isEmptyString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要检查 <em>String</em> 是空还是 <em>null</em> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenString_whenEmptyOrNull_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    assertThat(str, isEmptyOrNullString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查两个<em>String</em>的是否相等（忽略空格）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Strings_whenEqualRegardlessWhiteSpace_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"text"</span>;</span><br><span class="line">    String str2 = <span class="string">" text "</span>;</span><br><span class="line">    assertThat(str1, equalToIgnoringWhiteSpace(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以检查给定顺序中给定 <em>String</em> 中是否存在一个或多个子字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenString_whenContainsGivenSubstring_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"calligraphy"</span>;</span><br><span class="line">    assertThat(str, stringContainsInOrder(Arrays.asList(<span class="string">"call"</span>, <span class="string">"graph"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查两个 <em>String</em> 是否相等（忽略大小写）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Strings_whenEqual_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"foo"</span>;</span><br><span class="line">    String b = <span class="string">"FOO"</span>;</span><br><span class="line">    assertThat(a, equalToIgnoringCase(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-核心API"><a href="#9-核心API" class="headerlink" title="9. 核心API"></a>9. 核心API</h2><p>虽然 <strong>Hamcrest</strong> 核心API是通过第三方框架提供的。但是，它为我们提供了一些很好的结构，使我们的单元测试更具可读性，还有一些可以轻松使用的核心匹配器。</p>
<h3 id="9-1-is"><a href="#9-1-is" class="headerlink" title="9.1 is"></a>9.1 <em>is</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Strings_whenIsEqualRegardlessWhiteSpace_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"text"</span>;</span><br><span class="line">    String str2 = <span class="string">" text "</span>;</span><br><span class="line">    assertThat(str1, is(equalToIgnoringWhiteSpace(str2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-not"><a href="#9-2-not" class="headerlink" title="9.2 not"></a>9.2 <em>not</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Strings_whenIsNotEqualRegardlessWhiteSpace_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"text"</span>;</span><br><span class="line">    String str2 = <span class="string">" texts "</span>;</span><br><span class="line">    assertThat(str1, not(equalToIgnoringWhiteSpace(str2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-String"><a href="#9-3-String" class="headerlink" title="9.3 String"></a>9.3 <em>String</em></h3><p>检查<em>String是否</em>包含给定的子字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAStrings_whenContainsAnotherGivenString_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"calligraphy"</span>;</span><br><span class="line">    String str2 = <span class="string">"call"</span>;</span><br><span class="line">    assertThat(str1, containsString(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查<em>String</em>是否以给定的子<em>字符串</em>开头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void givenAString_whenStartsWithAnotherGivenString_thenCorrect() &#123;</span><br><span class="line">    String str1 = &quot;calligraphy&quot;;</span><br><span class="line">    String str2 = &quot;call&quot;;</span><br><span class="line">    assertThat(str1, startsWith(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查<em>String</em>是否以给定的子字符串结尾：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAString_whenEndsWithAnotherGivenString_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"calligraphy"</span>;</span><br><span class="line">    String str2 = <span class="string">"phy"</span>;</span><br><span class="line">    assertThat(str1, endsWith(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-4-Object"><a href="#9-4-Object" class="headerlink" title="9.4 Object"></a>9.4 <em>Object</em></h3><p>检查两个<em>Object</em>是否属于同一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">given2Objects_whenSameInstance_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat=<span class="keyword">new</span> Cat();</span><br><span class="line">    assertThat(cat, sameInstance(cat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查<em>Object</em>是否是给定类的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenAnObject_whenInstanceOfGivenClass_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat=<span class="keyword">new</span> Cat();</span><br><span class="line">    assertThat(cat, instanceOf(Cat<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-5-Collection"><a href="#9-5-Collection" class="headerlink" title="9.5 Collection"></a>9.5 <em>Collection</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenList_whenEachElementGreaterThan0_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> baseCase = <span class="number">0</span>;</span><br><span class="line">    assertThat(list, everyItem(greaterThan(baseCase)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-断言链"><a href="#9-6-断言链" class="headerlink" title="9.6 断言链"></a>9.6 <em>断言链</em></h3><p><em>anyOf</em>：当目标满足任何条件时测试通过，类似于逻辑OR：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenString_whenMeetsAnyOfGivenConditions_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"calligraphy"</span>;</span><br><span class="line">    String start = <span class="string">"call"</span>;</span><br><span class="line">    String end = <span class="string">"foo"</span>;</span><br><span class="line">    assertThat(str, anyOf(startsWith(start), containsString(end)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>allOf</em>：只有在目标满足所有条件时才通过测试，类似于逻辑AND：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenString_whenMeetsAllOfGivenConditions_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"calligraphy"</span>;</span><br><span class="line">    String start = <span class="string">"call"</span>;</span><br><span class="line">    String end = <span class="string">"phy"</span>;</span><br><span class="line">    assertThat(str, allOf(startsWith(start), endsWith(end)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-自定义匹配器"><a href="#10-自定义匹配器" class="headerlink" title="10.自定义匹配器"></a>10.自定义匹配器</h2><p>我们可以通过扩展<em>TypeSafeMatcher</em>来定义我们自己的匹配器。比如，我们将创建一个自定义匹配器，只有当目标是正整数时才允许测试通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsPositiveInteger</span> <span class="keyword">extends</span> <span class="title">TypeSafeMatcher</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeTo</span><span class="params">(Description description)</span> </span>&#123;</span><br><span class="line">        description.appendText(<span class="string">"a positive integer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Factory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Matcher&lt;Integer&gt; <span class="title">isAPositiveInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IsPositiveInteger();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesSafely</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> integer &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要实现 <em>matchSafely</em> 方法来检查目标是否确实是一个正整数，而 <em>describeTo</em> 方法在测试未通过的情况下产生失败消息。</p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenInteger_whenAPositiveValue_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    assertThat(num, isAPositiveInteger());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们验证一个负数，错误信息将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.AssertionError: Expected: a positive integer but: was &lt;-1&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>单元测试</tag>
        <tag>Hamcrest</tag>
      </tags>
  </entry>
  <entry>
    <title>在Spring Boot中格式化JSON日期</title>
    <url>/2016/08/24/zai-spring-boot-zhong-ge-shi-hua-json-ri-qi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在本教程中，我们将展示如何在Spring Boot应用程序中格式化JSON日期字段。</p>
<p>我们将探讨使用Jackson格式化日期的各种方法，它被Spring Boot用作默认的JSON处理器。</p>
<a id="more"></a>
<h3 id="2-在日期字段上使用-JsonFormat"><a href="#2-在日期字段上使用-JsonFormat" class="headerlink" title="2. 在日期字段上使用@JsonFormat"></a>2. 在日期字段上使用@JsonFormat</h3><h4 id="2-1-设置格式"><a href="#2-1-设置格式" class="headerlink" title="2.1 设置格式"></a>2.1 设置格式</h4><p>我们可以使用 @JsonFormat注释来格式化特定字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="keyword">private</span> LocalDate birthday;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime lastUpdate;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生日字段上，我们使用的格式只显示日期，而在 lastUpdate字段中我们也包含时间。</p>
<p>我们使用了Java 8日期类型，它们非常便于处理时态类型。当然，如果我们需要使用像java.util.Date 这样的遗留类型 ，我们可以以相同的方式使用注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactWithJavaUtilDate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// other fields</span></span><br><span class="line"> </span><br><span class="line">     <span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">     <span class="keyword">private</span> Date birthday;</span><br><span class="line">      </span><br><span class="line">     <span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">     <span class="keyword">private</span> Date lastUpdate;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，让我们看看使用给定日期格式的@JsonFormat 呈现的输出 ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"birthday"</span>: <span class="string">"2019-02-03"</span>,</span><br><span class="line">    <span class="attr">"lastUpdate"</span>: <span class="string">"2019-02-03 10:08:02"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，使用@JsonFormat 注释是格式化特定日期字段的绝佳方法。</p>
<p>但是，我们只应在需要字段的特定格式时使用它。如果我们想要在我们的应用程序中使用所有日期的通用格式，那么如何实现这一目标的方式更好，我们稍后会看到。</p>
<h4 id="2-2设置时区"><a href="#2-2设置时区" class="headerlink" title="2.2设置时区"></a>2.2设置时区</h4><p>另外，如果我们需要使用特定的时区，我们可以设置@JsonFormat的timezone属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone=<span class="string">"Europe/Zagreb"</span>)</span><br><span class="line"><span class="keyword">private</span> LocalDateTime lastUpdate;</span><br></pre></td></tr></table></figure>
<p>如果类型已包含时区，则不需要使用它，例如使用 java.time.ZonedDatetime.</p>
<h3 id="3-配置默认格式"><a href="#3-配置默认格式" class="headerlink" title="3. 配置默认格式"></a>3. 配置默认格式</h3><p>虽然@JsonFormat本身很强大，但对格式和时区进行硬编码可能会让我们陷入困境。</p>
<p>如果我们要为应用程序中的所有日期配置默认格式，则更灵活的方法是在application.properties中配置它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.jackson.date-format=yyyy-MM-dd HH:mm:ss</span><br></pre></td></tr></table></figure>
<p>如果我们想在JSON日期中使用特定时区，那么还有一个属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.jackson.time-zone=Europe/Zagreb</span><br></pre></td></tr></table></figure>
<p>尽管设置这样的默认格式非常方便直接，但这种方法存在缺陷。不幸的是，它不适用于Java 8日期类型，如 LocalDate 和 LocalDateTime - 我们只能使用它来格式化java.util.Date或 java.util.Calendar类型的字段 。 但是，我们很快就会看到希望。</p>
<h3 id="4-自定义Jackson的ObjectMapper"><a href="#4-自定义Jackson的ObjectMapper" class="headerlink" title="4. 自定义Jackson的ObjectMapper"></a>4. 自定义Jackson的ObjectMapper</h3><p>因此，如果我们想使用Java 8日期类型 并 设置默认日期格式，那么我们需要查看创建一个 Jackson2ObjectMapperBuilderCustomizer bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactAppConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String dateFormat = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String dateTimeFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title">jsonCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; &#123;</span><br><span class="line">            builder.simpleDateFormat(dateTimeFormat);</span><br><span class="line">            builder.serializers(<span class="keyword">new</span> LocalDateSerializer(DateTimeFormatter.ofPattern(dateFormat)));</span><br><span class="line">            builder.serializers(<span class="keyword">new</span> LocalDateTimeSerializer(DateTimeFormatter.ofPattern(dateTimeFormat)));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例显示了如何在我们的应用程序中配置默认格式。我们必须定义一个bean并覆盖其自定义方法以设置所需的格式。</p>
<p>虽然这种方法可能看起来有点麻烦，但它的优点在于它适用于Java 8和遗留日期类型。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本文中，我们探索了许多在Spring Boot应用程序中格式化JSON日期的方法。</p>
<p>与往常一样，我们可以在GitHub上找到示例的源代码。</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>在Spring中实现类似SpringBoot的环境检测能力</title>
    <url>/2018/12/17/zai-spring-zhong-shi-xian-lei-si-springboot-de-huan-jing-jian-ce-neng-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>​    在<a href="http://km.vivo.xyz/pages/viewpage.action?pageId=38237577" target="_blank" rel="noopener">Boot 你的应用</a>一文中提到了有时候我们需要检测当前时环境是否匹配我们的运行时要求，并根据不同的环境进行个性化的适配。</p>
<p>​    <strong>Spring4</strong>已经引入了简单的扩展接口 <code>@Conditional</code>和<code>Condition</code>，允许大家自行去识别环境信息，但也仅此而已，并没有内置一些可以让大家在实际场景中使用的条件判定器。</p>
<p>​    真正将 <code>@Conditional</code>和<code>Condition</code>发扬光大的是<strong>SpringBoot</strong>，在<strong>SpringBoot</strong>是全面采用了 <code>AutoConfiguration</code>和 <code>@Conditional</code>将自动配置的强大功能展现得淋漓尽致，内置了超过<strong><em>10</em></strong>种不同类型支持超过<strong><em>100</em></strong>种不同场景的环境检测器。比如：检测当前环境中是否存在某个Class，检测当前容器中是否定义了某个SpringBean，检测当前是否有某个配置项，配置项的值是多少等等。所有的环境检测器都在 <code>org.springframework.boot.autoconfigure.condition</code> 下面，大家可以去翻阅源码学习了解。</p>
</blockquote>
<a id="more"></a>
<h3 id="Conditional-与-Condition-介绍"><a href="#Conditional-与-Condition-介绍" class="headerlink" title="@Conditional 与 Condition 介绍"></a>@Conditional 与 Condition 介绍</h3><p>​    前文提到在 Spring 框架中仅仅提供了这两个扩展点，并没有能运用在实际应用场景中的环境检测器，这一节我们将分析这两个接口，并实现一个简单的环境检测功能。</p>
<p>​    以下是<code>@Conditional</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates that a component is only eligible for registration when all</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #value() specified conditions&#125; match.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &lt;em&gt;condition&lt;/em&gt; is any state that can be determined programmatically</span></span><br><span class="line"><span class="comment"> * before the bean definition is due to be registered (see &#123;<span class="doctag">@link</span> Condition&#125; for details).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125; annotation may be used in any of the following ways:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;as a type-level annotation on any class directly or indirectly annotated with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125;, including &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;as a meta-annotation, for the purpose of composing custom stereotype</span></span><br><span class="line"><span class="comment"> * annotations&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;as a method-level annotation on any &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; method&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class is marked with &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125;, all of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods, &#123;<span class="doctag">@link</span> Import <span class="doctag">@Import</span>&#125; and &#123;<span class="doctag">@link</span> ComponentScan <span class="doctag">@ComponentScan</span>&#125;</span></span><br><span class="line"><span class="comment"> * annotations associated with that class will be subject to the conditions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;<span class="doctag">NOTE:</span> &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125; annotations are not inherited; any conditions from</span></span><br><span class="line"><span class="comment"> * superclasses or from overridden methods are not being considered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Condition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * All &#123;<span class="doctag">@link</span> Condition&#125;s that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</span></span><br><span class="line"><span class="comment">	 * in order for the component to be registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这是一个注解，从注释中我们看到这是 <code>@Since 4.0</code> 的，即在 Spring4 开始提供的，用来<strong><em>指定一系列的配置条件</em></strong>，当所有指定的条件都满足时，被 <code>@Configuration</code> 中标注的 <code>@Bean</code>，<code>@Import</code>，<code>@ComponentScan</code>才会生效。</p>
<p>​    它接受一个<code>Condition</code>数组，用来标记所有的筛选条件，当所有的<code>Condition.matches</code>条件均返回<code>true</code>时即可认为该<code>Conditional</code>成立，从而完成环境检测。</p>
<p>​    <code>Condition</code>接口只有一个方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A single &#123;<span class="doctag">@code</span> condition&#125; that must be &#123;<span class="doctag">@linkplain</span> #matches matched&#125; in order</span></span><br><span class="line"><span class="comment"> * for a component to be registered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Conditions are checked immediately before the bean-definition is due to be</span></span><br><span class="line"><span class="comment"> * registered and are free to veto registration based on any criteria that can</span></span><br><span class="line"><span class="comment"> * be determined at that point.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Conditions must follow the same restrictions as &#123;<span class="doctag">@link</span> BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * and take care to never interact with bean instances. For more fine-grained control</span></span><br><span class="line"><span class="comment"> * of conditions that interact with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; beans consider the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurationCondition&#125; interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationCondition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Conditional</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionContext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine if the condition matches.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> metadata metadata of the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> false&#125; to veto registration.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    只需要实现<code>matches</code>方法并根据自己的需要完成环境检测判定即可。</p>
<p>​    </p>
<h3 id="简单用法示例"><a href="#简单用法示例" class="headerlink" title="简单用法示例"></a>简单用法示例</h3><p>​    下面我们用一个小的示例来演示这两个接口的使用方法，假设需求：<strong><em>根据不同的操作系统注册不同的 MXBean 服务</em></strong></p>
<h4 id="1-实现在不同操作系统环境下的条件判定"><a href="#1-实现在不同操作系统环境下的条件判定" class="headerlink" title="1. 实现在不同操作系统环境下的条件判定"></a>1. 实现在不同操作系统环境下的条件判定</h4><p>​    这个过程我们就简化地判定当前的<code>os.name</code>就可以，代码如下：</p>
<p><strong><em>Windows 环境的判定器</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定当前环境是否为 Windows 的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * created on 2018/12/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>Linux 环境的判定器</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定当前环境是否为 Windows 的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * created on 2018/12/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Linux"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-在Bean注册时带上条件注解"><a href="#2-在Bean注册时带上条件注解" class="headerlink" title="2. 在Bean注册时带上条件注解"></a>2. 在Bean注册时带上条件注解</h4><p>​    有了第1步的的条件判定器，那么在我们进行 <code>@Configuraiton</code>的Bean注册时就可以将这些条件附带上，让Spring容器根据不同的条件加载不同的Bean配置。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据不同的操作系统加载不同的 MXBean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * created on 2018/12/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalMXBeanConifg</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(WindowsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">BaseMXBean</span> <span class="title">windowsMXBeanService</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsMXBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">BaseMXBean</span> <span class="title">linuxMXBeanService</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinuxMXBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据以上的配置，在不同的操作系统环境下，Spring会分别注册不同的 MXBean 。</p>
<h3 id="高级用法示例"><a href="#高级用法示例" class="headerlink" title="高级用法示例"></a>高级用法示例</h3><p>​    在简单用法示例中我们可以看到，虽然实现了不同环境下的判定识别，但还是太简单了，还是比较静态的，如果我们要像<strong>SpringBoot</strong>那样动态的判定当前环境中是否存在某个类，Spring容器中是否存在某个Bean定义该怎么做呢？下面我们将演示这几种更高级的用法。</p>
<h4 id="判定当前-classpath-下是否存在某个类"><a href="#判定当前-classpath-下是否存在某个类" class="headerlink" title="判定当前 classpath 下是否存在某个类"></a>判定当前 classpath 下是否存在某个类</h4><p>​    这类条件判定器主要用在一些模板类SDK中，根据当前用户是否依赖了某些类来确定是否要定义相应的模板、工具、服务等。如同<a href="http://km.vivo.xyz/pages/viewpage.action?pageId=38239820" target="_blank" rel="noopener">应用分发 base-boot-starter 的使用说明</a>中对于 OA 权限平台的判定一样，当用户没有添加OA权限平台这个MAVEN依赖时，应用仍然能智能判定而不是抛出 <code>NoClassDefFoundError</code>。</p>
<ol>
<li><p>首先定义一个自定义的注解，供用户使用判定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否存在某个类的条件判定注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Time: 2018/12/7 : 19:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(OnClassCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">ConditionalOnClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须存在的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 必须存在的类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须存在的类名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 必须存在的类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当用户在注解某个<code>@Bean</code>进，可以添加这个注解来进行判定。这个注解本身还依赖另外一个注解<code>@Conditional(OnClassCondition.class)</code>，表示扫Spring容器在扫描到某个类定义被标注了<code>@ConditionalOnClass</code>时，会执行里面的<code>OnClassCondition</code>来完成条件判定。</p>
<ol start="2">
<li><p>定义真正的条件判定器 <code>OnClassCondition</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定某个类是否存在的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Time: 2018/12/7 : 19:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnClassCondition</span> <span class="keyword">extends</span> <span class="title">BaseCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; attributes = metadata</span><br><span class="line">                .getAllAnnotationAttributes(ConditionalOnClass<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == attributes) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addAll(candidates, attributes.get(<span class="string">"value"</span>));</span><br><span class="line">        addAll(candidates, attributes.get(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String candidate : candidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ClassUtils.isPresent(candidate, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也很简单，就是从注解中获取当前用户要判定是否存在的Class（支持类定义，和全类名），然后在当前 classpath 下去查找这个类是否存在即完成判定过程。</p>
</li>
<li><p>使用自定义的注解</p>
<p>使用起来就比较简单了，加上注解即可，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(SSOFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SsoAutoConfiguration</span> </span>&#123;...｝</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="判定当前Spring容器中是否定义了某个Bean"><a href="#判定当前Spring容器中是否定义了某个Bean" class="headerlink" title="判定当前Spring容器中是否定义了某个Bean"></a>判定当前Spring容器中是否定义了某个Bean</h4><p>​    这类判定主要用在如下的场景：某些组件需要依赖某个SpringBean，如果当前Spring容器中不存在这个Bean，那么就要添加一个，如果存在就不能再添加，防止产生<code>NoSuchBeanDefinitionException</code>或者<code>NoUniqueBeanDefinitionException</code>异常。</p>
<p>​    其实现过程其实和<code>@ConditionalOnClass</code>大同小异，最主要的区别在于<code>Condition.matches</code>方法一个是判定类是否存在，一个是判定Bean是否存在。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判定某个 bean 是否存在的条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * Time: 2018/12/7 : 19:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnBeanCondition</span> <span class="keyword">extends</span> <span class="title">BaseCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; conditionOnBeanAttrs = metadata</span><br><span class="line">                .getAllAnnotationAttributes(ConditionalOnBean<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != conditionOnBeanAttrs) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchBean(context, conditionOnBeanAttrs, metadata);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; conditionOnMissingBeanAttrs = metadata</span><br><span class="line">                .getAllAnnotationAttributes(ConditionalOnMissingBean<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (conditionOnMissingBeanAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchMissingBean(context, conditionOnMissingBeanAttrs, metadata);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchBean</span><span class="params">(ConditionContext context, MultiValueMap&lt;String, Object&gt; attributes, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (attributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; classNameCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addAll(classNameCandidates, attributes.get(<span class="string">"value"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String clsName : classNameCandidates) &#123;</span><br><span class="line">                beanFactory.getBean(Class.forName(clsName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.debug(<span class="string">"没有找到需要的 Bean: &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; beanNameCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addAll(beanNameCandidates, attributes.get(<span class="string">"name"</span>));</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNameCandidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beanFactory.containsBean(beanName)) &#123;</span><br><span class="line">                log.debug(<span class="string">"没有找到需要的 bean: &#123;&#125;"</span>, beanName);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchMissingBean</span><span class="params">(ConditionContext context, MultiValueMap&lt;String, Object&gt; attributes, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 和 matchBean 相反，判定是否不存在某个 Bean，省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文主要讲解了如何通过<code>@Conditional</code>和<code>Condition</code>实现环境检测的能力，并从源码及示例两方面演示了从简单到高级的用法支持。其它的诸如判定当时配置项中的值以及资源判定的实现原理都差不多，感兴趣的可以翻阅应用分发 <code>base-boot-starter</code> 的源码。</p>
<blockquote>
<p>当然，这里高级应用里面的判定规则并不如SpringBoot中的功能强大，但应付常规的应用已经足够，当不满足需求时，通过本文的讲解读者应该也已经了解到了如何自行扩展，或者<a href="mailto:huangfengjing@gmail.com" target="_blank" rel="noopener">联系我</a>协助。</p>
</blockquote>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>在Spring中使用Quartz调度器</title>
    <url>/2008/03/24/zai-spring-zhong-shi-yong-quartz-diao-du-qi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Quartz调度器为调度工作提供了更丰富的支持。和Java定时器一样，可以使用Quartz来每隔多少毫秒执行一个工作。但Quartz比Java Timer更先进之处在于它允许你调度一个工作在某个特定的时间或日期执行。<br>关于Quartz的更多信息，可以访问Quartz位于<a href="http://www.opensymphony.com/quartz" target="_blank" rel="noopener">http://www.opensymphony.com/quartz</a>的主页。<br>让我们从定义发送报表邮件的工作开始使用Quartz： </p>
<a id="more"></a>
<h4 id="创建一个工作"><a href="#创建一个工作" class="headerlink" title="创建一个工作"></a>创建一个工作</h4><p>定义Quartz工作的第一步是创建一个类来定义工作。要做到这一点，你需要从Spring的QuartzJobBean中派生子类，如以下程序所示： </p>
<p>程序：定义一个Quartz工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailReportJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailReportJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        courseService.sendCourseEnrollmentReport();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CourseService courseService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseService</span><span class="params">(CourseService courseService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseService = courseService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QuartzJobBean是Quartz中与Java的TimerTask等价的类。它实现了org.quartz.Job接口。executeInternal()方法定义了当预定的时刻来临时应该执行哪些动作。在这里，正如EmailReportTask，你只是简单地调用了courseService属性的sendCourseEnrollmentReport()方法。 </p>
<p>在Spring配置文件中按以下方式声明这个工作：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"reportJob"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.JobDetailBean"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobClass"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">value</span>&gt;</span>com.springinaction.training.schedule.EmailReportJob<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDataAsMap"</span>&gt;</span></span><br><span class="line">　　　　　　　<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">　　　　　　　　　　　<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"courseService"</span>&gt;</span></span><br><span class="line">　　　　　　　　　　　　　　　<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"courseService"</span>/&gt;</span></span><br><span class="line">　　　　　　　　　　　<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">　　　　　　　<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，在这里你并没有直接声明一个EmailReportJob Bean，而是声明了一个JobDetailBean。这是使用Quartz时的一个特点。JobDetailBean是Quartz的org.quartz.JobDetail的子类，它要求通过jobClass属性来设置一个Job对象。 </p>
<p>使用Quartz的JobDetail中的另一个特别之处是EmailReportJob的courseService属性是间接设置的。JobDetail的jobDataAsMap属性接受一个java.util.Map，其中包含了需要设置给jobClass的各种属性。在这里，这个map包含了一个指向courseService Bean的引用，它的键值为courseService。当JobDetailBean实例化时，它会将courseService Bean注入到EmailReportJob的courseService属性中。 </p>
<h4 id="调度工作"><a href="#调度工作" class="headerlink" title="调度工作"></a>调度工作</h4><p>现在工作已经被定义好了，接下来你需要调度这个工作。Quartz的org.quartz.Trigger类描述了何时及以怎样的频度运行一个Quartz工作。Spring提供了两个触发器，SimpleTriggerBean和CronTriggerBean。你应该使用哪个触发器？让我们分别考察一下这两个触发器，首先从SimpleTriggerBean开始。 </p>
<p>SimpleTriggerBean与ScheduledTimerTask类似。你可以用它来指定一个工作应该以怎样的频度运行，以及（可选地）在第一次运行工作之前应该等待多久。例如，要调度报表工作每24小时运行一次，第一次在1小时之后开始运行，可以按照以下方式进行声明： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleReportTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SimpleTriggerBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"reportJob"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startDelay"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3600000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"repeatInterval"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>86400000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性jobDetail装配了将要被调度的工作，在这个例子中是reportJob Bean。属性repeatInterval告诉触发器以怎样的频度运行这个工作（以毫秒作为单位）。这里，我们设置它为86400000，因此每隔24小时它会被触发一次。你也可以选择设置startDelay属性来延迟工作的第一次执行。我们设置它为3600000，因此在第一次触发之前它会等待1小时。 </p>
<h4 id="调度一个cron工作"><a href="#调度一个cron工作" class="headerlink" title="调度一个cron工作"></a>调度一个cron工作</h4><p>尽管你可能认为SimpleTriggerBean适用于大多数应用，但它仍然不能满足发送注册报表邮件的需求。正如ScheduledTimerTask，你只能指定工作执行的频度，而不能准确指定它于何时运行。因此，你无法使用SimpleTriggerBean在每天早晨6:00给课程主任发送注册报表邮件。 </p>
<p>然而，CronTriggerBean允许你更精确地控制任务的运行时间。如果你对Unix的cron工具很熟悉，则会觉得CronTriggerBean很亲切。你不是定义工作的执行频度，而是指定工作的准确运行时间（和日期）。例如，要在每天早上6:00运行报表工作，可以按照以下方式声明一个CronTriggerBean： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cronReportTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"reportJob"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cronExpression"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>0 0 6 * * ?<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和SimpleTriggerBean一样，jobDetail属性告诉触发器调度哪个工作。这里我们又一次装配了一个reportJob Bean。属性cronExpression告诉触发器何时触发。如果你不熟悉cron，这个属性可能看上去有点神秘，因此让我们进一步考察一下这个属性。 </p>
<p>一个cron表达式有至少6个（也可能是7个）由空格分隔的时间元素。从左至右，这些元素的定义如下： </p>
<ol>
<li>秒（0–59）</li>
<li>分钟（0–59） </li>
<li>小时（0–23） </li>
<li>月份中的日期（1–31） </li>
<li>月份（1–12或JAN–DEC） </li>
<li>星期中的日期（1–7或SUN–SAT） </li>
<li>年份（1970–2099） </li>
</ol>
<p>每一个元素都可以显式地规定一个值（如6），一个区间（如9-12），一个列表（如9，11，13）或一个通配符（如*）。“月份中的日期”和“星期中的日期”这两个元素是互斥的，因此应该通过设置一个问号（？）来表明你不想设置的那个字段。下表中显示了一些cron表达式的例子和它们的意义： </p>
<table>
<thead>
<tr>
<th>表   达   式</th>
<th>意     义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 10,14,16 <em> </em> ?</td>
<td>每天上午10点，下午2点和下午4点</td>
</tr>
<tr>
<td>0 0,15,30,45 <em> 1-10 </em> ?</td>
<td>每月前10天每隔15分钟</td>
</tr>
<tr>
<td>30 0 0 1 1 ? 2012</td>
<td>在2012年1月1日午夜过30秒时</td>
</tr>
<tr>
<td>0 0 8-5 ? * MON-FRI</td>
<td>每个工作日的工作时间</td>
</tr>
</tbody>
</table>
<p>对于cronReportTrigger，我们设置cronExpression为<code>0 0 6 * * ?</code>可以把它读作“在任何月份任何日期（不管是星期几）的6时0分0秒执行触发器。”换句话说，这个触发器会在每天早晨6:00执行。<br>使用CronTriggerBean完全能够满足课程主任的期望了。现在剩下要做的只是启动这个工作了。 </p>
<h4 id="启动工作"><a href="#启动工作" class="headerlink" title="启动工作"></a>启动工作</h4><p>Spring的SchedulerFactoryBean是Quartz中与TimerFactoryBean等价的类。按照如下方式在Spring配置文件中声明它：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"triggers"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"cronReportTrigger"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性triggers接受一组触发器。由于目前只有一个触发器，因此只需简单地装配一个包含cronReportTrigger Bean的一个引用的列表即可。 </p>
<p>现在，你已经实现了调度发送注册报表邮件的需求。但在这个过程中，你做了一些额外的工作。在开始新的话题之前，首先让我们看一下如何通过更简单一些的方式调度报表邮件。</p>
]]></content>
      <tags>
        <tag>任务调度</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读与定制化</title>
    <url>/2018/12/20/ding-zhi-hua-de-le-qu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>SpringFramework</code>，<code>Acegi(SpringSecurity)</code>，<code>Tomcat</code>，<code>SpringBoot</code>，<code>SpringCloud(部分)</code>, <code>Jetty</code>，<code>Velocity</code>，<code>MyBatis/Generator</code>，<code>Quercus(PHP in Java)</code>，<code>Guava</code>，<code>Android(UI部分)</code></p>
<h3 id="源码阅读的目的"><a href="#源码阅读的目的" class="headerlink" title="源码阅读的目的"></a>源码阅读的目的</h3><ol>
<li>分析与解决 BUG（Quercus）</li>
<li>寻找隐藏的交互方式（Spring）</li>
<li>弥补文档的不完善性（非著名项目）</li>
<li>扩展与定制（Velocity，MyBatis/Generator等）</li>
<li>安全性检查（Quercus）</li>
<li>学习（Spring, Tomcat, Android-UI）</li>
</ol>
<a id="more"></a>
<h3 id="源码阅读的方式"><a href="#源码阅读的方式" class="headerlink" title="源码阅读的方式"></a>源码阅读的方式</h3><ol>
<li>确定目标对象（建立自信 OR 被打击自信）</li>
<li>分析主脉络</li>
<li>分步调试</li>
<li>从抽象到具体</li>
</ol>
<h3 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h3><ol>
<li><p>Ali-Tomcat</p>
<p> 对 Tomcat 的增加，比如对于ClasaLoader并行加载的补丁<code>ClassLoader.registerAsParallelCapable</code>，并合入Tomcat7.0.65。另外就是对于HSF（High-Speed Service Framework）的支持。</p>
</li>
<li><p>Ali-JVM</p>
</li>
<li><p>PHP Support in Java</p>
</li>
<li><p>更全面的代码生成器</p>
</li>
<li><p>SpringBoot之兼容Velocity</p>
</li>
<li><p>权限平台的Boot化</p>
</li>
</ol>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>Tomcat -&gt; 容器组件构架模型，生命周期管理与事件处理模型，以及 Pipeline 模型</p>
<p>Quercus, Binlog -&gt; 协议的理解与实现</p>
<p>Android -&gt; 分而治之与事件管理</p>
<p>Spring全家桶 -&gt; 几乎囊括了所有的设计模式和架构模型</p>
<p>Tomcat 生命周期管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">           start()</span><br><span class="line"> -----------------------------</span><br><span class="line"> |                           |</span><br><span class="line"> | init()                    |</span><br><span class="line">NEW -»-- INITIALIZING        |</span><br><span class="line">| |           |              |     ------------------«-----------------------</span><br><span class="line">| |           |auto          |     |                                        |</span><br><span class="line">| |          \|/    start() \|/   \|/     auto          auto         stop() |</span><br><span class="line">| |      INITIALIZED --»-- STARTING_PREP --»- STARTING --»- STARTED --»---  |</span><br><span class="line">| |         |                                                            |  |</span><br><span class="line">| |destroy()|                                                            |  |</span><br><span class="line">| --»-----«--    ------------------------«--------------------------------  ^</span><br><span class="line">|     |          |                                                          |</span><br><span class="line">|     |         \|/          auto                 auto              start() |</span><br><span class="line">|     |     STOPPING_PREP ----»---- STOPPING ------»----- STOPPED -----»-----</span><br><span class="line">|    \|/                               ^                     |  ^</span><br><span class="line">|     |               stop()           |                     |  |</span><br><span class="line">|     |       --------------------------                     |  |</span><br><span class="line">|     |       |                                              |  |</span><br><span class="line">|     |       |    destroy()                       destroy() |  |</span><br><span class="line">|     |    FAILED ----»------ DESTROYING ---«-----------------  |</span><br><span class="line">|     |                        ^     |                          |</span><br><span class="line">|     |     destroy()          |     |auto                      |</span><br><span class="line">|     --------»-----------------    \|/                         |</span><br><span class="line">|                                 DESTROYED                     |</span><br><span class="line">|                                                               |</span><br><span class="line">|                            stop()                             |</span><br><span class="line">----»-----------------------------»------------------------------</span><br></pre></td></tr></table></figure>
<p><img src="E:\分享与培训\Java编译模型.png" alt="Java编译模型"></p>
]]></content>
      <tags>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤（Bloom Filter）</title>
    <url>/2018/03/21/bu-long-guo-lu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either “possibly in set” or “definitely not in set”. —— From wikipedia.</p>
</blockquote>
<a id="more"></a>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>数据字典</li>
<li>进行数据的判重</li>
<li>黑名单</li>
<li>CDN（squid）代理缓存技术</li>
</ol>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Bloom Filter是一种空间效率极高的随机数据结构，它的原理是：当一个元素被加入集合时，通过 K 个Hash函数将这个元素映射成一个位阵列（Bit array）中的 K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检索元素一定不在；如果都是1，则被检索元素很可能在。</p>
<p><strong>重点：牺牲一定的准确率换取非常高的空间利用率</strong></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（O(k)）。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>
<p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</p>
<p>另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p>
<p>在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p>
<h3 id="Java-实现（Guava）"><a href="#Java-实现（Guava）" class="headerlink" title="Java 实现（Guava）"></a>Java 实现（Guava）</h3><p>Google Guava 库在第 <strong>v11.0</strong> 版本加入了 <strong>Bloom Filter</strong> 的实现，常用 API 介绍如下：</p>
<ol>
<li>Bloom Filter 构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> funnel 			漏斗模型，用于添加要检测的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedInsertions   预期要检测的数据总量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fpp                  误报率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>                     Bloom Filter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这是全参数的构造器，还有几个重载的构造函数（可以不指定误报率，默认为 3%）</p>
<blockquote>
<p><strong>注意事项</strong>  ：正确估计预期插入数量是很关键的一个参数，当插入的数量接近或高于预期值的时候，布隆过滤器将会填满，这样的话，它会产生很多无用的误报点。</p>
</blockquote>
<ol start="2">
<li>检测内容是否存在</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测数据是否存在</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object  要检测的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>        是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意事项</strong> ：当返回不存在时，一定不存在，但返回存在时，则有可能存在，误报率在构造器中已经说明</p>
</blockquote>
<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><blockquote>
<p><strong>需求</strong> ：给10亿用户每人发送一条消息</p>
</blockquote>
<h4 id="方案一：在内存中记录用户消息发送的状态"><a href="#方案一：在内存中记录用户消息发送的状态" class="headerlink" title="方案一：在内存中记录用户消息发送的状态"></a>方案一：在内存中记录用户消息发送的状态</h4><ul>
<li>详细描述：在内存设计一个缓存，地将所有的用户 <strong>已</strong> 发送状态放入缓存中，当下一个用户过来时，校验缓存中是否已经存在。</li>
<li>优点：实现方式逻辑简单；</li>
<li>缺点：按 UTF-8 编码，用户标识符 10 个字符（10个字节） <em> 10亿 = 10 </em> 10^9 ~= 10 G，基本超出常用的 JVM 内存；</li>
</ul>
<h4 id="方案二：将10亿用户号码存到数据库中，并标记发送状态"><a href="#方案二：将10亿用户号码存到数据库中，并标记发送状态" class="headerlink" title="方案二：将10亿用户号码存到数据库中，并标记发送状态"></a>方案二：将10亿用户号码存到数据库中，并标记发送状态</h4><ul>
<li>详细描述：设计数据库表记录各个用户的发送状态；</li>
<li>优点：无内存问题，逻辑简单；</li>
<li>缺点：10 亿级的数据记录存储本身的架构设计、高性能查询就是一个需要解决的很复杂的难题。</li>
</ul>
<h4 id="方案三：利用分布式缓存存储用户消息发送状态"><a href="#方案三：利用分布式缓存存储用户消息发送状态" class="headerlink" title="方案三：利用分布式缓存存储用户消息发送状态"></a>方案三：利用分布式缓存存储用户消息发送状态</h4><ul>
<li><p>详细描述：通过分布式 K-V 数据库（Redis）记录用户的发送状态；</p>
</li>
<li><p>优点：无内存问题，逻辑相对简单；</p>
</li>
<li>缺点：每条记录都需要跟缓存服务交互 2 次，存在分布式网络延迟；</li>
</ul>
<h4 id="方案四：Bloom-Filter-分布式缓存"><a href="#方案四：Bloom-Filter-分布式缓存" class="headerlink" title="方案四：Bloom Filter + 分布式缓存"></a>方案四：Bloom Filter + 分布式缓存</h4><ul>
<li>详细描述：本地将所有的用户 <strong>已</strong> 发送状态放入 Bloom Filter 中（<strong>以及分布式缓存中</strong>），当下一个用户过来时，先在 Bloom Filter 中查询状态。如果不存在，则 <strong>一定</strong> 未发送，执行发送逻辑；如果存在，则 <strong>不一定</strong> 发送过，则去分布式缓存中进行二次确认，确认之前的 <strong>不一定</strong> 状态；</li>
<li>优点：无内存问题，绝大部分校验过程在本地完成，只有极少部分（<strong>来源于之前介绍的 Bloom Filter 的误差</strong>）会去分布式缓存进行二次校验，无网络延迟问题；</li>
<li>缺点：逻辑上会相对复杂一些；</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bloom_filter</a></li>
<li><a href="https://blog.csdn.net/v_JULY_v/article/details/6685894" target="_blank" rel="noopener">海量数据处理之Bloom Filter详解</a></li>
</ol>
]]></content>
      <tags>
        <tag>大数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>哪些散落的名句</title>
    <url>/2014/04/16/na-xie-san-luo-de-ming-ju/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>总有些名句散落在我们的脑海里，只知其一不知其二</p>
<p><strong>《集杭州俗语诗》</strong></p>
<blockquote>
<p>清·黄增</p>
</blockquote>
<p>色不迷人人自迷，情人眼里出西施。</p>
<p><strong>有缘千里来相会</strong>，三笑徒然当一痴。<br><a id="more"></a></p>
<p><strong>《夜坐》其二</strong></p>
<blockquote>
<p>清·龚自珍</p>
</blockquote>
<p>沉沉心事北南东，一睨人材海内空。</p>
<p>壮岁始参周史席，髫年惜堕晋贤风。</p>
<p>功高拜将成仙外，才尽回肠荡气中。</p>
<p>万一禅关砉然破，<strong>美人如玉剑如虹</strong>。</p>
<p><strong>《春 宵》</strong></p>
<blockquote>
<p>宋·苏轼</p>
</blockquote>
<p><strong>春宵一刻值千金</strong>，花有清香月有阴。</p>
<p>歌管楼台声细细，秋千院落夜沉沉。</p>
<p><strong>《白鹿洞》其一</strong></p>
<blockquote>
<p>唐·王贞白</p>
</blockquote>
<p>读书不觉已春深，<strong>一寸光阴一寸金</strong>。</p>
<p>不是道人来引笑，周情孔思正追寻。</p>
<p><strong>《自 遣》</strong></p>
<blockquote>
<p>唐·罗隐</p>
</blockquote>
<p>得即高歌失即休，多愁多恨亦悠悠。</p>
<p><strong>今朝有酒今朝醉</strong>，明日愁来明日愁。</p>
<p><strong>《题桃花扇》</strong></p>
<blockquote>
<p>清·陈于王</p>
</blockquote>
<p>玉树歌残迹已陈，南朝宫殿柳条新。</p>
<p>福王少小风流惯，<strong>不爱江山爱美人</strong>。</p>
<p><strong>《杂 感》</strong></p>
<blockquote>
<p>清·黄景仁</p>
</blockquote>
<p>仙佛茫茫两未成，只知独夜不平鸣。</p>
<p>风蓬飘尽悲歌气，泥絮沾来薄幸名。</p>
<p>十有九人堪白眼，<strong>百无一用是书生</strong>。</p>
<p>莫因诗卷愁成谶，春鸟秋虫自作声。</p>
<p><strong>《励学篇》</strong></p>
<blockquote>
<p>宋·赵恒</p>
</blockquote>
<p>富家不用买良田，书中自有千钟粟。</p>
<p>安居不用架高堂，<strong>书中自有黄金屋</strong>。</p>
<p>出门莫恨无人随，书中车马多如簇。</p>
<p>娶妻莫恨无良媒，<strong>书中自有颜如玉</strong>。</p>
<p>男儿欲遂平生志，六经勤向窗前读。</p>
<p><strong>《自 嘲》</strong></p>
<blockquote>
<p>宋·陶谷</p>
</blockquote>
<p>官职须由生处有，才能不管用时无。</p>
<p>堪笑翰林陶学士，<strong>年年依样画葫芦</strong>。</p>
<p><strong>《不第后赋菊》</strong></p>
<blockquote>
<p>唐·黄巢</p>
</blockquote>
<p>待到秋来九月八，我花开后百花杀。</p>
<p>冲天香阵透长安，<strong>满城尽带黄金甲</strong>。</p>
<p><strong>《赠去婢》</strong></p>
<blockquote>
<p>唐·崔郊</p>
</blockquote>
<p>公子王孙逐后尘，绿珠垂泪滴罗巾。</p>
<p><strong>侯门一入深如海</strong>，<strong>从此萧郎是路人</strong>。</p>
<p><strong>《绝 句》</strong></p>
<blockquote>
<p>宋·夏元鼎</p>
</blockquote>
<p>崆峒访道至湘湖，万卷诗书看转愚。</p>
<p><strong>踏破铁鞋无觅处</strong>，<strong>得来全不费工夫</strong>。</p>
<p><strong>《登乐游原》</strong></p>
<blockquote>
<p>唐·李商隐</p>
</blockquote>
<p>向晚意不适，驱车登古原。</p>
<p><strong>夕阳无限好</strong>，<strong>只是近黄昏</strong>。</p>
<p><strong>《已亥岁》</strong></p>
<blockquote>
<p>唐·曹松</p>
</blockquote>
<p>泽国江山入战图，生民何计乐樵苏。</p>
<p>凭君莫话封侯事，<strong>一将功成万骨枯</strong>。</p>
<p>传闻一战百神愁，两岸强兵过未休。</p>
<p>谁道沧江总无事，近来长共血争流。</p>
<p><strong>《入 京》</strong></p>
<blockquote>
<p>明·于谦</p>
</blockquote>
<p>绢帕蘑菇与线香，本资民用反为殃。</p>
<p><strong>清风两袖朝天去</strong>，免得闾阎话短长。</p>
<p><strong>《戏张先》</strong></p>
<blockquote>
<p>宋·苏轼</p>
</blockquote>
<p>十八新娘八十郎，苍苍白发对红妆。</p>
<p>鸳鸯被里成双夜，<strong>一树梨花压海棠</strong>。</p>
<p><strong>《书扇示门人》</strong></p>
<blockquote>
<p>宋·范仲淹</p>
</blockquote>
<p>一派青山景色幽，<strong>前人田地后人收</strong>。</p>
<p>后人收得休欢喜，还有收人在后头。</p>
<p><strong>《竹枝词》其一</strong></p>
<blockquote>
<p>唐·刘禹锡</p>
</blockquote>
<p>杨柳青青江水平，闻郎江上踏歌声。</p>
<p><strong>东边日出西边雨，道是无晴却有晴。</strong></p>
<p><strong>《上堂开示颂》</strong></p>
<blockquote>
<p>唐·黄櫱禅师</p>
</blockquote>
<p>尘劳迥脱事非常，紧把绳头做一场。</p>
<p><strong>不经一番寒彻骨</strong>，<strong>怎得梅花扑鼻香</strong>。</p>
<p><strong>《登科后》</strong></p>
<blockquote>
<p>唐·孟郊</p>
</blockquote>
<p>昔日龌龊不足夸，今朝放荡思无涯。</p>
<p><strong>春风得意马蹄疾</strong>，<strong>一日看尽长安花</strong>。</p>
]]></content>
      <categories>
        <category>诗词鉴赏</category>
      </categories>
      <tags>
        <tag>诗词鉴赏</tag>
        <tag>名句赏析</tag>
      </tags>
  </entry>
  <entry>
    <title>在Spring中使用 Java Timer 调度任务 </title>
    <url>/2008/03/21/zai-spring-zhong-shi-yong-java-timer-diao-du-ren-wu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从Java 1.3开始，Java SDK就通过<code>java.util.Timer</code>类提供了基本的调度功能。这个类允许你调度一个任务（通过<code>java.util.TimerTask</code>子类定义）按任意周期运行。 </p>
<a id="more"></a>
<h4 id="创建一个定时器任务"><a href="#创建一个定时器任务" class="headerlink" title="创建一个定时器任务"></a>创建一个定时器任务</h4><p>使用Java Timer来调度发送注册报表邮件的第一步是从java.util.TimerTask中派生出邮件任务，如以下程序所示。 </p>
<p>程序：一个用于发送注册报表邮件的定时器任务 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailReportTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailReportTask</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        courseService.sendCourseEnrollmentReport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> CourseService courseService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseService</span><span class="params">(CourseService courseService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseService = courseService; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run()方法定义了当任务运行时该做什么。在上面的例子中，它调用CourseService的sendCourseEnrollmentReport()方法（见程序清单7.1）来发送注册报表邮件。CourseService是通过依赖注入方式提供给EmailReportTask的。<br>按以下方式在Spring配置文件中声明EmailReportTask：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"reportTimerTask"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.training.schedule.EmailReportTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"courseService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"courseService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个声明本身只是将EmailReportTask放到应用上下文中，并在courseService属性中装配courseService Bean。在你调度它之前，它不会做任何有用的事。 </p>
<h4 id="调度定时器任务"><a href="#调度定时器任务" class="headerlink" title="调度定时器任务"></a>调度定时器任务</h4><p>Spring的ScheduledTimerTask定义了一个定时器任务的运行周期。既然课程主任要求每天向她发送注册报表，你应该以如下方式装配一个ScheduledTimerTask： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"scheduledReportTask"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.timer.ScheduledTimerTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timerTask"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"reportTimerTask"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"period"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>86400000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性timerTask告诉ScheduledTimerTask运行哪个TimerTask。在这里，该属性装配了指向reportTimerTask的一个引用，它就是EmailReportTask。属性period告诉ScheduledTimerTask以怎样的频度调用TimerTask的run()方法。这个属性以毫秒作为单位，它被设置为86400000，指定这个任务应该每24小时运行一次。 </p>
<h4 id="启动定时器"><a href="#启动定时器" class="headerlink" title="启动定时器"></a>启动定时器</h4><p>最后一步是启动定时器。Spring的TimerFactoryBean负责启动定时任务。按以下方式在Spring配置文件中声明它： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.timer.TimerFactoryBean"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scheduledTimerTasks"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"scheduledReportTask"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性scheduledTimerTasks要求一个需要启动的定时器任务的列表。既然你现在只有一个定时器任务，这个列表中只包含一个指向scheduledReportTask Bean的引用。 </p>
<p>遗憾的是，即使这个任务已经能够每隔24小时运行一次了，在这里你无法指定它应该在一天中的哪个时间点执行。ScheduledTimerTask有一个delay属性，允许你指定当任务第一次运行之前应该等待多久。例如，要将EmailReportTask的第一次运行延迟1小时，可以按照以下方式进行配置： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.timer.TimerFactoryBean"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"scheduledTimerTasks"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"scheduledReportTask"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- delay 属性指定其间隔时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"delay"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3600000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使使用deplay属性，EmailReportTask的第一次运行时间仍然是相对于应用程序的启动时间的。怎样才能做到如课程主任所要求的在每天早晨6:00发送邮件（而不是在早晨5:00启动应用程序）呢？ </p>
<p>遗憾的是，这是Java Timer的一个局限性。你可以指定任务执行的频度，但你无法精确指定它何时运行。为了能够精确指定何时发送电子邮件，你需要使用Quartz调度器。</p>
]]></content>
      <tags>
        <tag>JavaTimer</tag>
        <tag>定时调度</tag>
      </tags>
  </entry>
  <entry>
    <title>基于约定的Spring MVC扩展</title>
    <url>/2009/11/11/ji-yu-yue-ding-de-spring-mvc-kuo-zhan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>闲来无事翻了下以前写的项目，发现一个还算不错的东西，就是基于约定的Spring MVC扩展，这段代码是好早以前的东西了（大概四五年了吧），那个时候Spring还远没有现在这么“强大”，哦不，应该说是杂，现在的Spring似乎无所不能，却再也不那么专注了，基于让我有点怀念Spring1.X时代了。</p>
<p>这个扩展是当时没有Annotation时代，为了解决XML配置文件膨胀而产生的，原理很简单，就是依据请求的urlPath，动态的解析到所对应的处理类，然后实例化处理类，注入所需要的依赖，再执行。帖出来怀念一下。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.webtemplate.spring.mvc;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryUtils;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.multiaction.InternalPathMethodNameResolver;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.multiaction.MethodNameResolver;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.multiaction.MultiActionController;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> cn.edu.ccnu.inc.webtemplate.cache.SystemCacheManager;  </span><br><span class="line"><span class="keyword">import</span> cn.edu.ccnu.inc.webtemplate.util.ClassUtils;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Convention based url handler mapping, to find a handle class based on the url hierarchy if no </span></span><br><span class="line"><span class="comment"> * handler found with the mapping-configuration. </span></span><br><span class="line"><span class="comment"> * Example: </span></span><br><span class="line"><span class="comment"> * &amp;lt;bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&amp;gt; </span></span><br><span class="line"><span class="comment"> *      &amp;lt;property name="defaultHandler"&amp;gt; </span></span><br><span class="line"><span class="comment"> *           &amp;lt;!-- It also could configure a reference to an exist handler --&amp;gt; </span></span><br><span class="line"><span class="comment"> *          &amp;lt;bean class="org.springframework.web.servlet.mvc.UrlFilenameViewController" /&amp;gt; </span></span><br><span class="line"><span class="comment"> *      &amp;lt;/property&amp;gt; </span></span><br><span class="line"><span class="comment"> *      &amp;lt;property name="packages"&amp;gt; </span></span><br><span class="line"><span class="comment"> *              &amp;lt;value&amp;gt;cn.edu.ccnu.inc.webtemplate.controller, cn.edu.ccnu.inc.webtemplate.spring.controller&amp;lt;/value&amp;gt; </span></span><br><span class="line"><span class="comment"> *      &amp;lt;/property&amp;gt; </span></span><br><span class="line"><span class="comment"> *      &amp;lt;property name="mappings"&amp;gt; </span></span><br><span class="line"><span class="comment"> *          &amp;lt;value&amp;gt; </span></span><br><span class="line"><span class="comment"> *              /login.html = filenameController </span></span><br><span class="line"><span class="comment"> *              /index.html = filenameController </span></span><br><span class="line"><span class="comment"> *              /main.html = filenameController </span></span><br><span class="line"><span class="comment"> *              /security/userManage.html = filenameController </span></span><br><span class="line"><span class="comment"> *              /security/roleManage.html = filenameController </span></span><br><span class="line"><span class="comment"> *          &amp;lt;/value&amp;gt; </span></span><br><span class="line"><span class="comment"> *      &amp;lt;/property&amp;gt; </span></span><br><span class="line"><span class="comment"> * &amp;lt;/bean&amp;gt; </span></span><br><span class="line"><span class="comment"> * the path "/security/methodPrivilegeManage.html" doesn't match any item of above, so it will be mapped </span></span><br><span class="line"><span class="comment"> * to the security.UserManager class under the package cn.edu.ccnu.inc.webtemplate.controller or under </span></span><br><span class="line"><span class="comment"> * cn.edu.ccnu.inc.webtemplate.spring.controller package to handle. When no controller found with this strategy, </span></span><br><span class="line"><span class="comment"> * a defaultHandler will be used if it is configured(eg.. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt; </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> 2005-10-29 下午12:41:30 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConventionBasedUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">SimpleUrlHandlerMapping</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    SystemCacheManager systemCacheManager = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">private</span> String CACHE_NAME_IN_SYSTEM = <span class="string">"_system_cache_handler"</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** Default handler when no handler mapped */</span>  </span><br><span class="line">    <span class="keyword">private</span> Object defaultHandler;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Packages to look for the Handler class */</span>   </span><br><span class="line">    <span class="keyword">private</span> String packages;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Config the packages </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packages </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPackages</span><span class="params">(String packages)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.packages = packages;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultHandler the defaultHandler to set </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultHandler</span><span class="params">(Object defaultHandler)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.defaultHandler = defaultHandler;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Override the default lookup strategy, when the parent can not find an appropriate one to handle. </span></span><br><span class="line"><span class="comment">     * Lookup strategy: </span></span><br><span class="line"><span class="comment">     * 1. ask parent mapping to look up handler. </span></span><br><span class="line"><span class="comment">     * 2. if no handler found, then use url hierarchy build a short name to retrieve the bean as the handler. </span></span><br><span class="line"><span class="comment">     * 3. if still no handler found, assemble a full class name with package and url hierarchy, then load and </span></span><br><span class="line"><span class="comment">     *    initiate a class with reflection, inject all needed properties, finally use this object as the handler. </span></span><br><span class="line"><span class="comment">     * 4. finally, if no handler found through all of above ways, use a default one. </span></span><br><span class="line"><span class="comment">     * 5. if no default handler specified, return null. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Object handler = <span class="keyword">super</span>.lookupHandler(urlPath, request);  </span><br><span class="line">          </span><br><span class="line">        Map&lt;Object, Object&gt; handlerCache = systemCacheManager.getCache(CACHE_NAME_IN_SYSTEM);  </span><br><span class="line">        <span class="comment">// get handler from the cache  </span></span><br><span class="line">        handler = handlerCache.get(urlPath);  </span><br><span class="line">        <span class="keyword">if</span>(handler != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> handler;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// load the Controller as the handler  </span></span><br><span class="line">        String className;  </span><br><span class="line">        String[] pkgs = StringUtils.commaDelimitedListToStringArray(packages);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(String pkg : pkgs) &#123;  </span><br><span class="line">            className = pkg + <span class="string">"."</span> + ClassUtils.convertUrlPathToClassName(urlPath, <span class="keyword">true</span>);  </span><br><span class="line">            handler = ClassUtils.loadModelWithApplicationContextFirst(className, getApplicationContext(), <span class="keyword">null</span>);  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">if</span>((handler != <span class="keyword">null</span> &amp;&amp; handler <span class="keyword">instanceof</span> MultiActionController) &amp;&amp; ((MultiActionController)handler).getMethodNameResolver().getClass().equals(InternalPathMethodNameResolver<span class="class">.<span class="keyword">class</span>)) </span>&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    MethodNameResolver methodNameResolver = (MethodNameResolver)BeanFactoryUtils.beanOfTypeIncludingAncestors(getApplicationContext(), MethodNameResolver<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">true</span>)</span>;  </span><br><span class="line">                    ((MultiActionController)handler).setMethodNameResolver(methodNameResolver);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (BeansException be) &#123;  </span><br><span class="line">                    <span class="comment">// ignore  </span></span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">              </span><br><span class="line">        <span class="comment">// use the default handler if it is specified  </span></span><br><span class="line">        <span class="keyword">if</span>(handler == <span class="keyword">null</span> &amp;&amp; defaultHandler != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            handler = defaultHandler;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// if find one, put it to the cache  </span></span><br><span class="line">        <span class="keyword">if</span>(handler != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            handlerCache.put(urlPath, handler);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> handler;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* (non-Javadoc) </span></span><br><span class="line"><span class="comment">     * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet() </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Assert.notNull(packages, <span class="string">"Packages can not be null."</span>);  </span><br><span class="line">        <span class="keyword">if</span>(systemCacheManager == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            systemCacheManager = (SystemCacheManager)BeanFactoryUtils.beanOfTypeIncludingAncestors(getApplicationContext(), SystemCacheManager<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.webtemplate.util;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ReflectionUtils.FieldFilter;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt; </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> 2005-11-1 上午12:40:04 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">util</span>.<span class="title">ClassUtils</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Normalize the control/userManage.html/.htm/.jsp/.vm... name to the standard </span></span><br><span class="line"><span class="comment">     * class name like control.UserManage  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urlPath </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertUrlPathToClassName</span><span class="params">(String urlPath, <span class="keyword">boolean</span> hasSuffix)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(urlPath.startsWith(<span class="string">"/"</span>)) &#123;  </span><br><span class="line">            urlPath = urlPath.substring(<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        urlPath = urlPath.replaceAll(<span class="string">"/"</span>, <span class="string">"."</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">int</span> index = urlPath.length();  </span><br><span class="line">        <span class="keyword">if</span>(hasSuffix) &#123;  </span><br><span class="line">            <span class="comment">// get rid of resource suffix such as .html/.htm/.jsp/.vm and so no  </span></span><br><span class="line">            index = urlPath.lastIndexOf(<span class="string">"."</span>);  </span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        String handlerName = urlPath.substring(<span class="number">0</span>, index);  </span><br><span class="line">        index = handlerName.lastIndexOf(<span class="string">"."</span>);  </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(handlerName);  </span><br><span class="line">        <span class="keyword">if</span>(index &lt; handlerName.length() &amp;&amp; Character.isLowerCase(handlerName.charAt(index + <span class="number">1</span>))) &#123;  </span><br><span class="line">            sb.setCharAt(index + <span class="number">1</span>, Character.toUpperCase(handlerName.charAt(index + <span class="number">1</span>)));  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> sb.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Load a module class from application context, if not found, then use reflection to initiate one </span></span><br><span class="line"><span class="comment">     * and inject all it's properties which is not set yet and the value has been configured in context. </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fullname </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">loadModelWithApplicationContextFirst</span><span class="params">(String fullname, ApplicationContext context, FieldFilter filter)</span> </span>&#123;  </span><br><span class="line">        Object model = <span class="keyword">null</span>;  </span><br><span class="line">          </span><br><span class="line">        String shortName = ClassUtils.getShortName(fullname);  </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(shortName);  </span><br><span class="line">        sb.setCharAt(<span class="number">0</span>, Character.toLowerCase(shortName.charAt(<span class="number">0</span>)));  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            model = context.getBean(sb.toString());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException be) &#123;  </span><br><span class="line">            <span class="comment">// ignore  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(model != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> model;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            model = ClassUtils.forName(fullname).newInstance();  </span><br><span class="line">            injectDependencies(model, context, filter);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">            <span class="comment">// ignore, continue  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;  </span><br><span class="line">            <span class="comment">// ignore, continue  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;  </span><br><span class="line">            <span class="comment">// ignore, continue  </span></span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> model;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Initialize all the properties which has Setter, the value comes from Spring ApplictionContext </span></span><br><span class="line"><span class="comment">     * By default, the static/final/volatile/native field will no be injected. </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectDependencies</span><span class="params">(Object bean, ApplicationContext context, FieldFilter filter)</span> </span>&#123;  </span><br><span class="line">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(bean.getClass());  </span><br><span class="line">        Field[] fields = ReflectionUtils.getAllFields(bean.getClass());  </span><br><span class="line">        <span class="keyword">for</span>(Field field : fields) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(filter == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                filter = <span class="keyword">new</span> FieldFilter() &#123;  </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Field field)</span> </span>&#123;  </span><br><span class="line">                        <span class="keyword">int</span> modifier = field.getModifiers();  </span><br><span class="line">                        <span class="keyword">if</span>(Modifier.isStatic(modifier) || Modifier.isFinal(modifier)  </span><br><span class="line">                                || Modifier.isVolatile(modifier) || Modifier.isNative(modifier)) &#123;  </span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(!filter.matches(field)) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            ReflectionUtils.makeAccessible(field);  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span>(field.get(bean) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            <span class="comment">// make sure it has a Setter or we will skip this field  </span></span><br><span class="line">            StringBuffer startdMethodName = <span class="keyword">new</span> StringBuffer(field.getName());  </span><br><span class="line">            startdMethodName.setCharAt(<span class="number">0</span>, Character.toUpperCase(field.getName().charAt(<span class="number">0</span>)));  </span><br><span class="line">            startdMethodName.insert(<span class="number">0</span>, <span class="string">"set"</span>);  </span><br><span class="line">            <span class="keyword">for</span>(Method method : methods) &#123;  </span><br><span class="line">                <span class="keyword">if</span>((startdMethodName.toString()).equals(method.getName())) &#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        ReflectionUtils.invokeMethod(method, bean, <span class="keyword">new</span> Object[] &#123;context.getBean(field.getName())&#125;);  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeansException be) &#123;  </span><br><span class="line">                        <span class="comment">// ignore  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码扩展</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试利器——JMH框架</title>
    <url>/2016/03/09/xing-neng-ce-shi-li-qi-jmh-kuang-jia/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>JMH 是一个由 OpenJDK/Oracle 里面那群开发了 Java 编译器的大牛们所开发的 Micro Benchmark Framework 。何谓 Micro Benchmark 呢？简单地说就是在 <strong>method</strong> 层面上的 benchmark，精度可以精确到微秒级。可以看出 JMH 主要使用在当你已经找出了热点函数，而需要对热点函数进行进一步的优化时，就可以使用 JMH 对优化的效果进行定量的分析。</p>
<p>比较典型的使用场景还有：</p>
<ul>
<li>想定量地知道某个函数需要执行多长时间，以及执行时间和输入 n 的相关性</li>
<li>一个函数有两种不同实现（例如实现 A 使用了 FixedThreadPool，实现 B 使用了 ForkJoinPool），不知道哪种实现性能更好</li>
</ul>
<p>尽管 JMH 是一个相当不错的 Micro Benchmark Framework，但很无奈的是网上能够找到的文档比较少，而官方也没有提供比较详细的文档，对使用造成了一定的障碍。但是有个好消息是官方的 <a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/" target="_blank" rel="noopener">Code Sample</a> 写得非常浅显易懂，推荐在需要详细了解 JMH 的用法时可以通读一遍——本文则会介绍 JMH 最典型的用法和部分常用选项。</p>
<h2 id="2-第一个例子"><a href="#2-第一个例子" class="headerlink" title="2. 第一个例子"></a>2. 第一个例子</h2><p>如果你使用 maven 来管理你的 Java 项目的话，引入 JMH 是一件很简单的事情——只需要在 <code>pom.xml</code> 里增加 JMH 的依赖即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jmh.version</span>&gt;</span>1.14.1<span class="tag">&lt;/<span class="name">jmh.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jmh.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jmh.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来再创建我们的第一个 Benchmark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.MICROSECONDS)</span><br><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sleepAWhile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(FirstBenchmark<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">forks</span>(1)</span></span><br><span class="line"><span class="class">                .<span class="title">warmupIterations</span>(5)</span></span><br><span class="line"><span class="class">                .<span class="title">measurementIterations</span>(5)</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有不少你可能是第一次见到的注解，不过不着急，接下来会解释这些注解的意义。我们先来跑一下这个 benchmark 吧 :)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># JMH 1.14.1 (released 39 days ago)</span><br><span class="line"># VM version: JDK 1.8.0_11, VM 25.11-b03</span><br><span class="line"># VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_11.jdk/Contents/Home/jre/bin/java</span><br><span class="line"># VM options: -Didea.launcher.port=7535 -Didea.launcher.bin.path=/Applications/IntelliJ IDEA 15 CE.app/Contents/bin -Dfile.encoding=UTF-8</span><br><span class="line"># Warmup: 5 iterations, 1 s each</span><br><span class="line"># Measurement: 5 iterations, 1 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: com.dyng.FirstBenchmark.sleepAWhile</span><br><span class="line"></span><br><span class="line"># Run progress: 0.00% complete, ETA 00:00:10</span><br><span class="line"># Fork: 1 of 1</span><br><span class="line"># Warmup Iteration   1: 503.440 ms/op</span><br><span class="line"># Warmup Iteration   2: 503.885 ms/op</span><br><span class="line"># Warmup Iteration   3: 503.714 ms/op</span><br><span class="line"># Warmup Iteration   4: 504.333 ms/op</span><br><span class="line"># Warmup Iteration   5: 502.596 ms/op</span><br><span class="line">Iteration   1: 504.352 ms/op</span><br><span class="line">Iteration   2: 502.583 ms/op</span><br><span class="line">Iteration   3: 501.256 ms/op</span><br><span class="line">Iteration   4: 501.655 ms/op</span><br><span class="line">Iteration   5: 504.212 ms/op</span><br><span class="line"></span><br><span class="line">Result &quot;sleepAWhile&quot;:</span><br><span class="line">  502.811 ±(99.9%) 5.495 ms/op [Average]</span><br><span class="line">  (min, avg, max) = (501.256, 502.811, 504.352), stdev = 1.427</span><br><span class="line">  CI (99.9%): [497.316, 508.306] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:00:12</span><br><span class="line"></span><br><span class="line">Benchmark                   Mode  Cnt    Score   Error  Units</span><br><span class="line">FirstBenchmark.sleepAWhile  avgt    5  502.811 ± 5.495  ms/op</span><br></pre></td></tr></table></figure>
<p>对 <code>sleepAWhile()</code> 的测试结果显示执行时间平均约为502毫秒。因为我们的测试对象 <code>sleepAWhile()</code> 正好就是睡眠500毫秒，所以 JMH 显示的结果可以说很符合我们的预期。</p>
<p>那好，现在我们再来详细地解释代码的意义。不过在这之前，需要先了解一下 JMH 的几个基本概念。</p>
<h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><h4 id="2-1-1-Mode"><a href="#2-1-1-Mode" class="headerlink" title="2.1.1 Mode"></a>2.1.1 Mode</h4><p><em>Mode</em> 表示 JMH 进行 Benchmark 时所使用的模式。通常是测量的维度不同，或是测量的方式不同。目前 JMH 共有四种模式：</p>
<ul>
<li><code>Throughput</code>: 整体吞吐量，例如“1秒内可以执行多少次调用”。</li>
<li><code>AverageTime</code>: 调用的平均时间，例如“每次调用平均耗时xxx毫秒”。</li>
<li><code>SampleTime</code>: 随机取样，最后输出取样结果的分布，例如“99%的调用在xxx毫秒以内，99.99%的调用在xxx毫秒以内”</li>
<li><code>SingleShotTime</code>: 以上模式都是默认一次 iteration 是 1s，唯有 <code>SingleShotTime</code> 是<strong>只运行一次</strong>。往往同时把 warmup 次数设为0，用于测试冷启动时的性能。</li>
</ul>
<h4 id="2-1-2-Iteration"><a href="#2-1-2-Iteration" class="headerlink" title="2.1.2 Iteration"></a>2.1.2 Iteration</h4><p><em>Iteration</em> 是 JMH 进行测试的最小单位。在大部分模式下，一次 <em>iteration</em> 代表的是一秒，JMH 会在这一秒内不断调用需要 benchmark 的方法，然后根据模式对其采样，计算吞吐量，计算平均执行时间等。</p>
<h4 id="2-1-3-Warmup"><a href="#2-1-3-Warmup" class="headerlink" title="2.1.3 Warmup"></a>2.1.3 Warmup</h4><p><em>Warmup</em> 是指在实际进行 benchmark 前先进行预热的行为。为什么需要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p>
<h3 id="2-2-注解"><a href="#2-2-注解" class="headerlink" title="2.2 注解"></a>2.2 注解</h3><p>现在来解释一下上面例子中使用到的注解，其实很多注解的意义完全可以望文生义 :)</p>
<h4 id="2-2-1-Benchmark"><a href="#2-2-1-Benchmark" class="headerlink" title="2.2.1 @Benchmark"></a>2.2.1 @Benchmark</h4><p>表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 <code>@Test</code> 类似。</p>
<h4 id="2-2-2-Mode"><a href="#2-2-2-Mode" class="headerlink" title="2.2.2 @Mode"></a>2.2.2 @Mode</h4><p><code>Mode</code> 如之前所说，表示 JMH 进行 Benchmark 时所使用的模式。</p>
<h4 id="2-2-3-State"><a href="#2-2-3-State" class="headerlink" title="2.2.3  @State"></a>2.2.3  @State</h4><p><code>State</code> 用于声明某个类是一个“状态”，然后接受一个 <code>Scope</code> 参数用来表示该状态的共享范围。因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。<code>Scope</code> 主要分为两种。</p>
<ul>
<li><code>Thread</code>: 该状态为每个线程独享。</li>
<li><code>Benchmark</code>: 该状态在所有线程间共享。</li>
</ul>
<p>关于<code>State</code>的用法，官方的 code sample 里有比较好的<a href="http://hg.openjdk.java.net/code-tools/jmh/file/cb9aa824b55a/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_03_States.java" target="_blank" rel="noopener">例子</a>。</p>
<h4 id="2-2-4-OutputTimeUnit"><a href="#2-2-4-OutputTimeUnit" class="headerlink" title="2.2.4 @OutputTimeUnit"></a>2.2.4 @OutputTimeUnit</h4><p>benchmark 结果所使用的时间单位。</p>
<h3 id="2-3-启动选项"><a href="#2-3-启动选项" class="headerlink" title="2.3 启动选项"></a>2.3 启动选项</h3><p>解释完了注解，再来看看 JMH 在启动前设置的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">        .include(FirstBenchmark<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">        .<span class="title">forks</span>(1)</span></span><br><span class="line"><span class="class">        .<span class="title">warmupIterations</span>(5)</span></span><br><span class="line"><span class="class">        .<span class="title">measurementIterations</span>(5)</span></span><br><span class="line"><span class="class">        .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Runner(opt).run();</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-include"><a href="#2-3-1-include" class="headerlink" title="2.3.1 include"></a>2.3.1 include</h4><p>benchmark 所在的类的名字，注意这里是<strong>使用正则表达式对所有类进行匹配</strong>的。</p>
<h4 id="2-3-2-fork"><a href="#2-3-2-fork" class="headerlink" title="2.3.2 fork"></a>2.3.2 fork</h4><p>进行 fork 的次数。如果 fork 数是2的话，则 JMH 会 fork 出两个进程来进行测试。</p>
<h4 id="2-3-3-warmupIterations"><a href="#2-3-3-warmupIterations" class="headerlink" title="2.3.3 warmupIterations"></a>2.3.3 warmupIterations</h4><p>预热的迭代次数。</p>
<h4 id="2-3-4-measurementIterations"><a href="#2-3-4-measurementIterations" class="headerlink" title="2.3.4 measurementIterations"></a>2.3.4 measurementIterations</h4><p>实际测量的迭代次数。</p>
<h2 id="3-第二个例子"><a href="#3-第二个例子" class="headerlink" title="3. 第二个例子"></a>3. 第二个例子</h2><h3 id="3-1-场景描述"><a href="#3-1-场景描述" class="headerlink" title="3.1 场景描述"></a>3.1 场景描述</h3><p>在看过第一个完全只为示范的例子之后，再来看一个有实际意义的例子。</p>
<p>问题：</p>
<blockquote>
<p>计算 1 ~ n 之和，比较串行算法和并行算法的效率，看 n 在大约多少时并行算法开始超越串行算法</p>
</blockquote>
<p>首先定义一个表示这两种实现的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * calculate sum of an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdown pool or reclaim any related resources</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这两种算法的实现不是这篇文章的重点，而且本身并不困难，所以实际代码就不赘述了。如果真的感兴趣的话，可以看最后的附录。以下仅说明一下我所指的串行算法和并行算法的含义。</p>
<ul>
<li>串行算法：使用 <code>for-loop</code> 来计算 n 个正整数之和。</li>
<li>并行算法：将所需要计算的 n 个正整数分成 m 份，交给 m 个线程分别计算出和以后，再把它们的结果相加。</li>
</ul>
<h3 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h3><p>进行 benchmark 的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.MICROSECONDS)</span><br><span class="line"><span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondBenchmark</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Param</span>(&#123;<span class="string">"10000"</span>, <span class="string">"100000"</span>, <span class="string">"1000000"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> Calculator singleThreadCalc;</span><br><span class="line">    <span class="keyword">private</span> Calculator multiThreadCalc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(SecondBenchmark<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">forks</span>(2)</span></span><br><span class="line"><span class="class">                .<span class="title">warmupIterations</span>(5)</span></span><br><span class="line"><span class="class">                .<span class="title">measurementIterations</span>(5)</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">singleThreadBench</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleThreadCalc.sum(numbers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">multiThreadBench</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> multiThreadCalc.sum(numbers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numbers = IntStream.rangeClosed(<span class="number">1</span>, length).toArray();</span><br><span class="line">        singleThreadCalc = <span class="keyword">new</span> SinglethreadCalculator();</span><br><span class="line">        multiThreadCalc = <span class="keyword">new</span> MultithreadCalculator(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TearDown</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        singleThreadCalc.shutdown();</span><br><span class="line">        multiThreadCalc.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-注解"><a href="#3-3-注解" class="headerlink" title="3.3 注解"></a>3.3 注解</h3><p>注意到这里用到了3个之前没有使用的注解。</p>
<h4 id="3-3-1-Param"><a href="#3-3-1-Param" class="headerlink" title="3.3.1 @Param"></a>3.3.1 @Param</h4><p><code>@Param</code> 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。</p>
<h4 id="3-3-2-Setup"><a href="#3-3-2-Setup" class="headerlink" title="3.3.2 @Setup"></a>3.3.2 @Setup</h4><p><code>@Setup</code> 会在执行 benchmark 之前被执行，正如其名，主要用于初始化。</p>
<h4 id="3-3-3-TearDown"><a href="#3-3-3-TearDown" class="headerlink" title="3.3.3 @TearDown"></a>3.3.3 @TearDown</h4><p><code>@TearDown</code> 和 <code>@Setup</code> 相对的，会在所有 benchmark 执行结束以后执行，主要用于资源的回收等。</p>
<p>最后来猜猜看实际结果如何？并行算法在哪个问题集下能够超越串行算法？</p>
<p>我在自己的 mac 上跑下来的结果，总数在10000时并行算法不如串行算法，总数达到100000时并行算法开始和串行算法接近，总数达到1000000时并行算法所耗时间约是串行算法的一半左右。</p>
<h2 id="4-常用选项"><a href="#4-常用选项" class="headerlink" title="4. 常用选项"></a>4. 常用选项</h2><p>还有一些 JMH 的常用选项没有提及的，简单地在此介绍一下</p>
<h3 id="4-1-CompilerControl"><a href="#4-1-CompilerControl" class="headerlink" title="4.1 CompilerControl"></a>4.1 CompilerControl</h3><p>控制 compiler 的行为，例如强制 inline，不允许编译等。</p>
<h3 id="4-2-Group"><a href="#4-2-Group" class="headerlink" title="4.2 Group"></a>4.2 Group</h3><p>可以把多个 benchmark 定义为同一个 group，则它们会被同时执行，主要用于测试多个相互之间存在影响的方法。</p>
<h3 id="4-3-Level"><a href="#4-3-Level" class="headerlink" title="4.3 Level"></a>4.3 Level</h3><p>用于控制 <code>@Setup</code>，<code>@TearDown</code> 的调用时机，默认是 <code>Level.Trial</code>，即benchmark开始前和结束后。</p>
<h3 id="4-4-Profiler"><a href="#4-4-Profiler" class="headerlink" title="4.4 Profiler"></a>4.4 Profiler</h3><p>JMH 支持一些 profiler，可以显示等待时间和运行时间比，热点函数等。</p>
<h2 id="5-延伸阅读"><a href="#5-延伸阅读" class="headerlink" title="5. 延伸阅读"></a>5. 延伸阅读</h2><h3 id="5-1-IDE插件"><a href="#5-1-IDE插件" class="headerlink" title="5.1 IDE插件"></a>5.1 IDE插件</h3><p>IntelliJ 有 JMH 的<a href="https://github.com/artyushov/idea-jmh-plugin" target="_blank" rel="noopener">插件</a>，提供 benchmark 方法的自动生成等便利功能。</p>
<h3 id="5-2-JMH-教程"><a href="#5-2-JMH-教程" class="headerlink" title="5.2 JMH 教程"></a>5.2 JMH 教程</h3><p>Jenkov 的 JMH <a href="http://tutorials.jenkov.com/java-performance/jmh.html" target="_blank" rel="noopener">教程</a>，相比于这篇文章介绍得更为详细，非常推荐。顺便 Jenkov 的其他 Java 教程也非常值得一看。</p>
<h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h2><h3 id="6-1-代码清单"><a href="#6-1-代码清单" class="headerlink" title="6.1 代码清单"></a>6.1 代码清单</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglethreadCalculator</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : numbers) &#123;</span><br><span class="line">            total += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nothing to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadCalculator</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nThreads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultithreadCalculator</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nThreads = nThreads;</span><br><span class="line">        <span class="keyword">this</span>.pool = Executors.newFixedThreadPool(nThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] numbers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; to; i++) &#123;</span><br><span class="line">                total += numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> chunk = numbers.length / nThreads;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> from, to;</span><br><span class="line">        List&lt;SumTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;SumTask&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nThreads) &#123;</span><br><span class="line">                from = (i - <span class="number">1</span>) * chunk;</span><br><span class="line">                to = numbers.length;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                from = (i - <span class="number">1</span>) * chunk;</span><br><span class="line">                to = i * chunk;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> SumTask(numbers, from, to));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Future&lt;Long&gt;&gt; futures = pool.invokeAll(tasks);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">                total += future.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>性能测试</tag>
        <tag>JMH</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展Spring——外部属性文件安全（一）</title>
    <url>/2008/03/17/kuo-zhan-spring-wai-bu-shu-xing-wen-jian-an-quan-yi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在Spring的开发中，我们在很多情况下会使用占位符引用属性文件的属性值来简化我们的系统及使我们的系统具有更高的灵活性和通用性。这种配置方式有两个明显的好处： </p>
<ul>
<li>减少维护的工作量：资源的配置信息可以多应用共享，在多个应用使用同一资源的情况下，如果资源的地址、用户名等配置信息发生了更改，你只要调整属性文件就可以了； </li>
<li>使部署更简单：Spring配置文件主要描述应用程序中的Bean，这些配置信息在开发完成后，应该就固定下来了，在部署应用时，需要根据部署环境调整是就是数据源，邮件服务器的配置信息，将它们的配置信息独立到属性文件中，应用部署人员只需要调整资源属性文件即可，根本不需要关注内容复杂的Spring配置文件。不仅给部署和维护带来了方便，也降低了出错的机率。 </li>
</ul>
<a id="more"></a>
<p>Spring为我们提供了一个<code>BeanFactoryPostProcessorBean</code>工厂后置处理器接口的实现类：<code>org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</code>，它的主要功能是对引用了外部属性值的<code>&lt;bean&gt;</code>进行处理，将其翻译成真实的配置值。 </p>
<p>一般的属性信息以明文的方式存放在属性文件中并没有什么问题，但如果是数据源或邮件服务器用户名密码等重要的信息，在某些场合，我们可能需要以密文的方式保存。虽然Web应用的客户端用户看不到配置文件的，但有时，我们只希望特定的维护人员掌握重要资源的配置信息，而不是毫无保留地对所有可以进入部署机器的用户开放。 </p>
<p>对于这种具有高度安全性要求的系统（如电信、银行、重点人口库等），我们需要对资源连接等属性配置文件中的配置信息加密存放。然后让Spring容器启动时，读入配置文件后，先进行解密，然后再进行占位符的替换。 </p>
<p>很可惜，<code>PropertyPlaceholderConfigurer</code>只支持明文的属性文件。但是，我们可以充分利用Spring框架的扩展性，通过扩展<code>PropertyPlaceholderConfigurer</code>类来达到我们的要求。本文将讲解使用加密属性文件的原理并提供具体的实现。 </p>
<h4 id="以传统的方式使用属性文件"><a href="#以传统的方式使用属性文件" class="headerlink" title="以传统的方式使用属性文件"></a>以传统的方式使用属性文件</h4><p>一般情况下，外部属性文件用于定义诸如数据源或邮件服务器之类的配置信息。这里，我们通过一个简单的例子，讲解使用属性文件的方法。假设有一个 <em>car.properties</em> 属性文件，文件内容如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brand=红旗CA72</span><br><span class="line">maxSpeed=250</span><br><span class="line">price=20000.00</span><br></pre></td></tr></table></figure>
<p>该文件放在类路径的 <em>com/baobaotao/</em> 目录下，在Spring配置文件中利用<code>PropertyPlaceholderConfigurer</code>引入这个配置文件，并通过占位符引用属性文件内的属性项，如代码清单 1所示： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ① 引入外部属性文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/baobaotao/car.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span> ② 指定属性文件地址</span><br><span class="line">       <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fileEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ③ 引用外部属性的值，对car进行配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.baobaotao.place.Car"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"$&#123;brand&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxSpeed"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxSpeed&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"$&#123;price&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在①处，我们通过<code>PropertyPlaceholderConfigurer</code>这个<code>BeanFactoryPostProcessor</code>实现类引用外部的属性文件，通过它的locations属性指定Spring配置文件中引用到的属性文件，在<code>PropertyPlaceholderConfigurer</code>内部，locations是一个Resource数组，所以你可以在地址前添加资源类型前缀，如②处所示。如果需要引用多个属性文件，只需要在②处添加相应<code>&lt;value&gt;</code>配置项即可。</p>
<p>分析<code>PropertyPlaceholderConfigurer</code>结构我们知道Spring通过PropertyPlaceholderConfigurer提供对外部属性文件的支持，为了使用加密的属性文件，我们就需要分析该类的工作机理，再进行改造。所以我们先来了解一下该类的结构如下所示：</p>
<p><img src="/images/pasted-5.png" alt="PropertyPlaceholderConfigurer"></p>
<p>其中<code>PropertiesLoaderSupport</code>类有一个重要的<code>protected void loadProperties(Properties props)</code>方法，查看它的注释，可以知道该方法的作用是将PropertyPlaceholderConfigurer 中locations属性所定义的属性文件的内容读取到props入参对象中。这个方法比较怪，Java很少通过入参承载返回值，但这个方法就是这样。 </p>
<p>所以，我们只要简单地重载这个方法，在将资源文件的内容转换为Properties之前，添加一个解密的步骤就可以了。但是，<code>PropertiesLoaderSupport</code>的设计有一个很让人遗憾的地方，它的locations属性是private的，只提供setter没有提供getter。因此，无法在子类中获取<code>PropertiesLoaderSupport</code>中的locations（资源地址），所以我们得在子类重新定义locations属性并覆盖<code>PropertiesLoaderSupport</code>中的<code>setLocations()</code>方法。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>配置安全</tag>
      </tags>
  </entry>
  <entry>
    <title>春花秋月何时了</title>
    <url>/2014/05/23/chun-hua-qiu-yue-he-shi-liao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>李煜的故事足够多，就算只说他的人生经历，也足够单独写一篇文章出来，比如他传说中的骈齿双瞳；比如他出城投降时带着的国后“小周后”；比如他死时的“牵机药”；比如他死的那天正好是他的生日，生日又正好是“七夕”……他是词人里最让人一言难尽的词人，他是真正的帝王，也是在词史中可以称“帝”的那一位。</p>
<a id="more"></a>
<p><img src="/images/pasted-29.png" alt="upload successful"><br>（李煜的宫廷生活）</p>
<p>严格意义上讲，李煜不算宋人，他是北宋建隆二年继位成为南唐（都城在现在的南京）国的皇帝，但他并不想当皇帝，他原来也不是太子，但因为有“骈齿双瞳”的奇相（欧阳修《新五代史》），被太子嫉恨，于是他死命读书、写诗、填词，礼佛，让太子释疑，但太子还是病死了，他还是不得不当了皇帝。就算当皇帝，他也没有勤政爱民，专心国事，他或者是读书礼佛形成了惯性，或者是天性使然，仍然醉心于宫闱，醉心于文艺，不理国事。他尊宋为正统，每年向宋纳贡以保境内平安。十年过去，宋太祖灭掉了南汉，李煜看看天下形势，再也不敢称为“唐”国，于是改称“江南国主”，第二年他又再次贬损仪制，撤去金陵台殿鸱吻，以表示自己尊奉宋廷。</p>
<p><img src="/images/pasted-30.png" alt="upload successful"></p>
<p>（北宋灭南唐示意图）</p>
<p>天无二日，到了开宝八年（975年），南京城前宋兵兵临城下，李煜还是兵败降宋，被俘至汴京（就是现在的的河南开封），宋朝廷授他为右千牛卫上将军，封“违命侯”，将军听上去还好说，但这个”违命“侯的名字，实在是极大的侮辱。到太平兴国三年（978年）的七月初七“乞巧节”那一天，李煜死于汴京（据说死的原因也是因为写词，我们不展开说了），死时只有四十二岁，被宋朝廷追赠太师，追封吴王，世称南唐后主、李后主。</p>
<p><img src="/images/pasted-31.png" alt="upload successful"></p>
<p>（李煜画像）</p>
<p>中国历史上有两位最不应当做帝王的帝王，一位是李煜，一位是宋徽宗，两位都是不世的艺术天才，两位都是在帝王世袭的制度下当上了帝王，也都亡了国，都被抓去做了俘虏，赵佶创立了瘦金体，绘画也成就极高，李煜则干脆成了词中帝王。</p>
<p>其实，词之外，李煜还精书法、工绘画、通音律，但词的成就最高。李煜的词，继承了晚唐以来温庭筠、韦庄等“花间派”词人的传统，同时又受李璟、冯延巳的影响，语言明快、形象生动、用情真挚，风格鲜明，到了亡国之后，因为个人经历更加丰富，因此词作也更加题材广阔，含意也更加深沉，气象也更加博大。今天我们就来读他的代表作《虞美人.春花来月何时了》，全词如下：</p>
<p><img src="/images/pasted-32.png" alt="upload successful"></p>
<p>（京剧《霸王别姬》）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">春花秋月何时了？往事知多少。</span><br><span class="line"></span><br><span class="line">小楼昨夜又东风，故国不堪回首月明中。</span><br><span class="line"></span><br><span class="line">雕栏玉砌应犹在，只是朱颜改。</span><br><span class="line"></span><br><span class="line">问君能有几多愁？恰似一江春水向东流。</span><br></pre></td></tr></table></figure>
<p>虞美人是词牌名，最早是唐代教坊曲，始词见于敦煌曲子词，“虞美人”这个名字据说来源于楚霸王项羽的爱姬虞姬，当然，它也是一种极美丽的花，又叫丽春花、锦被花，花有红、紫、白等色，真正被定名为词牌名，就是李煜写了这阙词之后的“虞美人”，因为后来，这个词牌还多了一个名字叫“一江春水”。</p>
<p><img src="/images/pasted-33.png" alt="upload successful"></p>
<p>（虞美人花）</p>
<p>《人间词话》里说李煜“生于深宫之中，长于妇人之手”，也正因此，他阅世不深，他没有治国安邦的雄才大略，也没有拯民济世的想法，当他被命运推着走到了囚徒的末路时，命运给他的生命送上了一个出口，就是写词。正是因为他曾经的经历，他以真性情示人，他做过皇帝，什么世面都见过，自己想做什么就做什么，想说什么就说什么，他不用掩饰，他说出来的都是真情，而诗词之所以能打动人，还有什么比真情更重要呢？</p>
<p>“春花秋月何时了，往事知多少”，这是两个对谁都合适的真理，任谁都不得不面对的真理，春花秋月无尽而永恒，往事知多少也无尽而永恒，当词人在发出喟叹之时，他不假思索，没有任何掩饰，直接就说了“何时了”“知多少”。正是因为他的普遍永恒性，大部分人读到这两句，都会心生生命无常之悲，这种无穷而无可奈何的感情是绵亘在每一个人生命中的永恒悲凉，因此，这凭空而出的似问非问的两句，足以引得读词的天下人与之同悲。</p>
<p>他为什么会有这样的感受呢？因为“小楼昨夜又东风，故国不堪回首月明中”，昨天晚上又起风了，这让词人想起了旧时的往事，东风年年都有，但故国已经不在，明月月月常圆，但往事不堪回首。写到这句，词人并没有写旧时具体的生活，这使得这几句更适合所有的人，亡国是他的哀痛，但每个人心中都有类似词人亡国之重的悲痛，这份悲痛在无边无尽的春花秋月之中，在不断流逝的时光之中，都同样显得不堪回首，因此带有普适性，让人共鸣，打动人心。</p>
<p><img src="/images/pasted-34.png" alt="upload successful"></p>
<p>（雕栏玉彻应犹在）</p>
<p>“雕栏玉砌应犹在，只是朱颜改。”雕栏玉砌当然指远在金陵的南唐故宫。故国的雕栏玉砌还应当是老样子吧，可是那些旧日的宫女们该是容颜改变了吧，由小楼东风，词人想到了故国，想到了故国的宫殿，想到了宫殿的人，岁月催人，人怎么可能不改变容颜呢？</p>
<p>“问君能有几多愁？恰似一江春水向东流”，思前想后，心中的愁绪难以排解，“往事”、“故国”、“朱颜”都一去不复返了，这重重叠叠的愁绪一层层压了过来，再也无法排解，有多少愁绪呢？“恰似一江春水向东流”，就像一江春水啊，流也流不尽……</p>
<p><img src="/images/pasted-35.png" alt="upload successful"></p>
<p>（一江春水向东流）</p>
<p>因为他当过帝王，又是亡国之君，所以，他才能以沉雄奔放之笔，将破国亡家的悲痛，以不管不顾的方法，以不加掩饰的语气，层层叠叠的堆积了出来，他跟温庭筠他们的词完全不一样，他再也不是闺阁之情，再也不是伤春怨别，词到了李煜手里，题材真正变得阔大深远了，它所能表达的感情也更加丰富了。在李煜之前，词以艳情为主，就算是要寄寓抱负也基本用“比兴”手法，隐而不露，不直接说，显得不够“真”，李煜的词则不管不顾、直抒胸臆，他倾吐家国身世情真语挚，使词摆脱了过去长期是在花间樽前闺阁亭台吟唱中所形成的传统风格，成为词人们言怀述志的新文学体裁，艺术手法上对后来“豪放派”词有一定程度的影响。《人间词话》里的评价是“变伶工之词而为士大夫之词”是准确的，当然，他还没有沉远奔放到豪放的程度，那是范仲淹以及后来苏轼和辛弃疾要做的事，但词这种文学体裁，在李煜手里，真正成熟了，成了能与诗并称的文学体裁。</p>
<p><img src="/images/pasted-36.png" alt="upload successful"></p>
<p>（李煜祖先的陵墓）</p>
<p>《增广贤文》里说：“未曾清贫难成人,不经打击老天真。 自古英雄出炼狱,从来富贵入凡尘。”李煜的词史地位是他遭受亡国之劫换来的，他做不好皇帝，上天给了他别样的地位。</p>
<p>李煜注定是为写词而生的，让他做皇帝他也做不好，论用词写愁，谁还能愁得像他一样沉重阔大。</p>
]]></content>
      <tags>
        <tag>古诗鉴赏</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展acegi以支持验证码</title>
    <url>/2008/03/27/kuo-zhan-acegi-yi-zhi-chi-yan-zheng-ma/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是通用改写扩展 <code>AuthenticationProcessingFilter</code> 类加入验证码的校验来实现，当然还有开源框架 JCaptcha 来生成验证码，验证码的生成过程可以去查阅相关的资料，这里只展示后端在验证时的扩展点，代码如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationProcessingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略非关键点代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (requiresAuthentication(httpRequest, httpResponse)) &#123;</span><br><span class="line">            Authentication authResult;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//加入验证码</span></span><br><span class="line">                <span class="keyword">if</span>(!onPreAuthentication(httpRequest, httpResponse))&#123;</span><br><span class="line">                    httpRequest.getSession().setAttribute(ACEGI_SECURITY_LAST_USERNAME_KEY,</span><br><span class="line">                            username);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationCodeException(<span class="string">"请输入正确的验证码！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 省略非关键代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入验证码 </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onPreAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException, IOException </span>&#123;</span><br><span class="line">        String randNum=request.getParameter(<span class="string">"randNum"</span>);</span><br><span class="line">        String rand=(String)request.getSession().getAttribute(<span class="string">"rand"</span>);</span><br><span class="line">        <span class="keyword">if</span>(rand.equals(randNum))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略非关键代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Acegi</tag>
        <tag>应用安全</tag>
      </tags>
  </entry>
  <entry>
    <title>油画里的乡愁</title>
    <url>/2018/11/22/you-hua-li-de-xiang-chou/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-52.png" alt="upload successful"></p>
<p>本篇油画是画家李自健的作品，他以自己的童年生活为素材，画出了中国乡土文明中的人性光辉，也画出了刻骨的乡愁。<strong>在那个已逝的美丽时代，物质尽管匮乏，但不乏温暖，我们都是从那个时代走过来的，内心深处最真实的记忆，很温馨的回忆。如果也能引起你的共鸣，那么庆幸你拥有着如此美丽的乡愁</strong>，虽然那时候没有游戏机电视机，但是你有牛有狗有鸡猫，有山有水有鱼虾，你的童年拥有整个大自然最纯净的部分，比现在孩子的童年更幸福！<br><a id="more"></a></p>
<p><img src="/images/pasted-53.png" alt="upload successful"><br>拔刺儿，没有穿鞋，脚被磨破了——这代价我们曾经愿意付出，很感慨！</p>
<p><img src="/images/pasted-54.png" alt="upload successful"></p>
<p>姐姐的故事还没讲完就听睡着了。那时候，哪里都可以安静无虑的睡觉</p>
<p><img src="/images/pasted-55.png" alt="upload successful"></p>
<p>小狗陪伴河边憧憬，安静的疑望远方……想起了什么？</p>
<p><img src="/images/pasted-56.png" alt="upload successful"></p>
<p>是劳动也是玩耍，真是天真无邪</p>
<p><img src="/images/pasted-57.png" alt="upload successful"></p>
<p>那时从小就开始劳动了</p>
<p><img src="/images/pasted-58.png" alt="upload successful"></p>
<p>听泉的汶川女娃，小时的发呆也是一片片的期盼</p>
<p><img src="/images/pasted-59.png" alt="upload successful"></p>
<p>割草，干活也辛苦靠在姐姐就睡着了，现在的孩子已经没有多的兄弟姐妹了，这些画让我好怀念啊！</p>
<p><img src="/images/pasted-60.png" alt="upload successful"></p>
<p>还是姐姐呵护着——放牛，暮归的老牛是我们的同伴</p>
<p><img src="/images/pasted-61.png" alt="upload successful"></p>
<p>那时学的很多，也会做很多……</p>
<p><img src="/images/pasted-62.png" alt="upload successful"></p>
<p>感慨的童年，心酸的年代，很……</p>
<p><img src="/images/pasted-63.png" alt="upload successful"></p>
<p>憧憬，从小就会做很多的事情，到河边洗衣服……</p>
<p><img src="/images/pasted-64.png" alt="upload successful"></p>
<p>最熟悉的背，是姐姐的，对了，不要忘了她，我们最忠诚的亲人……</p>
<p><img src="/images/pasted-65.png" alt="upload successful"></p>
<p>兄妹情深相依相靠很感动！不禁留下了泪水！曾经的纯真童年如今竟变成无处安放的回忆！</p>
<p><img src="/images/pasted-66.png" alt="upload successful"></p>
<p>勾起了埋藏的记忆，确实被触动了。一些内心深处的东西，因为我们小时都这样骑牛</p>
<p><img src="/images/pasted-67.png" alt="upload successful"></p>
<p>美好的年代，淳朴的民风，很感人，尤其是那姐、那狗、那牛、那山、那水、那些美好的童年时光……</p>
<p><img src="/images/pasted-68.png" alt="upload successful"></p>
<p>放牛娃</p>
<p><img src="/images/pasted-69.png" alt="upload successful"></p>
<p>草垛</p>
<p><img src="/images/pasted-70.png" alt="upload successful"></p>
<p>太累了</p>
<p><img src="/images/pasted-71.png" alt="upload successful"></p>
<p>山溪</p>
<p><img src="/images/pasted-72.png" alt="upload successful"></p>
<p>抓小鸡</p>
<p><img src="/images/pasted-73.png" alt="upload successful"></p>
<p>摘苹果</p>
<p><img src="/images/pasted-74.png" alt="upload successful"></p>
<p>读书</p>
<p><img src="/images/pasted-75.png" alt="upload successful"></p>
<p>洗衣服</p>
<p><img src="/images/pasted-76.png" alt="upload successful"></p>
<p>门神</p>
<p><img src="/images/pasted-77.png" alt="upload successful"></p>
<p>姐弟</p>
<p><img src="/images/pasted-78.png" alt="upload successful"></p>
<p>攀爬</p>
<p><img src="/images/pasted-79.png" alt="upload successful"></p>
<p>赤脚过河</p>
<p><img src="/images/pasted-80.png" alt="upload successful"></p>
<p>守推车</p>
<p><img src="/images/pasted-81.png" alt="upload successful"></p>
<p>洗个脚</p>
<p><img src="/images/pasted-82.png" alt="upload successful"></p>
<p>开心一刻</p>
<p><img src="/images/pasted-83.png" alt="upload successful"></p>
<p>喂饭</p>
<p><img src="/images/pasted-84.png" alt="upload successful"></p>
<p>姐弟</p>
<p><img src="/images/pasted-85.png" alt="upload successful"></p>
<p>割草</p>
<p><img src="/images/pasted-86.png" alt="upload successful"></p>
<p>和稀泥</p>
<p><img src="/images/pasted-87.png" alt="upload successful"></p>
<p>雀儿飞过</p>
<p><img src="/images/pasted-88.png" alt="upload successful"></p>
<p>春回大地</p>
<p><img src="/images/pasted-89.png" alt="upload successful"></p>
<p>自个玩</p>
<p><img src="/images/pasted-90.png" alt="upload successful"></p>
<p>啼晓</p>
<p><img src="/images/pasted-91.png" alt="upload successful"></p>
<p>初春的阳光</p>
<p><img src="/images/pasted-92.png" alt="upload successful"></p>
<p>眠</p>
<blockquote>
<p><strong>油画作者</strong>：<strong>李自建</strong>，著名的旅美画家，1954年生于湖南邵阳，1982年毕业于广州美术学院油画系，1988年移居美国洛杉矶。 现为中国艺术研究院中国油画院海外特聘画家、中国美术家协会会员、美国油画家协会会员。20年来，持续于六大洲三十个国家与地区举办大型环球巡回个展，自主、自费，以现实主义油画艺术巡展传播人性与爱普世价值，弘扬中华文化精神，影响广泛，瞩目画坛。国际和平特别贡献奖章及欧洲拜占庭“圣·约翰骑士勋章”获得者。</p>
</blockquote>
]]></content>
      <tags>
        <tag>油画</tag>
        <tag>童年</tag>
        <tag>乡愁</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展Spring——外部属性文件安全（二）</title>
    <url>/2008/03/18/kuo-zhan-spring-wai-bu-shu-xing-wen-jian-an-quan-er/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="编写支持加密属性文件的实现类"><a href="#编写支持加密属性文件的实现类" class="headerlink" title="编写支持加密属性文件的实现类"></a>编写支持加密属性文件的实现类</h4><p>通过以上分析，我们设计一个支持加密属性文件的增强型<code>PropertyPlaceholderConfigurer，</code>其代码如所示： </p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.DefaultPropertiesPersister;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.PropertiesPersister;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecryptPropertyPlaceholderConfigurer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">PropertyPlaceholderConfigurer</span> ...</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource[] locations;   <span class="comment">//① 重新定义父类中的这个同名属性</span></span><br><span class="line">    <span class="keyword">private</span> Resource keyLocation; <span class="comment">//② 用于指定密钥文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyLocation</span><span class="params">(Resource keyLocation)</span> ...</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyLocation = keyLocation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocations</span><span class="params">(Resource[] locations)</span> ...</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations = locations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> IOException ...</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.locations != <span class="keyword">null</span>) ...&#123;</span><br><span class="line">            PropertiesPersister propertiesPersister = <span class="keyword">new</span> DefaultPropertiesPersister();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.locations.length; i++) ...&#123;</span><br><span class="line">                Resource location = <span class="keyword">this</span>.locations[i];</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) ...&#123;</span><br><span class="line">                    logger.info(<span class="string">"Loading properties file from "</span> + location);</span><br><span class="line">                &#125;</span><br><span class="line">                InputStream is = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> ...&#123;</span><br><span class="line">                    is = location.getInputStream();</span><br><span class="line">                        <span class="comment">//③ 加载密钥</span></span><br><span class="line">                    Key key = DESEncryptUtil.getKey(keyLocation.getInputStream());</span><br><span class="line">                    <span class="comment">//④ 对属性文件进行解密</span></span><br><span class="line">is = DESEncryptUtil.doDecrypt(key, is);</span><br><span class="line"><span class="comment">//⑤ 将解密后的属性流装载到props中</span></span><br><span class="line">                    <span class="keyword">if</span>(fileEncoding != <span class="keyword">null</span>)...&#123;</span><br><span class="line">                        propertiesPersister.load(props,</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(is,fileEncoding));</span><br><span class="line">                    &#125;<span class="keyword">else</span>...&#123;</span><br><span class="line">                        propertiesPersister.load(props ,is);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> ...&#123;</span><br><span class="line">                    <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">                        is.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对locations指定的属性文件流数据进行额外的解密工作，解密后再装载到props中。比起PropertyPlaceholderConfigurer，我们只做了额外的一件事：装载前对属性资源进行解密。 </p>
<p>在代码清单 2的③和④处，我们使用了一个DES解密的工具类对加密的属性文件流进行解密。 对文件进行对称加密的算法很多，一般使用DES对称加密算法，因为它速度很快，破解困难，DESEncryptUtil不但提供了DES解密功能，还提供了DES加密的功能，因为属性文件在部署前必须经常加密： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESEncryptUtil</span> ...</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">createKey</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;<span class="comment">//创建一个密钥</span></span><br><span class="line">        Security.insertProviderAt(<span class="keyword">new</span> com.sun.crypto.provider.SunJCE(), <span class="number">1</span>);</span><br><span class="line">        KeyGenerator generator = KeyGenerator.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">        generator.init(<span class="keyword">new</span> SecureRandom());</span><br><span class="line">        Key key = generator.generateKey();</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">getKey</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> ...&#123;</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">            <span class="keyword">return</span> (Key) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) ...&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] doEncrypt(Key key, <span class="keyword">byte</span>[] data) &#123;<span class="comment">//对数据进行加密</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"DES/ECB/PKCS5Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">            <span class="keyword">byte</span>[] raw = cipher.doFinal(data);</span><br><span class="line">            <span class="keyword">return</span> raw;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">doDecrypt</span><span class="params">(Key key, InputStream in)</span> </span>&#123;<span class="comment">//对数据进行解密</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"DES/ECB/PKCS5Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] tmpbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((count = in.read(tmpbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(tmpbuf, <span class="number">0</span>, count);</span><br><span class="line">                tmpbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="keyword">byte</span>[] orgData = bout.toByteArray();</span><br><span class="line">            <span class="keyword">byte</span>[] raw = cipher.doFinal(orgData);</span><br><span class="line">            ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(raw);</span><br><span class="line">            <span class="keyword">return</span> bin;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//提供了Java命令使用该工具的功能</span></span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">2</span> &amp;&amp; args[<span class="number">0</span>].equals(<span class="string">"key"</span>)) &#123;<span class="comment">// 生成密钥文件</span></span><br><span class="line">            Key key = DESEncryptUtil.createKey();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]));</span><br><span class="line">            oos.writeObject(key);</span><br><span class="line">            oos.close();</span><br><span class="line">            System.out.println(<span class="string">"成功生成密钥文件。"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">3</span> &amp;&amp; args[<span class="number">0</span>].equals(<span class="string">"encrypt"</span>)) &#123;<span class="comment">//对文件进行加密</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(args[<span class="number">1</span>]);</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] tmpbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((count = in.read(tmpbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(tmpbuf, <span class="number">0</span>, count);</span><br><span class="line">                tmpbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="keyword">byte</span>[] orgData = bout.toByteArray();</span><br><span class="line">            Key key = getKey(<span class="keyword">new</span> FileInputStream(args[<span class="number">2</span>]));</span><br><span class="line">            <span class="keyword">byte</span>[] raw = DESEncryptUtil.doEncrypt(key, orgData);</span><br><span class="line">            file = <span class="keyword">new</span> File(file.getParent() + <span class="string">"\\en_"</span> + file.getName());</span><br><span class="line">            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            out.write(raw);</span><br><span class="line">            out.close();</span><br><span class="line">            System.out.println(<span class="string">"成功加密，加密文件位于:"</span>+file.getAbsolutePath());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">3</span> &amp;&amp; args[<span class="number">0</span>].equals(<span class="string">"decrypt"</span>)) &#123;<span class="comment">//对文件进行解密</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(args[<span class="number">1</span>]);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            Key key = getKey(<span class="keyword">new</span> FileInputStream(args[<span class="number">2</span>]));</span><br><span class="line">            InputStream raw = DESEncryptUtil.doDecrypt(key, fis);</span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] tmpbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((count = raw.read(tmpbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(tmpbuf, <span class="number">0</span>, count);</span><br><span class="line">                tmpbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            raw.close();</span><br><span class="line">            <span class="keyword">byte</span>[] orgData = bout.toByteArray();</span><br><span class="line">            file = <span class="keyword">new</span> File(file.getParent() + <span class="string">"\\rs_"</span> + file.getName());</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            fos.write(orgData);</span><br><span class="line">            System.out.println(<span class="string">"成功解密，解密文件位于:"</span>+file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解密工作主要涉及到两个类Cipher和Key，前者是加密器，可以通过init()方法设置工作模式和密钥，在这里，我们设置为解密工作模式：Cipher.DECRYPT_MODE。Cipher通过doFinal()方法对字节数组进行加密或解密。</p>
<p>要完成属性文件的加密工作，首先，必须获取一个密钥文件，然后才能对明文的属性文件进行加密。如果需要调整属性文件的信息，你必须执行相反的过程，即用密钥对加密后的属性文件进行解密，调整属性信息后，再将其加密。<br>DESEncryptUtil 工具类可以完成以上所提及的三个工作： </p>
<ul>
<li>生成一个密钥文件<br><code>java com.baobaotao.DESEncryptUtil key D:\key.dat</code><br>第一个参数为key，表示创建密钥文件，第二个参数为生成密钥文件的保存地址。 </li>
<li>用密钥文件对属性文件进行加密<br><code>java com.baobaotao.DESEncryptUtil encrypt d:\test.properties d:\key.dat</code><br>第一个参数为encrypt，表示加密，第二个参数为需要加密的属性文件，第三个参数为密钥文件。如果加密成功，将生成en_test.properties的加密文件。 </li>
<li>用密钥文件对加密后的属性文件进行解密<br><code>java com.baobaotao.DESEncryptUtil decrypt d:\test.properties d:\key.dat</code><br>第一个参数为decrypt，表示解密，第二个参数为需要解密的属性文件，第三个参数为密钥文件。如果加密成功，将生成rs_test.properties的解密文件。 </li>
</ul>
<h4 id="在Spring中配置加密属性文件"><a href="#在Spring中配置加密属性文件" class="headerlink" title="在Spring中配置加密属性文件"></a>在Spring中配置加密属性文件</h4><p>假设我们通过DESEncryptUtil 工具类创建了一个key.bat密钥，并对 <em>car.properties</em> 属性进行加密，生成加密文件<em>en_car.properties</em>。下面，我们通过<code>DecryptPropertyPlaceholderConfigurer</code>增强类进行配置，让Spring容器支持加密的属性文件： </p>
<p>假设我们通过DESEncryptUtil 工具类创建了一个key.bat密钥，并对car.properties属性进行加密，生成加密文件en_car.properties。下面，我们通过DecryptPropertyPlaceholderConfigurer增强类进行配置，让Spring容器支持加密的属性文件： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.baobaotao.place.DecryptPropertyPlaceholderConfigurer"</span>&gt;</span> ①</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/baobaotao/en_car.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keyLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:com/baobaotao/key.dat"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fileEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.baobaotao.place.Car"</span>&gt;</span> ②</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brand"</span> <span class="attr">value</span>=<span class="string">"$&#123;brand&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxSpeed"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxSpeed&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"$&#123;price&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意①处的配置，我们使用自己编写的DecryptPropertyPlaceholderConfigurer替代Spring的PropertyPlaceholderConfigurer，由于前者对属性文件进行了特殊的解密处理，因此②处的car Bean也可以引用到加密文件en_car.properties中的属性项。 </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>要Spring配置时，将一些重要的信息独立到属性文件中是比较常见的做法，Spring只支持明文存放的属性文件，在某些场合下，我们可以希望对属性文件加密保存，以保证关键信息的安全。通过扩展<code>PropertyPlaceholderConfigurer</code>，在属性文件流加载后应用前进行解密就可以很好地解决这个问题了。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>配置安全</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——Jetty</title>
    <url>/2012/04/23/yuan-ma-jie-du-jetty/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Jetty相较于Tomcat更加轻便，虽然架构更加简单，但是看起来可并不轻松。Spring是设计初衷是用来管理应用中的实例Bean，因而是基于Bean的架构；Jetty则更倾向于流程和组件的管理，采用了基于handler的架构。handler的嵌套和链式结构，LifeCycle和doStart、doHandler模式无不印证了这点。</p>
<p>本文主要从基本架构、LifeCycle结构、Handler体系结构、Jetty启动过程、接受并处理请求的流程和与Tomcat的比较来简要介绍下Jetty，细节部分后面的博文会有分析。</p>
<a id="more"></a>
<h3 id="Jetty的基本架构"><a href="#Jetty的基本架构" class="headerlink" title="Jetty的基本架构"></a>Jetty的基本架构</h3><p>前面的博文谈及应用服务期的架构已经说过了几个基本模块的概念，connection、Threadpool等~拷贝了<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jetty/" target="_blank" rel="noopener">我的同事许令波</a>画的图(文中关于基本架构的描述挺详细的，参考了其目录结构哈~不过对于有些知识点有自己的看法，因此总结该文)：</p>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<p>该博文中谈到“Jetty 中还有一些可有可无的组件，我们可以在它上做扩展。如 JMX，我们可以定义一些 Mbean 把它加到 Server 中，当 Server 启动的时候，这些 Bean 就会一起工作。”我的理解是，Jetty中的JMX是提供给server的Container，使得注册到server的Handler同时注册到JMX上，以便于运行时的监控和管理，应该是先有server再有JMX，而不是反过来的。</p>
<h3 id="LifeCycle体系结构"><a href="#LifeCycle体系结构" class="headerlink" title="LifeCycle体系结构"></a>LifeCycle体系结构</h3><p>Jetty是基于Handler的架构模式，对于组件化的概念很容易理解，那Jetty又是如何管理流程和Handler的生命周期的呢，这就需要从下节的Handler的体系架构来解释，本节主要分析LifeCycle。</p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<p>写文档最讨厌的就是画图，无奈有些图没法copy~</p>
<p>上图包含四层涵义：</p>
<p>1、每个Handler都是一个LifeCycle</p>
<p>2、AggregateLifeCycle正如起名，聚集在一起的生命周期。Jetty把Handler生命周期所关联的一些subHandler注册在Hahdler上，eg:server-&gt;deployManager正是如此。</p>
<p>3、监听器的概念就是一个观察者模式的应用，触发于Handler的doStart,doStop,doFail等事件。</p>
<p>4、Jetty的LifeCycle结构主要影响Jetty的初始化，而Handler结构影响Jetty的处理功能。</p>
<h3 id="Handler体系结构"><a href="#Handler体系结构" class="headerlink" title="Handler体系结构"></a>Handler体系结构</h3><p>既然Jetty是基于Handler的架构，那么Handler体系关乎着Jetty的方方面面：</p>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p>上图有几层涵义：</p>
<ol>
<li>红色的server即Jetty的核心Handler，它依赖的几个类虽然不是Handler，也在图中标出以方便理解，server需要Deploy部署，需要Connector，自然需要inner Handler，这里的红色的虚线是默认的依赖关系，嵌入式的Jetty或自定义情况下是可以变的，比如换成ResourceHandler,WebAppContext等~</li>
<li>AbatractHandlerContainer提供对嵌套Handler获取Childs的方法支持，因此位于很顶层。</li>
<li>ContextHandlerCollection不同于普通的HandlerCollection的区别在于，提供了对于Context的支持，即依据生产的app建立app与name的映射关系并对于url请求依据该映射关系分发到指定的app中。</li>
<li>HandlerWrapper仅仅提供了简单的对于Wapper的handler等操作，其实handler操作并不是主要的，Jetty中主要是用它来创建Handler的嵌套结构，就如ScopedHander一样，而handler操作大多数时候无用。</li>
<li>ScopedHandler这个真是折腾我好久，这样设计的意图着实不好理解，后面有专题解释，为理解本文，你可以将实现了继承了该类的Handler理解成已经是一个完整的嵌套Handler即可。</li>
<li>ContextHandler从图中可以看到，由DeployManager生产，并和ServletHandler等构成了嵌套Handler。ContextHandler的本质可理解为ServletContext,取到ServletContext,由于嵌套Handler的构造继而会调用ServletHandler等初始化和相关操作，最后走到web应用中处理业务代码。其实这个嵌套关系是可以修改的，比如应用中用不到sessionHandler，完全可以将其删除掉，但问题在与这种关系写在了代码中，为什么就不能留在配置文件中呢？也许配置文件也可以，没有验证过。</li>
</ol>
<h3 id="Jetty的启动过程"><a href="#Jetty的启动过程" class="headerlink" title="Jetty的启动过程"></a>Jetty的启动过程</h3><p><img src="/images/pasted-12.png" alt="upload successful"></p>
<p>实际流程比较复杂，上面的时序图是个简化版本。启动的时序图有几点需要注意：</p>
<ol>
<li>红线部分的第一次其实并没有handler，因为没有生产webappcontext，第二次再次调用start的时候才真的运作</li>
<li>蓝线部分描述的就是app的生产到contextHandler的生产的过程，后面的contextHandler的初始化是由于deployManager注册了事件监听器触发的。</li>
<li>最后打开Http连接，监听请求的到来</li>
</ol>
<h3 id="接受请求"><a href="#接受请求" class="headerlink" title="接受请求"></a>接受请求</h3><p>由于Jetty默认采用NIO的方式接受请求，本文基于NIO的方式简单介绍下实现原理，因为NIO内容比较多，会在下面的文章中给出总结。</p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>主要介绍jetty接收到请求后如何生产并解析Request，Response等属性并最终走到handler方法体内。</p>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<p>这里面涉及到的connection有多个,SelectorChannelConnector、SelectorChannelEndPoint、AsyncHttpConnection,功能各不相同</p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>Jetty</tag>
        <tag>WebServer</tag>
      </tags>
  </entry>
  <entry>
    <title>渔舟唱晚</title>
    <url>/2014/02/13/yu-zhou-chang-wan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>斜阳，氤氲了满脸的红光，恋恋地下山。</p>
<p>水湄边，圆晕，被斜打了正着。船上人家，在两岸“青山”中被烟笼着，羞涩地拉开了帷幕。</p>
<p>斜阳，抹红了天际。<br>远远有座小村庄，烟袅袅升起。外婆，就在那里面的灶头做饭，等着我。</p>
<p>渔舟唱晚，余音绕梁。</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<a id="more"></a>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<p><img src="/images/pasted-24.png" alt="upload successful"></p>
<p><img src="/images/pasted-25.png" alt="upload successful"></p>
<p><img src="/images/pasted-26.png" alt="upload successful"></p>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>山水古韵</category>
      </categories>
      <tags>
        <tag>渔舟唱晚</tag>
      </tags>
  </entry>
  <entry>
    <title>现有Spring应用的Hystrix集成</title>
    <url>/2016/03/27/xian-you-spring-ying-yong-de-hystrix-ji-cheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在<a href="/2016/03/25/hystrix-jian-jie/">上一篇文章中，</a>我们研究了Hystrix的基础知识，以及它如何帮助构建容错和弹性应用程序。</p>
<p><strong>有许多现有的Spring应用程序可以调用可以从Hystrix中受益的外部系统。</strong> 遗憾的是，为了集成Hystrix，可能无法重写这些应用程序，但是在<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html" target="_blank" rel="noopener">Spring AOP</a>的帮助下，可以采用非侵入性的方式集成Hystrix 。<br><a id="more"></a></p>
<p>在本文中，我们将了解如何将Hystrix与现有的Spring应用程序集成。</p>
<h2 id="2-Hystrix成Spring应用程序"><a href="#2-Hystrix成Spring应用程序" class="headerlink" title="2. Hystrix成Spring应用程序"></a>2. Hystrix成Spring应用程序</h2><h3 id="2-1-应用现状"><a href="#2-1-应用现状" class="headerlink" title="2.1 应用现状"></a>2.1 应用现状</h3><p>让我们看一下应用程序的现有客户端调用程序，它调用我们在上一篇文章中创建的<em>RemoteServiceTestSimulator</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"springClient"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExistingClient</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;remoteservice.timeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remoteServiceDelay;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invokeRemoteServiceWithOutHystrix</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RemoteServiceTestSimulator(remoteServiceDelay).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们在上面的代码片段中看到的那样，<em>invokeRemoteServiceWithOutHystrix</em>方法负责调用<em>RemoteServiceTestSimulator</em>远程服务。当然，现实世界的应用程序不会这么简单。</p>
<h3 id="2-2-创建一个-Aspect-Advice"><a href="#2-2-创建一个-Aspect-Advice" class="headerlink" title="2.2 创建一个 Aspect Advice"></a>2.2 创建一个 Aspect Advice</h3><p>为了演示如何集成Hystrix，我们将以此客户端为例。</p>
<p>为此，<strong>我们将定义一个在执行invokeRemoteService时将启动的Around Advice</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"@annotation(com.doleje.hystrix.HystrixCircuitBreaker)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">circuitBreakerAround</span><span class="params">(ProceedingJoinPoint aJoinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RemoteServiceCommand(config, aJoinPoint).execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述建议被设计为在使用<em>@HystrixCircuitBreaker</em>注释的切入点处执行的<em>Around</em>建议。</p>
<p>现在让我们看一下<em>HystrixCircuitBreaker</em>注释的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HystrixCircuitBreaker &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Hystrix逻辑"><a href="#2-3-Hystrix逻辑" class="headerlink" title="2.3 Hystrix逻辑"></a>2.3 Hystrix逻辑</h3><p>现在让我们来看看<em>RemoteServiceCommand</em>。它在示例代码中实现为<em>静态内部类</em>，以便封装Hystrix调用逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteServiceCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ProceedingJoinPoint joinPoint;</span><br><span class="line"> </span><br><span class="line">    RemoteServiceCommand(Setter config, ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">        <span class="keyword">super</span>(config);</span><br><span class="line">        <span class="keyword">this</span>.joinPoint = joinPoint;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(th);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在<a href="https://github.com/eugenp/tutorials/blob/master/hystrix/src/main/java/com/doleje/hystrix/HystrixAspect.java" target="_blank" rel="noopener">此处</a>看到<em>Aspect</em>组件的整个实现。</p>
<h3 id="2-4-添加-HystrixCircuitBreaker-注解"><a href="#2-4-添加-HystrixCircuitBreaker-注解" class="headerlink" title="2.4 添加 @HystrixCircuitBreaker 注解"></a>2.4 添加 @HystrixCircuitBreaker 注解</h3><p>一旦定义了 Aspect，我们就可以使用<em>@HystrixCircuitBreaker</em>注释我们的客户端方法，如下所示，并且每次调用注释的方法都会激发Hystrix：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCircuitBreaker</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">invokeRemoteServiceWithHystrix</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RemoteServiceTestSimulator(remoteServiceDelay).execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下积分测试将证明Hystrix路线和非Hystrix路线之间的差异。</p>
<h3 id="2-5-测试集成"><a href="#2-5-测试集成" class="headerlink" title="2.5 测试集成"></a>2.5 测试集成</h3><p>出于演示的目的，我们已经定义了两个方法执行路由，一个是Hystrix，另一个是没有。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAndHystrixIntegrationTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HystrixController hystrixController;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span>(expected = HystrixRuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">givenTimeOutOf15000_whenClientCalledWithHystrix_thenExpectHystrixRuntimeException</span>()</span></span><br><span class="line"><span class="class">      <span class="title">throws</span> <span class="title">InterruptedException</span> </span>&#123;</span><br><span class="line">        hystrixController.withHystrix();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenTimeOutOf15000_whenClientCalledWithOutHystrix_thenExpectSuccess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        assertThat(hystrixController.withOutHystrix(), equalTo(<span class="string">"Success"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当测试执行时，您可以看到没有Hystrix的方法调用将等待远程服务的整个执行时间，而Hystrix路由将短路并在定义的超时后抛出<em>HystrixRuntimeException</em>，在我们的情况下为10秒。</p>
<h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3.结论</h2><p>我们可以为每个远程服务调用创建一个方面，我们希望使用不同的配置。在下一篇文章中，我们将介绍从项目开始时集成Hystrix。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>王维的《画》</title>
    <url>/2014/03/27/wang-wei-de-hua/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>王维的《画》</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">远看山有色，近听水无声。</span><br><span class="line"></span><br><span class="line">春去花还在，人来鸟不惊。</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-18.png" alt="王维的《画》"></p>
<a id="more"></a>
<p>估计是个中国人都会念这首诗，大家都知道这是王维的诗，语文课本上面就标了，很清楚啊。王维作。</p>
<p>我们放下这个作者问题，先欣赏一下诗。这个诗可以说十分简单，但韵味十足，而且是一个极好的谜题。</p>
<p>读了这首题，就能感觉到迎面而来的画意，山色斑斓，水流如绢。但走近了，想听听溪水的声音，却怎么也听不见。春天已经过去了，可这里的花还开着，树上的鸟儿多么大胆，人靠近了，它们也不飞走。</p>
<p>可以说，这就是一幅活灵活现的字画。</p>
<p>苏轼评价王维：味摩诘之诗，诗中有画；观摩诘之画，画中有诗</p>
<p>摩诘是王维的字号。</p>
<p>但是，现在有人提出来，这个诗可能不是王维写的。</p>
<p>为什么呢？因为《全唐诗》里没有收录这首诗。当然在王维的目录下也没有这首诗。这首诗可能只是题在了王维的画上。</p>
<p>那这首诗是谁写的呢？</p>
<p>有人认为是清朝诗人高鼎，这位高鼎曾经写过一首很不错的诗，叫《村居》：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">草长莺飞二月天，拂堤杨柳醉春烟。</span><br><span class="line"></span><br><span class="line">儿童散学归来早，忙趁东风放纸鸢。</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<p>很有田园诗的气质。</p>
<p>但是，也没有确切的证据。而且有人考据，《画这首诗》其实是有先作的，在南宋时期，有一位道川禅师，他就写了一首诗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">远观山有色，近听水无声。</span><br><span class="line"></span><br><span class="line">春去花犹在，人来鸟不惊。</span><br><span class="line"></span><br><span class="line">头头皆显露，物物体元平。</span><br><span class="line"></span><br><span class="line">如何言不会，只为转分明。</span><br></pre></td></tr></table></figure>
<p>在一本佛经里发现了这首诗，这是我们发现关于这首诗最早的出处。</p>
<p><img src="/images/pasted-20.png" alt="upload successful"></p>
<p>那是道川禅师抄了王维的，还是人家把道川禅师的诗挂到王维头上呢？</p>
<p>这谁也说不清了，其实除了这些说法，还有人认为是元代王冕写的，有的认为是明代唐伯虎写的。</p>
<p>不管谁写的，总而言之是一首好诗无疑。</p>
<p>可见，中国的诗文化博大精深，一首诗里面包含着好多文化故事。</p>
]]></content>
      <categories>
        <category>诗和远方</category>
      </categories>
      <tags>
        <tag>古诗鉴赏</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Spring 发送邮件的注意事项</title>
    <url>/2008/03/21/yong-spring-fa-song-you-jian-de-zhu-yi-shi-xiang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用Spring 的封装的MailSender，确实省事多了！ 但在使用中,还是得注意些问题，记录如下：</p>
<a id="more"></a>
<ol>
<li><p>增加验证,否则会报:553 authentication is required 的错误信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties(); </span><br><span class="line">prop.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>); </span><br><span class="line">JavaMailSenderImpl.setJavaMailProperties(prop);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> ：此处 <code>prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);</code> 中 true 必须用双引号引用起来，不然会报错，具体原因参考 Properties 文档。</p>
</blockquote>
</li>
<li><p>当邮件内容是HTML语言时的中文问题</p>
<p>初始化MimeMessageHelper辅助类时，设置”GBK” encoding！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MimeMessageHelper messageHelp = <span class="keyword">new</span> MimeMessageHelper(message,<span class="keyword">true</span>,<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure>
<p>同时在设置：<code>&lt;META http-equiv=Content-Type content=&#39;text/html; charset=GBK&#39;&gt;</code><br>如果都设置为”UTF-8”，在某些邮件客户端标题是冷僻字时，不能正常显示！ </p>
</li>
<li><p>邮件附件的中文问题</p>
<p>spring的文档里面说MimeMessageHelper设置了encoding,同时对title,text,attach产生作用，但还是会出问题，解决方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MimeUtility.encodeWord(file.getName());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以下是一段完整的邮件发送测试代码，暂无附件设置 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MailTest.java</span></span><br><span class="line"><span class="comment"> * Created on 2008-1-23 下午04:56:38</span></span><br><span class="line"><span class="comment"> * Description: Test for mail sending</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.MailSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.SimpleMailMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.JavaMailSenderImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@163.com"&gt;Iven&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> MailSender sender = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SimpleMailMessage message = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		sender = <span class="keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">		((JavaMailSenderImpl)sender).setHost(<span class="string">"smtp.163.com"</span>);</span><br><span class="line">		((JavaMailSenderImpl)sender).setUsername(<span class="string">"username"</span>);</span><br><span class="line">		((JavaMailSenderImpl)sender).setPassword(<span class="string">"password"</span>);</span><br><span class="line">		Properties config = <span class="keyword">new</span> Properties();</span><br><span class="line">		config.put(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line">		((JavaMailSenderImpl)sender).setJavaMailProperties(config);</span><br><span class="line">		message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		message.setTo(<span class="string">"huangfengjing@yahoo.com.cn"</span>);</span><br><span class="line">		message.setSubject(<span class="string">"Test my owen sending program"</span>);</span><br><span class="line">		message.setFrom(<span class="string">"huangfengjing@gmail.com"</span>);</span><br><span class="line">		message.setText(<span class="string">"Test......"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.assertNotNull(sender);</span><br><span class="line">		</span><br><span class="line">		sender.send(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><blockquote>
<p><strong>注意</strong>：在用户名和密码都没有问题的情况下，如果代码抛出javax.mail.AuthenticationFailedException异常，先用OutLook测试一下看能否进行正常的收发邮件，有时信箱如果是新注册的话，邮件的服务商默认刚注册的帐号是不能使用pop3的。例如163.com在我进行代码测试时，刚刚注册的帐号是没有权限使用该功能的，所以就会抛出上述的异常。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>短路式编程（Fast-Break）</title>
    <url>/2016/11/29/duan-lu-shi-bian-cheng-fast-break/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>目标</strong> ：优化代码结构中的嵌套层次，减少代码缩进，提升代码可以性，可理解性；</p>
<h3 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSensitiveWord</span><span class="params">(String targetWord)</span> </span>&#123;</span><br><span class="line">    String sensitiveWordKey = <span class="string">"developer.sensitiveword"</span>;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtil.isNotEmpty(targetWord)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isNotEmpty(sensitiveWordKey)) &#123;</span><br><span class="line">            List&lt;String&gt; wordList = redisService.getList(sensitiveWordKey);</span><br><span class="line">            <span class="keyword">if</span> (wordList != <span class="keyword">null</span> &amp;&amp; wordList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (targetWord.equals(word)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong> ：正向思维，编码过程中，一直在思索正常的流程情况是什么样的。</p>
<a id="more"></a>
<h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSensitiveWord</span><span class="params">(String targetWord)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(targetWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(sensitiveWordKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String sensitiveWordKey = <span class="string">"developer.sensitiveword"</span>;</span><br><span class="line">    List&lt;String&gt; result = redisService.getList(sensitiveWordKey);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == result || result.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result.contains(targetWord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方式</strong> ：逆向思维，编码过程中逐步排除异常情况，并迅速给出反馈，中断流程。</p>
]]></content>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池的简单实现</title>
    <url>/2009/07/07/xian-cheng-chi-de-jian-dan-shi-xian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近看了下JAVA线程相关的资料，顺便写了个自己的线程池的实现方式，记录一下。 </p>
<h4 id="简单任务的定义"><a href="#简单任务的定义" class="headerlink" title="简单任务的定义"></a>简单任务的定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Task </span></span><br><span class="line"><span class="comment"> * Created on: 2008-9-29 上午10:29:18 </span></span><br><span class="line"><span class="comment"> * Description:  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.ivan.thread;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt; </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="工作线程的定义"><a href="#工作线程的定义" class="headerlink" title="工作线程的定义"></a>工作线程的定义</h4><p>用于执行任务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WorkThread</span></span><br><span class="line"><span class="comment"> * Created on: 2008-9-29 上午10:30:06</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.ivan.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程关闭的标识位</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> shutDown = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程池管理器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ThreadPoolManager mgr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 任务队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;Task&gt; taskQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WorkThread</span><span class="params">(ThreadPoolManager mgr, Queue&lt;Task&gt; taskQueue, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.mgr = mgr;</span><br><span class="line">		<span class="keyword">this</span>.taskQueue = taskQueue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!shutDown) &#123;</span><br><span class="line">			Task task;</span><br><span class="line">			<span class="comment">// 如果任务队列不为空，则取出一个任务并开始执行，否则线程等等</span></span><br><span class="line">			<span class="keyword">if</span>(!taskQueue.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(taskQueue) &#123;</span><br><span class="line">					task = taskQueue.poll();</span><br><span class="line">				&#125;</span><br><span class="line">				task.execute();</span><br><span class="line">				<span class="comment">// 任务执行完毕之后释放线程到空闲线程队列中</span></span><br><span class="line">				mgr.releaseThread(<span class="keyword">this</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">synchronized</span>(taskQueue) &#123;</span><br><span class="line">						taskQueue.wait();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shutDown = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池管理器"><a href="#线程池管理器" class="headerlink" title="线程池管理器"></a>线程池管理器</h4><p>核心的线程管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPoolManager</span></span><br><span class="line"><span class="comment"> * Created on: 2008-9-29 上午10:34:09</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.ivan.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 空闲线程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;WorkThread&gt; idleThread;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 任务队列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;Task&gt; taskQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程池大小</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> poolSize;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(DEFAULT_POOL_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolManager</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(poolSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.poolSize = DEFAULT_POOL_SIZE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">		&#125;</span><br><span class="line">		idleThread = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;WorkThread&gt;();</span><br><span class="line">		taskQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Task&gt;();</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化线程池，新建 N 个空闲线程</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Start up thread pool..."</span>);</span><br><span class="line">		<span class="keyword">synchronized</span>(taskQueue) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">				WorkThread workThread = <span class="keyword">new</span> WorkThread(<span class="keyword">this</span>, taskQueue, <span class="string">"Thread "</span> + i);</span><br><span class="line">				idleThread.add(workThread);</span><br><span class="line">				POOL_SIZE++;</span><br><span class="line">				workThread.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 关闭线程池，关闭线程池中各个线程</span></span><br><span class="line"><span class="comment">	 * 在调用该方法后，线程并没有马上关闭，而是在线程任务执行完之后关闭</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Shut down all work thread..."</span>);</span><br><span class="line">		<span class="keyword">synchronized</span>(taskQueue) &#123;</span><br><span class="line">			<span class="keyword">for</span>(WorkThread thread : idleThread) &#123;</span><br><span class="line">				thread.shutDown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加任务并唤醒各因无任务而等待的空闲线程</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Task task)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(taskQueue) &#123;</span><br><span class="line">			taskQueue.add(task);</span><br><span class="line">			taskQueue.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void schedule() throws Exception &#123;</span></span><br><span class="line"><span class="comment">//		while(!shutDown) &#123;</span></span><br><span class="line"><span class="comment">//			if(!taskQueue.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//				WorkThread workThread = getIdleThread();</span></span><br><span class="line"><span class="comment">//				synchronized(workThread) &#123;</span></span><br><span class="line"><span class="comment">//					workThread.notifyAll();</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125; else &#123;</span></span><br><span class="line"><span class="comment">//				taskQueue.wait();</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取空闲线程，当线程池内无空闲线程时等待</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WorkThread <span class="title">getIdleThread</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(idleThread.isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"No idle thread in pool, please wait..."</span>);</span><br><span class="line">			idleThread.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span>(idleThread) &#123;</span><br><span class="line">			<span class="keyword">return</span> idleThread.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 释放线程</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> thread</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseThread</span><span class="params">(WorkThread thread)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Release the thread ["</span> + thread.getName() + <span class="string">"] to the pool..."</span>);</span><br><span class="line">		<span class="keyword">synchronized</span>(idleThread) &#123;</span><br><span class="line">			idleThread.add(thread);</span><br><span class="line">			idleThread.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>测试起来就比较简单，为了模拟线程效果，在任务中只是打印一行执行过程，并让线程睡眠一段时间，同样，在所有任务执行完成后，让线程池睡眠一段时间再关闭： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SimpleTask</span></span><br><span class="line"><span class="comment"> * Created on: 2008-9-29 上午10:47:07</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.ivan.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.ccnu.inc.ivan.util.DateUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTask</span> <span class="keyword">implements</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"["</span> + DateUtils.getTimeNow() + <span class="string">"] Task["</span> + getNum() + <span class="string">"]:I have worked in thread ["</span> + Thread.currentThread().getName() + <span class="string">"]"</span>);</span><br><span class="line">			Thread.sleep(Math.round(Math.random() * <span class="number">1000</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestThreadPoolManager</span></span><br><span class="line"><span class="comment"> * Created on: 2008-9-29 上午10:45:35</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.edu.ccnu.inc.ivan.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:huangfengjing@gmail.com"&gt;Ivan&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPoolManager</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ThreadPoolManager pool = <span class="keyword">new</span> ThreadPoolManager();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			pool.addTask(<span class="keyword">new</span> SimpleTask(i));</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">		pool.shutDown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码扩展</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池拒绝策略</title>
    <url>/2017/01/06/xian-cheng-chi-ju-jue-ce-lue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>ThreadPoolExecutor</code>类实现了<code>ExecutorService</code>接口和<code>Executor</code>接口，可以设置线程池<strong>corePoolSize</strong>，最大线程池大小，<strong>AliveTime</strong>，拒绝策略等。常用构造方法：</p>
<p>当线程池的任务缓存队列已满并且线程池中的线程数目达到<strong>maximumPoolSize</strong>，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy <span class="comment">// 丢弃任务并抛出RejectedExecutionException异常。</span></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy <span class="comment">// 也是丢弃任务，但是不抛出异常。</span></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy <span class="comment">// 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy <span class="comment">// 由调用线程处理该任务</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>​    我们先看一下<code>ThreadPoolExecutor</code>的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>corePoolSize</code>： 线程池维护线程的最少数量</p>
</li>
<li><p><code>maximumPoolSize</code>：线程池维护线程的最大数量</p>
</li>
<li><p><code>keepAliveTime</code>： 线程池维护线程所允许的空闲时间</p>
</li>
<li><p><code>unit</code>： 线程池维护线程所允许的空闲时间的单位</p>
</li>
<li><p><code>workQueue</code>： 线程池所使用的缓冲队列</p>
</li>
<li><p><code>handler</code>：线程池对拒绝任务的处理策略</p>
</li>
</ol>
<p>​    当我们通过<code>execute(Runnable)</code>方法将一个任务添加到线程池时，过程如下：</p>
<ol>
<li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。</li>
<li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。  </li>
</ol>
]]></content>
      <tags>
        <tag>源码阅读</tag>
        <tag>知识技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>详解spring2.0的scope</title>
    <url>/2008/02/05/xiang-jie-spring2-0-de-scope/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="如何使用spring的作用域"><a href="#如何使用spring的作用域" class="headerlink" title="如何使用spring的作用域"></a>如何使用spring的作用域</h4><p>示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的scope就是用来配置spring bean的作用域，它标识bean的作用域。在spring2.0之前bean只有2种作用域即：singleton(单例)、non-singleton（也称prototype）, Spring2.0以后，增加了session、request、global session三种专用于Web应用程序上下文的Bean。因此，默认情况下Spring2.0现在有五种类型的Bean。 </p>
<p>当然，Spring2.0对Bean的类型的设计进行了重构，并设计出灵活的Bean类型支持，理论上可以有无数多种类型的Bean，用户可以根据自己的需要，增加新的Bean类型，满足实际应用需求。 </p>
<a id="more"></a>
<h4 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h4><p>singleton作用域当一个bean的作用域设置为singleton, 那么Spring IOC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。换言之，当把一个bean定义设置为singleton作用域时，Spring IOC容器只会创建该bean定义的唯一实例。这个单一实例会被存储到单例缓存（singleton cache）中，并且所有针对该bean的后续请求和引用都将返回被缓存的对象实例，这里要注意的是singleton作用域和GOF设计模式中的单例是完全不同的，单例设计模式表示一个ClassLoader中只有一个class存在，而这里的singleton则表示一个容器对应一个bean，也就是说当一个bean被标识为singleton时候，spring的IOC容器中只会存在一个该bean。配置实例： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">singleton</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>prototype作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）都会产生一个新的bean实例，相当与一个new的操作，对于prototype作用域的bean，有一点非常重要，那就是Spring不能对一个prototype bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个prototype实例后，将它交给客户端，随后就对该prototype实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对prototype而言，任何配置好的析构生命周期回调方法都将不会被调用。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。（让Spring容器释放被singleton作用域bean占用资源的一种可行方式是，通过使用bean的后置处理器，该处理器持有要被清除的bean的引用。） </p>
<p>配置实例： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beanid="role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><p>request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，配置实例：request、session、global session使用的时候首先要在初始化web的web.xml中做如下配置：如果你使用的是Servlet 2.4及以上的web容器，那么你仅需要在web应用的XML声明文件web.xml中增加下述ContextListener即可： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">org.springframework.web.context.request.RequestContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是Servlet2.4以前的web容器,那么你要使用一个javax.servlet.Filter的实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着既可以配置bean的作用域了： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效，配置实例：配置实例：和request配置实例的前提一样，配置好web启动文件就可以如下配置： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="global-session"><a href="#global-session" class="headerlink" title="global session"></a>global session</h4><p>global session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。如果你在web中使用global session作用域来标识bean，那么web会自动当成session类型来使用。配置实例：和request配置实例的前提一样，配置好web启动文件就可以如下配置： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role"</span> <span class="attr">class</span>=<span class="string">"spring.chapter2.maryGame.Role"</span> <span class="attr">scope</span>=<span class="string">"global session"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义bean装配作用域"><a href="#自定义bean装配作用域" class="headerlink" title="自定义bean装配作用域"></a>自定义bean装配作用域</h4><p>在spring2.0中作用域是可以任意扩展的，你可以自定义作用域，甚至你也可以重新定义已有的作用域（但是你不能覆盖singleton和prototype），spring的作用域由接口org.springframework.beans.factory.config.Scope来定义，自定义自己的作用域只要实现该接口即可，下面给个实例：我们建立一个线程的scope，该scope在表示一个线程中有效，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicclass MyScope implements Scope &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal threadScope = <span class="keyword">new</span> ThreadLocal()&#123;</span><br><span class="line">          <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="function">returnnew <span class="title">HashMap</span><span class="params">()</span></span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">         Map scope = (Map) threadScope.get();</span><br><span class="line">         Object object = scope.get(name);</span><br><span class="line">         <span class="keyword">if</span>(object==<span class="keyword">null</span>) &#123;</span><br><span class="line">           object = objectFactory.getObject();</span><br><span class="line">           scope.put(name, object);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> object;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        Map scope = (Map) threadScope.get();</span><br><span class="line">         <span class="keyword">return</span> scope.remove(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConversationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Bean Scope</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Ext2-Form表单项的不正确显示问题 </title>
    <url>/2008/01/27/jie-jue-ext2-form-biao-dan-xiang-de-bu-zheng-que-xian-shi-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在使用Ext2 form的过程中，发现了一些表单项在IE下外观显示的问题：</p>
<ol>
<li>输入框下边的线消失 </li>
<li>日期控件及combo控件右侧的图片和左侧输入域垂直方向没有对齐。<br>这让表单看起来极其难受。</li>
</ol>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>在 <strong>Ext-all.css</strong> 中找到如下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ext-ie</span> <span class="selector-class">.x-form-text</span> &#123; </span><br><span class="line">  <span class="attribute">margin-top</span>:-<span class="number">1px</span>; </span><br><span class="line">  <span class="attribute">margin-bottom</span>:-<span class="number">1px</span>; </span><br><span class="line">  <span class="attribute">height</span>:<span class="number">22px</span>; </span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">18px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后替换 <code>margin-bottom:-1px;</code> 为 <code>margin-bottom:0px;</code></p>
]]></content>
      <categories>
        <category>UED</category>
      </categories>
      <tags>
        <tag>ExtJS</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]这两首名诗到底是谁作的？</title>
    <url>/2018/03/23/zhe-liang-shou-ming-shi-dao-di-shi-shui-zuo-de/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/pasted-99.png" alt="upload successful"></p>
<p>翻读唐诗，关注到两宗“悬案”。</p>
<p>涉及到的两首唐诗都是流传千古的名篇。<br>一首是《登鹳雀楼》：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">白日依山尽，黄河入海流。</span><br><span class="line"></span><br><span class="line">欲穷千里目，更上一层楼。</span><br></pre></td></tr></table></figure></p>
<p>另一首是《清明》：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">清明时节雨纷纷，路上行人欲断魂。</span><br><span class="line"></span><br><span class="line">借问酒家何处有，牧童遥指杏花村。</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>众所周知，《登鹳雀楼》的作者是王之涣，《清明》的作者是杜牧。两位都是唐代极负盛名的诗人。一千多年的吟诵流传，两人的名字早已与两首古诗融为一体了。但是，如果有人告诉你，这两首诗的作者另有其人，你惊不惊讶，诧不诧异？</p>
<p>先说《清明》。有什么证据证明这诗不是杜牧所写呢？翻阅《全唐诗·杜牧卷》，里面没有这首诗的存在。如此有名的诗却未被收录在名家诗歌存目下，实属蹊跷。杜牧去世后，他的外甥裴延翰又整理编订了《樊川文集》，里面也没有这首诗。后来又有宋人补编《樊川外集》《樊川别集》，里面亦未见《清明》一诗的影子，使得此诗出处更加疑云重重。</p>
<p>《清明》最早出现在文献中，是在南宋末期。从时间上来说，这已经是杜牧去世三百多年之后的事儿了。</p>
<p>假若此诗真非杜牧所写，为什么偏偏冠上了他的名字呢？我们都知道，杜牧有“七绝之王”的美誉，曾写出“南朝四百八十寺，多少楼台烟雨中”，“东风不与周郎便，铜雀春深锁二乔”，“一骑红尘妃子笑，无人知是荔枝来”，“停车坐爱枫林晚，霜叶红于二月花”，“春风十里扬州路，卷上珠帘总不如”等等诸多或清新通俗、或意味隽永的诗句，而“清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村”的风格，与他的诗风是十分接近的。</p>
<p><img src="/images/pasted-100.png" alt="upload successful"></p>
<p>是不是当时有诗者写出这首诗，但因没有一定知名度，担心作品很难被流传下去，遂干脆就把署名“送”给了大名鼎鼎的杜牧呢？在那个当时代文化文本都很容易散佚或消失的时代，如果不把这首作品安在杜牧头上，写出此诗几年、十几年或者几十年之后，它便失传于凄风冷雨中，也未可知。</p>
<p>再说《登鹳雀楼》。芮挺章是盛唐时期一位非常有名气的文人，他编选了一本《国秀集》，把唐代的经典诗篇都选进集子里，当然也包括《登鹳雀楼》。然而，此诗署名却是一个叫朱斌的人。《国秀集》里选了王之涣三首诗，但《登鹳雀楼》不在他的名下。芮着手编《国秀集》之时，王之涣刚刚离世，但他的家人及老友王昌龄、高适等都还健在，如果《登鹳雀楼》确是出自王之涣之手，王昌龄与高适怎会视而不见？那还不得在第一时间找到芮挺章，为好友讨个说法？</p>
<p>清代康熙年间开始纂修《全唐诗》。这部《全唐诗》真的很“全”，共计九百卷，里面收录了当时人们所能看到的所有唐诗，共计四万八千九百余首，其中当然包含《登鹳雀楼》。有意思的是，作者那栏写的是“一作朱斌诗”，又在“一作朱斌诗”下面写了“一作王之涣诗”。估计当时负责编校《全唐诗》的彭定求、沈三曾等十人也非常“头大”，经过各方考证仍未得到确切答案，两难之中，只好采用这种“出选择题”似的署名办法。这一学术问题，几百年后的今天仍在探讨当中，只是亦未取得进展。</p>
<p><img src="/images/pasted-101.png" alt="upload successful"></p>
<p>到底谁写的《清明》？《登鹳雀楼》究竟出自王之涣还是朱斌之手？历史的真相迷失在风雨中，答案似乎已经没有那么重要了。五千年文化，三千年诗韵，这都是我们的祖先给后世子孙留下的财富，在中华诗词这条从未断流的大河之中，这些绝句佳篇姓王姓杜还是姓朱，无疑都不影响它们发散出最闪亮的光芒。</p>
<p>如果从哲学的角度出发，板桥先生的话值得一听。他说：难得糊涂。</p>
]]></content>
      <categories>
        <category>诗词鉴赏</category>
      </categories>
      <tags>
        <tag>诗词鉴赏</tag>
      </tags>
  </entry>
  <entry>
    <title>重试机制（RetryTemplate）</title>
    <url>/2017/04/23/chong-shi-ji-zhi-retrytemplate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>强制：</strong> 统一采用<code>Spring-Retry</code>库来完成重试操作，<strong>不得</strong> 通过循环等方式来自实现</p>
</blockquote>
<p>方案有如下两种（推荐采用注解方式，特殊场景可以通过 <code>RetryTemplate</code> 自行定制）：</p>
<ol>
<li><p>注解式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryCallService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ATTEMPTS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY = <span class="number">1000</span> * <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_DELAY = DELAY * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retryable</span>(value = &#123;BizException<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">            <span class="title">maxAttempts</span> </span>= MAX_ATTEMPTS,</span><br><span class="line">            backoff = <span class="meta">@Backoff</span>(delay = DELAY, maxDelay = MAX_DELAY, multiplier = <span class="number">2</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">retry</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 达到最大重试次数后的补偿方案</span></span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">recover</span><span class="params">(BizException e)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"达到最大尝试次数，执行最后的补偿操作，异常信息为：&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        log.info(<span class="string">"进行第 &#123;&#125; 次尝试，当前时间过去了：&#123;&#125; 秒"</span>, count, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(<span class="string">"模拟业务异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol start="2">
<li><p>模板模式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryCallServiceTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ATTEMPTS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INITIAL_INTERVAL = TimeUnit.SECONDS.toMillis(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_INTERVAL = TimeUnit.MINUTES.toMillis(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RetryTemplate retryTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化重试模板</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRetryTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        ExponentialBackOffPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackOffPolicy();</span><br><span class="line">        retryPolicy.setInitialInterval(INITIAL_INTERVAL);</span><br><span class="line">        retryPolicy.setMaxInterval(MAX_INTERVAL);</span><br><span class="line">        retryPolicy.setMultiplier(<span class="number">2</span>);</span><br><span class="line">        retryTemplate.setRetryPolicy(<span class="keyword">new</span> SimpleRetryPolicy(MAX_ATTEMPTS));</span><br><span class="line">        retryTemplate.setBackOffPolicy(retryPolicy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">retry</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 典型的 Spring Template 用法</span></span><br><span class="line">        retryTemplate.execute(<span class="keyword">new</span> RetryCallback&lt;Boolean, Exception&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                doSomething();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> RecoveryCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">recover</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> RetryCallServiceTwo.<span class="keyword">this</span>.recover(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 达到最大重试次数后的补偿方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">recover</span><span class="params">(RetryContext retryContext)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"达到最大尝试次数，执行最后的补偿操作，异常信息为：&#123;&#125;"</span>, retryContext.getLastThrowable().getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">0</span>) &#123;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        log.info(<span class="string">"进行第 &#123;&#125; 次尝试，当前时间过去了：&#123;&#125; 秒"</span>, count, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(<span class="string">"模拟业务异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>高效的Java异常处理</title>
    <url>/2009/03/21/gao-xiao-de-java-yi-chang-chu-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文从Java异常最基本的概念、语法开始讲述了Java异常处理的基本知识，分析了Java异常体系结构，对比Spring的异常处理框架，阐述了异常处理的基本原则。并且作者提出了自己处理一个大型应用系统异常的思想，并通过设计一个异常处理的框架来论述此思想。</p>
<a id="more"></a>
<h3 id="一、-异常的概念和Java异常体系结构"><a href="#一、-异常的概念和Java异常体系结构" class="headerlink" title="一、 异常的概念和Java异常体系结构"></a>一、 异常的概念和Java异常体系结构</h3><p>​    异常是程序运行过程中出现的错误。本文主要讲授的是Java语言的异常处理。Java语言的异常处理框架，是Java语言健壮性的一个重要体现。</p>
<p>​    Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。Java异常体系结构呈树状，其层次结构图如下所示：</p>
<p><img src="/images/pasted-2.png" alt="Java异常体系结构"></p>
<p>​    Thorwable类所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常，这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系：</p>
<p>​    <strong>1、Error与Exception</strong></p>
<p>​    Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p>​    Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。</p>
<p>​    <strong>2、运行时异常和非运行时异常</strong></p>
<p>​    运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>​    非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h3 id="二、-异常的捕获和处理"><a href="#二、-异常的捕获和处理" class="headerlink" title="二、 异常的捕获和处理"></a>二、 异常的捕获和处理</h3><p>​    Java异常的捕获和处理是一个不容易把握的事情，如果处理不当，不但会让程序代码的可读性大大降低，而且导致系统性能低下，甚至引发一些难以发现的错误。</p>
<p>​    Java异常处理涉及到五个关键字，分别是：try、catch、finally、throw、throws。下面将骤一介绍，通过认识这五个关键字，掌握基本异常处理知识。</p>
<ol>
<li><strong>异常处理的基本语法</strong></li>
</ol>
<p>在java中，异常处理的完整语法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//（尝试运行的）程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常的变量名)&#123;</span><br><span class="line">    <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上语法有三个代码块：<br>    try语句块，表示要尝试运行代码，try语句块中代码受异常监控，其中代码发生异常时，会抛出异常对象。</p>
<p>​    catch语句块会捕获try代码块中发生的异常并在其代码块中做异常处理，catch语句带一个Throwable类型的参数，表示可捕获异常类型。当try中出现异常时，catch会捕获到发生的异常，并和自己的异常类型匹配，若匹配，则执行catch块中代码，并将catch块参数指向所抛的异常对象。catch语句可以有多个，用来匹配多个中的一个异常，一旦匹配上后，就不再尝试匹配别的catch块了。通过异常对象可以获取异常发生时完整的JVM堆栈信息，以及异常信息和异常发生的原因等。</p>
<p>​    finally语句块是紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，而不管是否try语句块是否发生异常。并且这个语句块总是在方法返回前执行。目的是给程序一个补救的机会。这样做也体现了Java语言的健壮性。</p>
<ol start="2">
<li><strong>try、catch、finally三个语句块应注意的问题</strong>    第一、try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。<br> 第二、try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。<pre><code>第三、多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下。
</code></pre></li>
</ol>
<p>​    3. <strong>throw、throws关键字</strong>    throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。有关异常的转译会在下面说明。</p>
<p>​    throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣一般在catch块中打印一下堆栈信息做个勉强处理。下面给出一个简单例子，看看如何使用这两个关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//抛出一个检查异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"方法test3中的Exception"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>Throwable类中的常用方法</strong><br> getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。<pre><code>getMessage()：返回异常的消息信息。
printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 system.err 的值。
</code></pre></li>
</ol>
<h3 id="三、异常处理的一般原则"><a href="#三、异常处理的一般原则" class="headerlink" title="三、异常处理的一般原则"></a>三、异常处理的一般原则</h3><ol>
<li>能处理就早处理，抛出不去还不能处理的就想法消化掉或者转换为RuntimeException处理。因为对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能的控制异常发生的可能。</li>
<li>对于检查异常，如果不能行之有效的处理，还不如转换为RuntimeException抛出。这样也让上层的代码有选择的余地――可处理也可不处理。</li>
<li>对于一个应用系统来说，应该有自己的一套异常处理框架，这样当异常发生时，也能得到统一的处理风格，将优雅的异常信息反馈给用户。</li>
</ol>
<h3 id="四、异常的转译与异常链"><a href="#四、异常的转译与异常链" class="headerlink" title="四、异常的转译与异常链"></a>四、异常的转译与异常链</h3><p>​    1. <strong>异常转译的原理</strong></p>
<p>​    所谓的异常转译就是将一种异常转换另一种新的异常，也许这种新的异常更能准确表达程序发生异常。</p>
<p>​    在Java中有个概念就是异常原因，异常原因导致当前抛出异常的那个异常对象，几乎所有带异常原因的异常构造方法都使用Throwable类型做参数，这也就为异常的转译提供了直接的支持，因为任何形式的异常和错误都是Throwable的子类。比如将SQLException转换为另外一个新的异常DAOException，可以这么写：</p>
<p>​    先自定义一个异常DAOException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAOException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(省略了部分代码)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DAOException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    比如有一个SQLException类型的异常对象e，要转换为DAOException，可以这么写：</p>
<p>​    DAOException daoEx = new DAOException ( “SQL异常”, e);</p>
<p>​    异常转译是针对所有继承Throwable超类的类而言的，从编程的语法角度讲，其子类之间都可以相互转换。但是，从合理性和系统设计角度考虑，可将异常分为三类：Error、Exception、RuntimeException，笔者认为，合理的转译关系图应该如下图所示：</p>
<p><img src="/images/pasted-3.png" alt="异常转译关系图"></p>
<ol start="2">
<li><strong>异常转译</strong></li>
</ol>
<p>​    为什么要这么做呢？笔者认为，异常的处理存在着一套哲学思想：<strong>对于一个应用系统来说，系统所发生的任何异常或者错误对操作用户来说都是系统”运行时”异常，都是这个应用系统内部的异常。这也是异常转译和应用系统异常框架设计的指导原则。</strong>在系统中大量处理非检查异常的负面影响很多，最重要的一个方面就是代码可读性降低，程序编写复杂，异常处理的代码也很苍白无力。因此，很有必要将这些检查异常Exception和错误Error转换为RuntimeException异常，让程序员根据情况来决定是否捕获和处理所发生的异常。</p>
<p>​    <strong>图中的三条线标识转换的方向，分三种情况：</strong></p>
<p>​    ①：Error到Exception：将错误转换为异常，并继续抛出。例如Spring WEB框架中，将org.springframework.web.servlet.DispatcherServlet的doDispatch()方法中，将捕获的错误转译为一个NestedServletException异常。这样做的目的是为了最大限度挽回因错误发生带来的负面影响。因为一个Error常常是很严重的错误，可能会引起系统挂起。</p>
<p>​    ②：Exception到RuntimeException：将检查异常转换为RuntimeException可以让程序代码变得更优雅，让开发人员集中经理设计更合理的程序代码，反过来也增加了系统发生异常的可能性。</p>
<p>​    ③：Error到RuntimeException：目的还是一样的。把所有的异常和错误转译为不检查异常，这样可以让代码更为简洁，还有利于对错误和异常信息的统一处理。</p>
<p>​    3. <strong>异常链</strong></p>
<p>​    异常链顾名思义就是将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出。Java API文档中给出了一个简单的模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     lowLevelOp();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LowLevelException le) &#123;</span><br><span class="line">     <span class="keyword">throw</span> (HighLevelException)</span><br><span class="line">      <span class="keyword">new</span> HighLevelException().initCause(le);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序捕获到了一个底层异常le，在处理部分选择了继续抛出一个更高级别的新异常给此方法的调用者。这样异常的原因就会逐层传递。这样，位于高层的异常递归调用getCause()方法，就可以遍历各层的异常原因。这就是Java异常链的原理。异常链的实际应用很少，发生异常时候逐层上抛不是个好注意，上层拿到这些异常又能奈之何？而且异常逐层上抛会消耗大量资源，因为要保存一个完整的异常链信息。</p>
<h3 id="五、-设计一个高效合理的异常处理框架"><a href="#五、-设计一个高效合理的异常处理框架" class="headerlink" title="五、 设计一个高效合理的异常处理框架"></a>五、 设计一个高效合理的异常处理框架</h3><p>​    对于一个应用系统来说，发生所有异常在用户看来都是应用系统内部的异常。因此应该设计一套应用系统的异常框架，以处理系统运行过程中的所有异常。</p>
<p>​    基于这种观点，可以设计一个应用系统的异常比如叫做AppException。并且对用户来说，这些异常都是运行应用系统运行时发生的，因此AppException应该继承RuntimeException，这样系统中所有的其他异常都转译为AppException，当异常发生的时候，前端接收到AppExcetpion并做统一的处理。画出异常处理框架如下图 ：</p>
<p><img src="/images/pasted-4.png" alt="应用系统的异常处理框架"></p>
<p>​    在这个设计图中，AppRuntimeException是系统异常的基类，对外只抛出这个异常，这个异常可以由前端（客户端）接收处理，当异常发生时，客户端的相关组件捕获并处理这些异常，将”友好”的信息展示给客户。</p>
<p>​    在AppRuntimeException下层，有各种各样的异常和错误，最终都转译为AppRuntimeException，AppRuntimeException下面还可以设计一些别的子类异常，比如AppDAOException、OtherException等，这些都根据实际需要灵活处理。在往下就是如何将捕获的原始异常比如SQLException、HibernateException转换为更高级一点AppDAOException。</p>
<p>​    有关异常框架设计这方面公认比较好的就是Spring，Spring中的所有异常都可以用org.springframework.core.NestedRuntimeException来表示，并且该基类继承的是RuntimeException。Spring框架很庞大，因此设计了很多NestedRuntimeException的子类，还有异常转换的工具，这些都是非常优秀的设计思想。</p>
<h3 id="六、-Java异常处理总结"><a href="#六、-Java异常处理总结" class="headerlink" title="六、 Java异常处理总结"></a>六、 Java异常处理总结</h3><p>回顾全文，总结一下Java异常处理的要点：</p>
<p>​    1、 异常是程序运行过程过程出现的错误，在Java中用类来描述，用对象来表示具体的异常。Java将其区分为Error与Exception，Error是程序无力处理的错误，Exception是程序可以处理的错误。异常处理是为了程序的健壮性。<br>​    2、 Java异常类来自于Java API定义和用户扩展。通过继承Java API异常类可以实现异常的转译。</p>
]]></content>
      <categories>
        <category>理论与实践</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>网络请求模板（RestTemplate）</title>
    <url>/2017/02/03/wang-luo-qing-qiu-mo-ban-resttemplate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于返回格式为<code>JSON</code>的资源或者 Restful 接口，统一采用<code>RestTemplate</code>来请求，其它类型响应数据的也建议采用不同的<code>MessageConverter</code>来实现，<strong>不</strong> 建议再延续使用自定义的类似<code>HttpUtils</code>，<code>HttpHelper</code>之类的工具类。</p>
<a id="more"></a>
<h3 id="RestTemplate-的统一配置"><a href="#RestTemplate-的统一配置" class="headerlink" title="RestTemplate 的统一配置"></a>RestTemplate 的统一配置</h3><p>根据业务场景的实际需要，全局统一配置<code>RestTemplate</code>，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(ClientHttpRequestFactory factory)</span> </span>&#123;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(factory);</span><br><span class="line">        restTemplate.getMessageConverters().add(<span class="keyword">new</span> PlainTextJackson2HttpMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">simpleClientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleClientHttpRequestFactory factory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">        factory.setReadTimeout(<span class="number">5000</span>);</span><br><span class="line">        factory.setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持普通文本的转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainTextJackson2HttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">MappingJackson2HttpMessageConverter</span> </span>&#123;</span><br><span class="line">        PlainTextJackson2HttpMessageConverter() &#123;</span><br><span class="line">            List&lt;MediaType&gt; mediaTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            mediaTypes.add(MediaType.TEXT_PLAIN);</span><br><span class="line">            mediaTypes.add(MediaType.TEXT_HTML);</span><br><span class="line">            mediaTypes.add(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line">            setSupportedMediaTypes(mediaTypes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li><p>简单场景：返回普通的 String</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(config.getVmsServerGateway())</span><br><span class="line">                    .queryParam(<span class="string">"fromUserCode"</span>, config.getVmsFromUserCode())</span><br><span class="line">                    .queryParam(<span class="string">"toUserCode"</span>, account)</span><br><span class="line">                    .queryParam(<span class="string">"msgText"</span>, content)</span><br><span class="line">                    .queryParam(<span class="string">"key"</span>, DigestUtils.md5Hex(config.getVmsFromUserCode() + account + config.getVmsKey())).build();</span><br><span class="line">            log.info(<span class="string">"URL:&#123;&#125;"</span>, uriComponents.toUriString());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Get 方法</span></span><br><span class="line">            String result = restTemplate.getForObject(uriComponents.toUriString(), String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式化数据场景</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entities = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> HttpHeaders());</span><br><span class="line">        ApiResult&lt;SearchResult&gt; result = restTemplate.exchange(uriComponents.toUriString(), HttpMethod.POST, entities,</span><br><span class="line">                <span class="keyword">new</span> ParameterizedTypeReference&lt;ApiResult&lt;SearchResult&gt;&gt;() &#123;&#125;).getBody();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：序列化方式依赖系统中配置的<code>MessageConverter</code></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>最佳实践</tag>
      </tags>
  </entry>
</search>
